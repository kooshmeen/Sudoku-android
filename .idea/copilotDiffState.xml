<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt" />
              <option name="originalContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;game_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onContinueGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)  &#10;                                },&#10;                                onStartNewGame = { difficulty -&gt;&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;game_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt" />
              <option name="originalContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow modifying original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Check for conflicts&#10;        val gridValues = Array(9) {r -&gt; IntArray(9) { c -&gt; grid[r][c].value } }&#10;        val hasConflict = !SudokuValidator.isValidMove(gridValues, row, col, value)&#10;&#10;        // Update the cell&#10;        val newGrid = grid.map { it.clone() }.toTypedArray()&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(), // Clear notes when setting a value&#10;            hasError = hasConflict&#10;        )&#10;&#10;        // Update error cells&#10;        if (hasConflict) {&#10;            errorCells = errorCells + Pair(row, col)&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;&#10;        grid = newGrid&#10;&#10;        // Check if game is completed after this move&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    private fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = grid.map { it.clone() }.toTypedArray()&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = grid.map { it.clone() }.toTypedArray()&#10;        newGrid[row][col] = currentCell.copy()&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = grid.map { it.clone() }.toTypedArray()&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                )&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;&#10;        // Generate a new puzzle based on difficulty&#10;        grid = SudokuGenerator.generatePuzzle(difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow modifying original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Check for conflicts&#10;        val gridValues = Array(9) {r -&gt; IntArray(9) { c -&gt; grid[r][c].value } }&#10;        val hasConflict = !SudokuValidator.isValidMove(gridValues, row, col, value)&#10;&#10;        // Update the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(), // Clear notes when setting a value&#10;            hasError = hasConflict&#10;        )&#10;&#10;        // Update error cells&#10;        if (hasConflict) {&#10;            errorCells = errorCells + Pair(row, col)&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;&#10;        grid = newGrid&#10;&#10;        // Check if game is completed after this move&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    private fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = SudokuCell() // Create a new empty cell&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    hasError = false&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = SudokuCell(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    isOriginal = grid[action.row][action.col].isOriginal&#10;                )&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;&#10;        // Generate a new puzzle based on difficulty&#10;        grid = SudokuGenerator.generatePuzzle(difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameStateManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameStateManager.kt" />
              <option name="updatedContent" value="/**&#10; * Global game state manager&#10; * Provides a singleton instance of GameState that can be shared across screens&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;object GameStateManager {&#10;    private val _gameState = GameState()&#10;    &#10;    val gameState: GameState get() = _gameState&#10;    &#10;    /**&#10;     * Check if there's an active game that can be continued&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return _gameState.hasActiveGame()&#10;    }&#10;    &#10;    /**&#10;     * Start a new game with the specified difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        _gameState.startNewGame(difficulty)&#10;    }&#10;    &#10;    /**&#10;     * Continue the current active game&#10;     */&#10;    fun continueGame() {&#10;        _gameState.continueGame()&#10;    }&#10;    &#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        _gameState.endGame()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SudokuGenerator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SudokuGenerator.kt" />
              <option name="originalContent" value="/**&#10; * SudokuGenerator.kt&#10; * Generates a Sudoku puzzle by randomly filling the 3x3 grids on the diagonal&#10; * then filling the rest of the grid using backtracking.&#10; * Then strategically removes numbers depending on selected difficulty.&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import kotlin.random.Random&#10;&#10;class SudokuGenerator {&#10;    companion object {&#10;        private const val GRID_SIZE = 9&#10;        private const val BOX_SIZE = 3&#10;&#10;        // Difficulty settings - number of cells to remove&#10;        private const val EASY_CELLS_TO_REMOVE = 40&#10;        private const val MEDIUM_CELLS_TO_REMOVE = 50&#10;        private const val HARD_CELLS_TO_REMOVE = 60&#10;&#10;        /**&#10;         * Generate a complete Sudoku puzzle with given difficulty&#10;         */&#10;        fun generatePuzzle(difficulty: String): Array&lt;Array&lt;SudokuCell&gt;&gt; {&#10;            val generator = SudokuGenerator()&#10;            val completeGrid = generator.generateCompleteGrid()&#10;            val puzzle = generator.createPuzzle(completeGrid, difficulty)&#10;            return puzzle&#10;        }&#10;    }&#10;&#10;    private val grid = Array(GRID_SIZE) { IntArray(GRID_SIZE) }&#10;&#10;    /**&#10;     * Generate a complete valid Sudoku grid&#10;     */&#10;    private fun generateCompleteGrid(): Array&lt;IntArray&gt; {&#10;        // Fill diagonal 3x3 boxes first (they don't depend on each other)&#10;        fillDiagonalBoxes()&#10;&#10;        // Fill remaining cells using backtracking&#10;        fillRemaining(0, BOX_SIZE)&#10;&#10;        return grid.map { it.clone() }.toTypedArray()&#10;    }&#10;&#10;    /**&#10;     * Fill the three diagonal 3x3 boxes&#10;     */&#10;    private fun fillDiagonalBoxes() {&#10;        for (i in 0 until GRID_SIZE step BOX_SIZE) {&#10;            fillBox(i, i)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fill a 3x3 box starting at (row, col)&#10;     */&#10;    private fun fillBox(row: Int, col: Int) {&#10;        val numbers = (1..9).shuffled(Random.Default)&#10;        var index = 0&#10;&#10;        for (i in 0 until BOX_SIZE) {&#10;            for (j in 0 until BOX_SIZE) {&#10;                grid[row + i][col + j] = numbers[index++]&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fill remaining cells using backtracking&#10;     */&#10;    private fun fillRemaining(row: Int, col: Int): Boolean {&#10;        var currentRow = row&#10;        var currentCol = col&#10;&#10;        // If we've filled all cells, we're done&#10;        if (currentRow &gt; GRID_SIZE - 1 &amp;&amp; currentCol &gt; GRID_SIZE - 1) {&#10;            return true&#10;        }&#10;&#10;        // Move to next cell&#10;        if (currentCol &gt;= GRID_SIZE &amp;&amp; currentRow &lt; GRID_SIZE - 1) {&#10;            currentRow += 1&#10;            currentCol = 0&#10;        }&#10;&#10;        // Skip cells that are already filled (diagonal boxes)&#10;        if (grid[currentRow][currentCol] != 0) {&#10;            return fillRemaining(currentRow, currentCol + 1)&#10;        }&#10;&#10;        // Try numbers 1-9 in random order&#10;        val numbers = (1..9).shuffled(Random.Default)&#10;&#10;        for (num in numbers) {&#10;            if (isSafe(currentRow, currentCol, num)) {&#10;                grid[currentRow][currentCol] = num&#10;&#10;                if (fillRemaining(currentRow, currentCol + 1)) {&#10;                    return true&#10;                }&#10;&#10;                // Backtrack&#10;                grid[currentRow][currentCol] = 0&#10;            }&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Check if it's safe to place a number at given position&#10;     */&#10;    private fun isSafe(row: Int, col: Int, num: Int): Boolean {&#10;        return !usedInRow(row, num) &amp;&amp;&#10;               !usedInCol(col, num) &amp;&amp;&#10;               !usedInBox(row - row % BOX_SIZE, col - col % BOX_SIZE, num)&#10;    }&#10;&#10;    /**&#10;     * Check if number is used in the row&#10;     */&#10;    private fun usedInRow(row: Int, num: Int): Boolean {&#10;        for (col in 0 until GRID_SIZE) {&#10;            if (grid[row][col] == num) {&#10;                return true&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Check if number is used in the column&#10;     */&#10;    private fun usedInCol(col: Int, num: Int): Boolean {&#10;        for (row in 0 until GRID_SIZE) {&#10;            if (grid[row][col] == num) {&#10;                return true&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Check if number is used in the 3x3 box&#10;     */&#10;    private fun usedInBox(boxStartRow: Int, boxStartCol: Int, num: Int): Boolean {&#10;        for (row in 0 until BOX_SIZE) {&#10;            for (col in 0 until BOX_SIZE) {&#10;                if (grid[boxStartRow + row][boxStartCol + col] == num) {&#10;                    return true&#10;                }&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Create a puzzle by removing numbers from the complete grid&#10;     */&#10;    private fun createPuzzle(completeGrid: Array&lt;IntArray&gt;, difficulty: String): Array&lt;Array&lt;SudokuCell&gt;&gt; {&#10;        val puzzle = Array(GRID_SIZE) { row -&gt;&#10;            Array(GRID_SIZE) { col -&gt;&#10;                SudokuCell(&#10;                    value = completeGrid[row][col],&#10;                    isOriginal = true&#10;                )&#10;            }&#10;        }&#10;&#10;        val cellsToRemove = when (difficulty.lowercase()) {&#10;            &quot;easy&quot; -&gt; EASY_CELLS_TO_REMOVE&#10;            &quot;medium&quot; -&gt; MEDIUM_CELLS_TO_REMOVE&#10;            &quot;hard&quot; -&gt; HARD_CELLS_TO_REMOVE&#10;            else -&gt; EASY_CELLS_TO_REMOVE&#10;        }&#10;&#10;        // Get all cell positions and shuffle them&#10;        val allPositions = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        for (row in 0 until GRID_SIZE) {&#10;            for (col in 0 until GRID_SIZE) {&#10;                allPositions.add(Pair(row, col))&#10;            }&#10;        }&#10;        allPositions.shuffle(Random.Default)&#10;&#10;        // Remove numbers from random positions&#10;        var removed = 0&#10;        for (position in allPositions) {&#10;            if (removed &gt;= cellsToRemove) break&#10;&#10;            val (row, col) = position&#10;            puzzle[row][col] = SudokuCell(&#10;                value = 0,&#10;                isOriginal = false&#10;            )&#10;            removed++&#10;        }&#10;&#10;        return puzzle&#10;    }&#10;}" />
              <option name="updatedContent" value="/**&#10; * SudokuGenerator.kt&#10; * Generates a Sudoku puzzle by randomly filling the 3x3 grids on the diagonal&#10; * then filling the rest of the grid using backtracking.&#10; * Then strategically removes numbers depending on selected difficulty.&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import kotlin.random.Random&#10;&#10;class SudokuGenerator {&#10;    companion object {&#10;        private const val GRID_SIZE = 9&#10;        private const val BOX_SIZE = 3&#10;&#10;        // Difficulty settings - number of cells to remove&#10;        private const val EASY_CELLS_TO_REMOVE = 40&#10;        private const val MEDIUM_CELLS_TO_REMOVE = 50&#10;        private const val HARD_CELLS_TO_REMOVE = 60&#10;&#10;        /**&#10;         * Generate a complete Sudoku puzzle with given difficulty&#10;         */&#10;        fun generatePuzzle(difficulty: String): Array&lt;Array&lt;SudokuCell&gt;&gt; {&#10;            val generator = SudokuGenerator()&#10;            val completeGrid = generator.generateCompleteGrid()&#10;            val puzzle = generator.createPuzzle(completeGrid, difficulty)&#10;            return puzzle&#10;        }&#10;    }&#10;&#10;    private val grid = Array(GRID_SIZE) { IntArray(GRID_SIZE) }&#10;&#10;    /**&#10;     * Generate a complete valid Sudoku grid&#10;     */&#10;    private fun generateCompleteGrid(): Array&lt;IntArray&gt; {&#10;        // Fill diagonal 3x3 boxes first (they don't depend on each other)&#10;        fillDiagonalBoxes()&#10;&#10;        // Fill remaining cells using backtracking&#10;        fillRemaining(0, BOX_SIZE)&#10;&#10;        return grid.map { it.clone() }.toTypedArray()&#10;    }&#10;&#10;    /**&#10;     * Fill the three diagonal 3x3 boxes&#10;     */&#10;    private fun fillDiagonalBoxes() {&#10;        for (i in 0 until GRID_SIZE step BOX_SIZE) {&#10;            fillBox(i, i)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fill a 3x3 box starting at (row, col)&#10;     */&#10;    private fun fillBox(row: Int, col: Int) {&#10;        val numbers = (1..9).shuffled(Random.Default)&#10;        var index = 0&#10;&#10;        for (i in 0 until BOX_SIZE) {&#10;            for (j in 0 until BOX_SIZE) {&#10;                grid[row + i][col + j] = numbers[index++]&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fill remaining cells using backtracking&#10;     */&#10;    private fun fillRemaining(row: Int, col: Int): Boolean {&#10;        var currentRow = row&#10;        var currentCol = col&#10;&#10;        // Move to next cell&#10;        if (currentCol &gt;= GRID_SIZE &amp;&amp; currentRow &lt; GRID_SIZE - 1) {&#10;            currentRow += 1&#10;            currentCol = 0&#10;        }&#10;&#10;        // If we've filled all cells, we're done&#10;        if (currentRow &gt;= GRID_SIZE) {&#10;            return true&#10;        }&#10;&#10;        // Skip cells that are already filled (diagonal boxes)&#10;        if (grid[currentRow][currentCol] != 0) {&#10;            return fillRemaining(currentRow, currentCol + 1)&#10;        }&#10;&#10;        // Try numbers 1-9 in random order&#10;        val numbers = (1..9).shuffled(Random.Default)&#10;&#10;        for (num in numbers) {&#10;            if (isSafe(currentRow, currentCol, num)) {&#10;                grid[currentRow][currentCol] = num&#10;&#10;                if (fillRemaining(currentRow, currentCol + 1)) {&#10;                    return true&#10;                }&#10;&#10;                // Backtrack&#10;                grid[currentRow][currentCol] = 0&#10;            }&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Check if it's safe to place a number at given position&#10;     */&#10;    private fun isSafe(row: Int, col: Int, num: Int): Boolean {&#10;        return !usedInRow(row, num) &amp;&amp;&#10;               !usedInCol(col, num) &amp;&amp;&#10;               !usedInBox(row - row % BOX_SIZE, col - col % BOX_SIZE, num)&#10;    }&#10;&#10;    /**&#10;     * Check if number is used in the row&#10;     */&#10;    private fun usedInRow(row: Int, num: Int): Boolean {&#10;        for (col in 0 until GRID_SIZE) {&#10;            if (grid[row][col] == num) {&#10;                return true&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Check if number is used in the column&#10;     */&#10;    private fun usedInCol(col: Int, num: Int): Boolean {&#10;        for (row in 0 until GRID_SIZE) {&#10;            if (grid[row][col] == num) {&#10;                return true&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Check if number is used in the 3x3 box&#10;     */&#10;    private fun usedInBox(boxStartRow: Int, boxStartCol: Int, num: Int): Boolean {&#10;        for (row in 0 until BOX_SIZE) {&#10;            for (col in 0 until BOX_SIZE) {&#10;                if (grid[boxStartRow + row][boxStartCol + col] == num) {&#10;                    return true&#10;                }&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Create a puzzle by removing numbers from the complete grid&#10;     */&#10;    private fun createPuzzle(completeGrid: Array&lt;IntArray&gt;, difficulty: String): Array&lt;Array&lt;SudokuCell&gt;&gt; {&#10;        val puzzle = Array(GRID_SIZE) { row -&gt;&#10;            Array(GRID_SIZE) { col -&gt;&#10;                SudokuCell(&#10;                    value = completeGrid[row][col],&#10;                    isOriginal = true&#10;                )&#10;            }&#10;        }&#10;&#10;        val cellsToRemove = when (difficulty.lowercase()) {&#10;            &quot;easy&quot; -&gt; EASY_CELLS_TO_REMOVE&#10;            &quot;medium&quot; -&gt; MEDIUM_CELLS_TO_REMOVE&#10;            &quot;hard&quot; -&gt; HARD_CELLS_TO_REMOVE&#10;            else -&gt; EASY_CELLS_TO_REMOVE&#10;        }&#10;&#10;        // Get all cell positions and shuffle them&#10;        val allPositions = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        for (row in 0 until GRID_SIZE) {&#10;            for (col in 0 until GRID_SIZE) {&#10;                allPositions.add(Pair(row, col))&#10;            }&#10;        }&#10;        allPositions.shuffle(Random.Default)&#10;&#10;        // Remove numbers from random positions&#10;        var removed = 0&#10;        for (position in allPositions) {&#10;            if (removed &gt;= cellsToRemove) break&#10;&#10;            val (row, col) = position&#10;            puzzle[row][col] = SudokuCell(&#10;                value = 0,&#10;                isOriginal = false&#10;            )&#10;            removed++&#10;        }&#10;&#10;        return puzzle&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/SudokuCell.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/SudokuCell.kt" />
              <option name="originalContent" value="/**&#10; * Individual Sudoku Cell Component&#10; * Displays either a large number (if filled) or small note numbers (if empty with notes).&#10; * Handles visual states like selection and borders for 3x3 box separation.&#10; */&#10;&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@Composable&#10;fun SudokuCell(&#10;    value: Int, // 0 if empty&#10;    notes: Set&lt;Int&gt; = emptySet(), // Notes 1-9 for empty cells&#10;    isSelected: Boolean = false,&#10;    isOriginal: Boolean = false, // New parameter to identify original puzzle cells&#10;    hasError: Boolean = false, // Not used here, but can be added for error state&#10;    modifier: Modifier = Modifier,&#10;    onClick: () -&gt; Unit = {}&#10;) {&#10;    val borderColor = MaterialTheme.colorScheme.outline&#10;    val selectedColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.3f)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .border(0.5.dp, borderColor)&#10;            .background(if (isSelected) selectedColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .padding(0.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (value != 0) {&#10;            // Display large number for filled cells&#10;            Text(&#10;                text = value.toString(),&#10;                fontSize = 30.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = if (hasError) MaterialTheme.colorScheme.error&#10;                        else MaterialTheme.colorScheme.onSurface,&#10;            )&#10;        } else if (notes.isNotEmpty()) {&#10;            // Display notes in 3x3 mini-grid&#10;            NotesGrid(notes = notes)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NotesGrid(notes: Set&lt;Int&gt;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(0.dp), // Explicit zero padding&#10;        verticalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        repeat(3) { row -&gt;&#10;            Row(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp), // Explicit zero padding&#10;                horizontalArrangement = Arrangement.SpaceEvenly,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                repeat(3) { col -&gt;&#10;                    val number = row * 3 + col + 1&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .padding(0.dp), // Explicit zero padding&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = if (notes.contains(number)) number.toString() else &quot;&quot;,&#10;                            fontSize = 6.sp, // Even smaller font size&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier.padding(0.dp) // No padding on text&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Preview for filled cell (with value = 5)&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SudokuCellPreviewFilled() {&#10;    SudokuCell(&#10;        value = 5,&#10;        isSelected = true,&#10;        modifier = Modifier.padding(8.dp)&#10;    )&#10;}&#10;&#10;// Preview for empty cell with notes (notes = {1, 2, 3, 5, 7})&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SudokuCellPreviewEmptyWithNotes() {&#10;    SudokuCell(&#10;        value = 0,&#10;        notes = setOf(1, 2, 3, 5, 7),&#10;        isSelected = false,&#10;        modifier = Modifier.padding(8.dp)&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Individual Sudoku Cell Component&#10; * Displays either a large number (if filled) or small note numbers (if empty with notes).&#10; * Handles visual states like selection and borders for 3x3 box separation.&#10; */&#10;&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@Composable&#10;fun SudokuCell(&#10;    value: Int, // 0 if empty&#10;    notes: Set&lt;Int&gt; = emptySet(), // Notes 1-9 for empty cells&#10;    isSelected: Boolean = false,&#10;    isOriginal: Boolean = false, // New parameter to identify original puzzle cells&#10;    hasError: Boolean = false, // Not used here, but can be added for error state&#10;    modifier: Modifier = Modifier,&#10;    onClick: () -&gt; Unit = {}&#10;) {&#10;    val borderColor = MaterialTheme.colorScheme.outline&#10;    val selectedColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.3f)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .border(0.5.dp, borderColor)&#10;            .background(if (isSelected) selectedColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .padding(0.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (value != 0) {&#10;            // Display large number for filled cells&#10;            Text(&#10;                text = value.toString(),&#10;                fontSize = 30.sp,&#10;                fontWeight = if (isOriginal) FontWeight.ExtraBold else FontWeight.Bold,&#10;                color = when {&#10;                    hasError -&gt; MaterialTheme.colorScheme.error&#10;                    isOriginal -&gt; MaterialTheme.colorScheme.primary&#10;                    else -&gt; MaterialTheme.colorScheme.onSurface&#10;                },&#10;            )&#10;        } else if (notes.isNotEmpty()) {&#10;            // Display notes in 3x3 mini-grid&#10;            NotesGrid(notes = notes)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NotesGrid(notes: Set&lt;Int&gt;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(0.dp), // Explicit zero padding&#10;        verticalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        repeat(3) { row -&gt;&#10;            Row(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp), // Explicit zero padding&#10;                horizontalArrangement = Arrangement.SpaceEvenly,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                repeat(3) { col -&gt;&#10;                    val number = row * 3 + col + 1&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .padding(0.dp), // Explicit zero padding&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = if (notes.contains(number)) number.toString() else &quot;&quot;,&#10;                            fontSize = 6.sp, // Even smaller font size&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier.padding(0.dp) // No padding on text&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Preview for filled cell (with value = 5)&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SudokuCellPreviewFilled() {&#10;    SudokuCell(&#10;        value = 5,&#10;        isSelected = true,&#10;        modifier = Modifier.padding(8.dp)&#10;    )&#10;}&#10;&#10;// Preview for empty cell with notes (notes = {1, 2, 3, 5, 7})&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SudokuCellPreviewEmptyWithNotes() {&#10;    SudokuCell(&#10;        value = 0,&#10;        notes = setOf(1, 2, 3, 5, 7),&#10;        isSelected = false,&#10;        modifier = Modifier.padding(8.dp)&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/SudokuGrid.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/SudokuGrid.kt" />
              <option name="originalContent" value="/**&#10; * Sudoku Grid Component&#10; * Displays a 9x9 grid with bold borders every 3 cells to separate 3x3 boxes.&#10; * Manages cell interactions and visual feedback.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.SudokuCell&#10;&#10;@Composable&#10;fun SudokuGrid(&#10;    grid: Array&lt;Array&lt;SudokuCell&gt;&gt;, // Change from Array&lt;IntArray&gt; to Array&lt;Array&lt;SudokuCell&gt;&gt;&#10;    selectedCell: Pair&lt;Int, Int&gt;? = null,&#10;    onCellClick: (Int, Int) -&gt; Unit = { _, _ -&gt; },&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .border(2.dp, MaterialTheme.colorScheme.outline)&#10;    ) {&#10;        repeat(9) { row -&gt;&#10;            Row {&#10;                repeat(9) { col -&gt;&#10;                    val cell = grid[row][col]&#10;                    SudokuCell(&#10;                        value = cell.value,&#10;                        notes = cell.notes,&#10;                        isSelected = selectedCell == Pair(row, col),&#10;                        hasError = cell.hasError,&#10;                        onClick = { onCellClick(row, col) },&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .then(getBoxBorderModifier(row, col))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun getBoxBorderModifier(row: Int, col: Int): Modifier {&#10;    val borderColor = MaterialTheme.colorScheme.outline // Extract color here&#10;&#10;    return Modifier.drawBehind {&#10;        val thinStroke = 1.dp.toPx()&#10;        val thickStroke = 4.dp.toPx()&#10;&#10;        // Draw thick top border for rows 3 and 6&#10;        if (row == 3 || row == 6) {&#10;            drawLine(&#10;                color = borderColor, // Use the extracted color&#10;                start = Offset(0f, 0f),&#10;                end = Offset(size.width, 0f),&#10;                strokeWidth = thickStroke&#10;            )&#10;        }&#10;&#10;        // Draw thick left border for columns 3 and 6&#10;        if (col == 3 || col == 6) {&#10;            drawLine(&#10;                color = borderColor, // Use the extracted color&#10;                start = Offset(0f, 0f),&#10;                end = Offset(0f, size.height),&#10;                strokeWidth = thickStroke&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SudokuGridPreview() {&#10;    val sampleGrid = Array(9) { Array(9) { SudokuCell() } }&#10;    sampleGrid[0][0] = SudokuCell(value = 5)&#10;    sampleGrid[1][1] = SudokuCell(value = 3)&#10;    sampleGrid[4][4] = SudokuCell(value = 7)&#10;    sampleGrid[3][0] = SudokuCell(value = 5, hasError = true)&#10;    sampleGrid[0][1] = SudokuCell(notes = setOf(1, 2, 3))&#10;&#10;    SudokuGrid(&#10;        grid = sampleGrid,&#10;        selectedCell = Pair(0, 0),&#10;        onCellClick = { row, col -&gt; println(&quot;Cell clicked: ($row, $col)&quot;) },&#10;        modifier = Modifier.fillMaxSize()&#10;    )&#10;}" />
              <option name="updatedContent" value="/**&#10; * Sudoku Grid Component&#10; * Displays a 9x9 grid with bold borders every 3 cells to separate 3x3 boxes.&#10; * Manages cell interactions and visual feedback.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.SudokuCell&#10;&#10;@Composable&#10;fun SudokuGrid(&#10;    grid: Array&lt;Array&lt;SudokuCell&gt;&gt;, // Change from Array&lt;IntArray&gt; to Array&lt;Array&lt;SudokuCell&gt;&gt;&#10;    selectedCell: Pair&lt;Int, Int&gt;? = null,&#10;    onCellClick: (Int, Int) -&gt; Unit = { _, _ -&gt; },&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .border(2.dp, MaterialTheme.colorScheme.outline)&#10;    ) {&#10;        repeat(9) { row -&gt;&#10;            Row {&#10;                repeat(9) { col -&gt;&#10;                    val cell = grid[row][col]&#10;                    SudokuCell(&#10;                        value = cell.value,&#10;                        notes = cell.notes,&#10;                        isSelected = selectedCell == Pair(row, col),&#10;                        isOriginal = cell.isOriginal,&#10;                        hasError = cell.hasError,&#10;                        onClick = { onCellClick(row, col) },&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .then(getBoxBorderModifier(row, col))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun getBoxBorderModifier(row: Int, col: Int): Modifier {&#10;    val borderColor = MaterialTheme.colorScheme.outline // Extract color here&#10;&#10;    return Modifier.drawBehind {&#10;        val thinStroke = 1.dp.toPx()&#10;        val thickStroke = 4.dp.toPx()&#10;&#10;        // Draw thick top border for rows 3 and 6&#10;        if (row == 3 || row == 6) {&#10;            drawLine(&#10;                color = borderColor, // Use the extracted color&#10;                start = Offset(0f, 0f),&#10;                end = Offset(size.width, 0f),&#10;                strokeWidth = thickStroke&#10;            )&#10;        }&#10;&#10;        // Draw thick left border for columns 3 and 6&#10;        if (col == 3 || col == 6) {&#10;            drawLine(&#10;                color = borderColor, // Use the extracted color&#10;                start = Offset(0f, 0f),&#10;                end = Offset(0f, size.height),&#10;                strokeWidth = thickStroke&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SudokuGridPreview() {&#10;    val sampleGrid = Array(9) { Array(9) { SudokuCell() } }&#10;    sampleGrid[0][0] = SudokuCell(value = 5)&#10;    sampleGrid[1][1] = SudokuCell(value = 3)&#10;    sampleGrid[4][4] = SudokuCell(value = 7)&#10;    sampleGrid[3][0] = SudokuCell(value = 5, hasError = true)&#10;    sampleGrid[0][1] = SudokuCell(notes = setOf(1, 2, 3))&#10;&#10;    SudokuGrid(&#10;        grid = sampleGrid,&#10;        selectedCell = Pair(0, 0),&#10;        onCellClick = { row, col -&gt; println(&quot;Cell clicked: ($row, $col)&quot;) },&#10;        modifier = Modifier.fillMaxSize()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GameScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GameScreen.kt" />
              <option name="originalContent" value="/**&#10; * Game Screen for the Sudoku Game&#10; * This screen displays the Sudoku grid and allows users to play the game.&#10; * Includes a timer from the start of the game, a difficulty indicator,&#10; * a back button to return to the main menu, and a pause button - which pauses the timer&#10; * and covers the grid.&#10; *&#10; * The grid is displayed using a SudokuGrid composable, and the input numbers are handled by an InputRow composable.&#10; * Below is a UtilityRow composable.&#10;*/&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.GameState&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.components.InputRow&#10;import com.kooshmeen.sudoku.ui.components.SudokuGrid&#10;import com.kooshmeen.sudoku.ui.components.UtilityRow&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun GameScreen(&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToMenu: () -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    val gameState = GameStateManager.gameState&#10;    var showCompletionDialog by remember { mutableStateOf(false) }&#10;&#10;    // Timer effect&#10;    LaunchedEffect(gameState.isPaused) {&#10;        while (true) {&#10;            delay(1000)&#10;            gameState.updateTimer()&#10;        }&#10;    }&#10;&#10;    // Check for game completion&#10;    LaunchedEffect(gameState.isGameCompleted) {&#10;        if (gameState.isGameCompleted) {&#10;            showCompletionDialog = true&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(2.dp)&#10;            .background(MaterialTheme.colorScheme.background) // Use MaterialTheme for background color&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // Timer&#10;            Text(&#10;                text = &quot;Elapsed: ${gameState.getFormattedTime()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;            Spacer(Modifier.weight(1f)) // Push the difficulty indicator to the end&#10;            // Difficulty indicator&#10;            Text(&#10;                text = gameState.difficulty,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 32.dp)&#10;            )&#10;        }&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // back to menu button&#10;            IconButton(&#10;                onClick = onNavigateToMenu,&#10;                modifier = Modifier.padding(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back to Main Menu&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground // Use MaterialTheme for icon color&#10;                )&#10;            }&#10;            Spacer(Modifier.weight(1f)) // Push the pause button to the end&#10;            // Pause button - will pause timer, but cover the grid&#10;            IconButton(&#10;                onClick = { gameState.togglePause() },&#10;                modifier = Modifier.padding(8.dp),&#10;                // align the icon to the end of the row&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Lock,&#10;                    contentDescription = &quot;Pause Game&quot;,&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Grid - show overlay when paused&#10;        Box(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            SudokuGrid(&#10;                grid = gameState.grid, // Pass the full SudokuCell grid instead of extracting values&#10;                selectedCell = null,&#10;                onCellClick = { row, col -&gt;&#10;                    gameState.inputToCell(row, col)&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Pause overlay&#10;            if (gameState.isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Paused&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Input numbers row&#10;        InputRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            input = List(9) { it + 1 },&#10;            onInputChange = { index, value -&gt;&#10;                val number = value.toInt()&#10;                gameState.selectNumber(number)&#10;            },&#10;            selectedNumber = gameState.selectedNumber&#10;        )&#10;        Spacer(Modifier.height(24.dp))&#10;        // Utility Row&#10;        UtilityRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            selectedButton = when (gameState.gameMode) {&#10;                GameState.GameMode.NOTES -&gt; &quot;notes&quot;&#10;                GameState.GameMode.ERASE -&gt; &quot;erase&quot;&#10;                else -&gt; null&#10;            },&#10;            onEraseClick = { gameState.toggleEraseMode() },&#10;            onNotesClick = { gameState.toggleNotesMode() },&#10;            onUndoClick = { gameState.undo() }&#10;        )&#10;&#10;        // Completion Dialog&#10;        if (showCompletionDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = {&#10;                    showCompletionDialog = false&#10;                    GameStateManager.endGame()&#10;                },&#10;                title = { Text(&quot;Congratulations!&quot;) },&#10;                text = {&#10;                    Text(&quot;You completed the ${gameState.difficulty} puzzle in ${gameState.getFormattedTime()}!&quot;)&#10;                },&#10;                confirmButton = {&#10;                    Button(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                            onNavigateToMenu()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Back to Menu&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Stay Here&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GameScreenPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        GameScreen(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game Screen for the Sudoku Game&#10; * This screen displays the Sudoku grid and allows users to play the game.&#10; * Includes a timer from the start of the game, a difficulty indicator,&#10; * a back button to return to the main menu, and a pause button - which pauses the timer&#10; * and covers the grid.&#10; *&#10; * The grid is displayed using a SudokuGrid composable, and the input numbers are handled by an InputRow composable.&#10; * Below is a UtilityRow composable.&#10;*/&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.GameState&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.components.InputRow&#10;import com.kooshmeen.sudoku.ui.components.SudokuGrid&#10;import com.kooshmeen.sudoku.ui.components.UtilityRow&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun GameScreen(&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToMenu: () -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    val gameState = GameStateManager.gameState&#10;    var showCompletionDialog by remember { mutableStateOf(false) }&#10;&#10;    // Timer effect - only run when game is active and not paused&#10;    LaunchedEffect(gameState.isGameActive, gameState.isPaused) {&#10;        while (gameState.isGameActive &amp;&amp; !gameState.isPaused) {&#10;            delay(1000)&#10;            gameState.updateTimer()&#10;        }&#10;    }&#10;&#10;    // Check for game completion&#10;    LaunchedEffect(gameState.isGameCompleted) {&#10;        if (gameState.isGameCompleted) {&#10;            showCompletionDialog = true&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(2.dp)&#10;            .background(MaterialTheme.colorScheme.background) // Use MaterialTheme for background color&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // Timer&#10;            Text(&#10;                text = &quot;Elapsed: ${gameState.getFormattedTime()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;            Spacer(Modifier.weight(1f)) // Push the difficulty indicator to the end&#10;            // Difficulty indicator&#10;            Text(&#10;                text = gameState.difficulty,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 32.dp)&#10;            )&#10;        }&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // back to menu button&#10;            IconButton(&#10;                onClick = onNavigateToMenu,&#10;                modifier = Modifier.padding(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back to Main Menu&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground // Use MaterialTheme for icon color&#10;                )&#10;            }&#10;            Spacer(Modifier.weight(1f)) // Push the pause button to the end&#10;            // Pause button - will pause timer, but cover the grid&#10;            IconButton(&#10;                onClick = { gameState.togglePause() },&#10;                modifier = Modifier.padding(8.dp),&#10;                // align the icon to the end of the row&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Lock,&#10;                    contentDescription = &quot;Pause Game&quot;,&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Grid - show overlay when paused&#10;        Box(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            SudokuGrid(&#10;                grid = gameState.grid, // Pass the full SudokuCell grid instead of extracting values&#10;                selectedCell = null,&#10;                onCellClick = { row, col -&gt;&#10;                    gameState.inputToCell(row, col)&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Pause overlay&#10;            if (gameState.isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Paused&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Input numbers row&#10;        InputRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            input = List(9) { it + 1 },&#10;            onInputChange = { index, value -&gt;&#10;                val number = value.toInt()&#10;                gameState.selectNumber(number)&#10;            },&#10;            selectedNumber = gameState.selectedNumber&#10;        )&#10;        Spacer(Modifier.height(24.dp))&#10;        // Utility Row&#10;        UtilityRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            selectedButton = when (gameState.gameMode) {&#10;                GameState.GameMode.NOTES -&gt; &quot;notes&quot;&#10;                GameState.GameMode.ERASE -&gt; &quot;erase&quot;&#10;                else -&gt; null&#10;            },&#10;            onEraseClick = { gameState.toggleEraseMode() },&#10;            onNotesClick = { gameState.toggleNotesMode() },&#10;            onUndoClick = { gameState.undo() }&#10;        )&#10;&#10;        // Completion Dialog&#10;        if (showCompletionDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = {&#10;                    showCompletionDialog = false&#10;                    GameStateManager.endGame()&#10;                },&#10;                title = { Text(&quot;Congratulations!&quot;) },&#10;                text = {&#10;                    Text(&quot;You completed the ${gameState.difficulty} puzzle in ${gameState.getFormattedTime()}!&quot;)&#10;                },&#10;                confirmButton = {&#10;                    Button(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                            onNavigateToMenu()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Back to Menu&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Stay Here&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GameScreenPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        GameScreen(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/MainMenu.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/MainMenu.kt" />
              <option name="originalContent" value="/**&#10; * MainMenu.kt&#10; * This file defines the main menu screen for the Sudoku app.&#10; * It includes options to start a game, select difficulty, and toggle themes.&#10; * It also includes a settings button.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.rounded.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.R&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;@Composable&#10;fun MainMenu (&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToGame: () -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    var isDifficultyDropdownOpen by remember { mutableStateOf(false) }&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;Easy&quot;) }&#10;&#10;    Column (&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.End,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconToggleButton(&#10;                checked = isDarkTheme,&#10;                onCheckedChange = onThemeToggle,  // Use the callback&#10;                modifier = Modifier.size(24.dp)&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(&#10;                        id = if (!isDarkTheme) R.drawable.light_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                        else R.drawable.dark_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                    ),&#10;                    contentDescription = &quot;Toggle Dark/Light Mode&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            IconButton(onClick = { /* TODO: Open Settings */ }) {&#10;                Icon(&#10;                    imageVector = Icons.Rounded.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier&#10;                        .size(24.dp)&#10;                        .fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Title&#10;        Spacer(modifier = Modifier.height(64.dp))&#10;        Text(&#10;            text = &quot;Welcome to Sudoku!&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;        Spacer(modifier = Modifier.height(256.dp))&#10;        // Play button - start game if no game started&#10;        Button(&#10;            onClick = { onNavigateToGame() },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Start Game&quot;,&#10;                color = MaterialTheme.colorScheme.onPrimary,&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Select difficulty&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = { isDifficultyDropdownOpen = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Difficulty: $selectedDifficulty&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.arrow_drop_down),&#10;                        contentDescription = &quot;Dropdown arrow&quot;,&#10;                        modifier = Modifier&#10;                            .align(Alignment.CenterEnd)&#10;                            .size(24.dp),&#10;                        tint = MaterialTheme.colorScheme.onBackground&#10;                    )&#10;                }&#10;            }&#10;&#10;            DropdownMenu(&#10;                expanded = isDifficultyDropdownOpen,&#10;                onDismissRequest = { isDifficultyDropdownOpen = false }&#10;            ) {&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Easy&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Easy&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Medium&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Medium&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Hard&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Hard&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(128.dp))&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainMenuPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        MainMenu(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * MainMenu.kt&#10; * This file defines the main menu screen for the Sudoku app.&#10; * It includes options to start a game, select difficulty, and toggle themes.&#10; * It also includes a settings button.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.rounded.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.R&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;@Composable&#10;fun MainMenu (&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onContinueGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onStartNewGame: (String) -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    var isDifficultyDropdownOpen by remember { mutableStateOf(false) }&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;Easy&quot;) }&#10;    val hasActiveGame = GameStateManager.hasActiveGame()&#10;&#10;    Column (&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.End,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconToggleButton(&#10;                checked = isDarkTheme,&#10;                onCheckedChange = onThemeToggle,  // Use the callback&#10;                modifier = Modifier.size(24.dp)&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(&#10;                        id = if (!isDarkTheme) R.drawable.light_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                        else R.drawable.dark_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                    ),&#10;                    contentDescription = &quot;Toggle Dark/Light Mode&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            IconButton(onClick = { /* TODO: Open Settings */ }) {&#10;                Icon(&#10;                    imageVector = Icons.Rounded.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier&#10;                        .size(24.dp)&#10;                        .fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Title&#10;        Spacer(modifier = Modifier.height(64.dp))&#10;        Text(&#10;            text = &quot;Welcome to Sudoku!&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;        Spacer(modifier = Modifier.height(256.dp))&#10;        &#10;        // Continue game button - only show if there's an active game&#10;        if (hasActiveGame) {&#10;            Button(&#10;                onClick = { &#10;                    GameStateManager.continueGame()&#10;                    onContinueGame()&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Continue Game&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;        &#10;        // Start new game button&#10;        Button(&#10;            onClick = { &#10;                GameStateManager.startNewGame(selectedDifficulty)&#10;                onStartNewGame(selectedDifficulty)&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Text(&#10;                text = if (hasActiveGame) &quot;New Game&quot; else &quot;Start Game&quot;,&#10;                color = MaterialTheme.colorScheme.onPrimary,&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Select difficulty&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = { isDifficultyDropdownOpen = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Difficulty: $selectedDifficulty&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.arrow_drop_down),&#10;                        contentDescription = &quot;Dropdown arrow&quot;,&#10;                        modifier = Modifier&#10;                            .align(Alignment.CenterEnd)&#10;                            .size(24.dp),&#10;                        tint = MaterialTheme.colorScheme.onBackground&#10;                    )&#10;                }&#10;            }&#10;&#10;            DropdownMenu(&#10;                expanded = isDifficultyDropdownOpen,&#10;                onDismissRequest = { isDifficultyDropdownOpen = false }&#10;            ) {&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Easy&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Easy&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Medium&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Medium&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Hard&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Hard&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(128.dp))&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainMenuPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        MainMenu(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>