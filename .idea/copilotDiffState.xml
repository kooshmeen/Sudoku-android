<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt" />
              <option name="originalContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.screens.RecordScreen&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onContinueGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onStartNewGame = { difficulty -&gt;&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onNavigateToRecords = {&#10;                                    NavController.navigate(&quot;record_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;game_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;record_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            RecordScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.screens.RecordScreen&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onContinueGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onStartNewGame = { difficulty -&gt;&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onNavigateToRecords = {&#10;                                    NavController.navigate(&quot;record_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;game_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;record_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            RecordScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Save game state when app goes to background&#10;        GameStateManager.saveCurrentGame(this)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt" />
              <option name="originalContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class RemoveNotesBatch(&#10;        val cells: List&lt;Pair&lt;Int, Int&gt;&gt;,&#10;        val note: Int,&#10;        val oldNotes: List&lt;Set&lt;Int&gt;&gt;&#10;    ) : GameAction()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt" />
              <option name="originalContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Current number of mistakes made by the player&#10;    var mistakesCount by mutableIntStateOf(0)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    // Store the original solution grid for error checking&#10;    private var solutionGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;        if (currentCell.isOriginal) return&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        // Error: compare to solutionGrid&#10;        val hasError = solutionGrid[row][col] != value&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(),&#10;            hasError = hasError&#10;        )&#10;        // Track cells and old notes for undo&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val affectedOldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;        // Remove notes of this value in row&#10;        for (c in 0..8) {&#10;            if (c != col) {&#10;                val cell = newGrid[row][c]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(row, c))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[row][c] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from column&#10;        for (r in 0..8) {&#10;            if (r != row) {&#10;                val cell = newGrid[r][col]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(r, col))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[r][col] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if ((r != row || c != col)) {&#10;                    val cell = newGrid[r][c]&#10;                    if (cell.notes.contains(value)) {&#10;                        affectedCells.add(Pair(r, c))&#10;                        affectedOldNotes.add(cell.notes)&#10;                        newGrid[r][c] = cell.copy(notes = cell.notes - value)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // Push batch note removal to action stack for undo&#10;        if (affectedCells.isNotEmpty()) {&#10;            actionHistory.push(GameAction.RemoveNotesBatch(affectedCells, value, affectedOldNotes))&#10;        }&#10;        if (hasError) {&#10;            errorCells = errorCells + Pair(row, col)&#10;            // Mark as mistake&#10;            mistakesCount++&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;        grid = newGrid&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    private fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = SudokuCell() // Create a new empty cell&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    hasError = false&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = SudokuCell(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    isOriginal = grid[action.row][action.col].isOriginal&#10;                )&#10;            }&#10;            is GameAction.RemoveNotesBatch -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        // Generate a new puzzle and store the solution grid&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused &amp;&amp; isGameActive) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Current number of mistakes made by the player&#10;    var mistakesCount by mutableIntStateOf(0)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    // Store the original solution grid for error checking&#10;    internal var solutionGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;        private set&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;        if (currentCell.isOriginal) return&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        // Error: compare to solutionGrid&#10;        val hasError = solutionGrid[row][col] != value&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(),&#10;            hasError = hasError&#10;        )&#10;        // Track cells and old notes for undo&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val affectedOldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;        // Remove notes of this value in row&#10;        for (c in 0..8) {&#10;            if (c != col) {&#10;                val cell = newGrid[row][c]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(row, c))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[row][c] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from column&#10;        for (r in 0..8) {&#10;            if (r != row) {&#10;                val cell = newGrid[r][col]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(r, col))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[r][col] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if ((r != row || c != col)) {&#10;                    val cell = newGrid[r][c]&#10;                    if (cell.notes.contains(value)) {&#10;                        affectedCells.add(Pair(r, c))&#10;                        affectedOldNotes.add(cell.notes)&#10;                        newGrid[r][c] = cell.copy(notes = cell.notes - value)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // Push batch note removal to action stack for undo&#10;        if (affectedCells.isNotEmpty()) {&#10;            actionHistory.push(GameAction.RemoveNotesBatch(affectedCells, value, affectedOldNotes))&#10;        }&#10;        if (hasError) {&#10;            errorCells = errorCells + Pair(row, col)&#10;            // Mark as mistake&#10;            mistakesCount++&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;        grid = newGrid&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    private fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = SudokuCell() // Create a new empty cell&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    hasError = false&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = SudokuCell(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    isOriginal = grid[action.row][action.col].isOriginal&#10;                )&#10;            }&#10;            is GameAction.RemoveNotesBatch -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        // Generate a new puzzle and store the solution grid&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused &amp;&amp; isGameActive) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;&#10;    /**&#10;     * Load game state from saved data&#10;     */&#10;    fun loadFromSavedState(savedState: SavedGameState) {&#10;        this.difficulty = savedState.difficulty&#10;        this.elapsedTimeSeconds = savedState.elapsedTimeSeconds&#10;        this.mistakesCount = savedState.mistakesCount&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.errorCells = emptySet()&#10;&#10;        // Convert saved grid to SudokuCell array&#10;        this.grid = Array(9) { row -&gt;&#10;            Array(9) { col -&gt;&#10;                val saved = savedState.grid[row][col]&#10;                SudokuCell(&#10;                    value = saved.value,&#10;                    notes = saved.notes.toSet(),&#10;                    isOriginal = saved.isOriginal,&#10;                    hasError = saved.hasError&#10;                )&#10;            }&#10;        }&#10;&#10;        // Convert solution grid&#10;        this.solutionGrid = Array(9) { row -&gt;&#10;            IntArray(9) { col -&gt;&#10;                savedState.solutionGrid[row][col]&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameStateManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameStateManager.kt" />
              <option name="originalContent" value="/**&#10; * Global game state manager&#10; * Provides a singleton instance of GameState that can be shared across screens&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;object GameStateManager {&#10;    private val _gameState = GameState()&#10;&#10;    val gameState: GameState get() = _gameState&#10;&#10;    /**&#10;     * Check if there's an active game that can be continued&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return _gameState.hasActiveGame()&#10;    }&#10;&#10;    /**&#10;     * Start a new game with the specified difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        _gameState.startNewGame(difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue the current active game&#10;     */&#10;    fun continueGame() {&#10;        _gameState.continueGame()&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        _gameState.endGame()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Global game state manager&#10; * Provides a singleton instance of GameState that can be shared across screens&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import android.content.Context&#10;import com.kooshmeen.sudoku.utils.GameStatePersistence&#10;&#10;object GameStateManager {&#10;    private val _gameState = GameState()&#10;&#10;    val gameState: GameState get() = _gameState&#10;&#10;    /**&#10;     * Check if there's an active game that can be continued&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return _gameState.hasActiveGame()&#10;    }&#10;&#10;    /**&#10;     * Check if there's a saved game that can be loaded&#10;     */&#10;    fun hasSavedGame(context: Context): Boolean {&#10;        return GameStatePersistence.loadGameState(context) != null&#10;    }&#10;&#10;    /**&#10;     * Load saved game&#10;     */&#10;    fun loadSavedGame(context: Context): Boolean {&#10;        val savedState = GameStatePersistence.loadGameState(context) ?: return false&#10;        _gameState.loadFromSavedState(savedState)&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Save current game&#10;     */&#10;    fun saveCurrentGame(context: Context) {&#10;        GameStatePersistence.saveGameState(context, _gameState)&#10;    }&#10;&#10;    /**&#10;     * Start a new game with the specified difficulty&#10;     */&#10;    fun startNewGame(difficulty: String, context: Context? = null) {&#10;        context?.let { GameStatePersistence.clearSavedGame(it) }&#10;        _gameState.startNewGame(difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue the current active game&#10;     */&#10;    fun continueGame() {&#10;        _gameState.continueGame()&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        _gameState.endGame()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt" />
              <option name="updatedContent" value="/**&#10; * Data class representing the serializable game state&#10; * Used for saving/loading games from SharedPreferences&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;data class SavedGameState(&#10;    val grid: List&lt;List&lt;SavedCellState&gt;&gt;,&#10;    val difficulty: String,&#10;    val elapsedTimeSeconds: Int,&#10;    val mistakesCount: Int,&#10;    val solutionGrid: List&lt;List&lt;Int&gt;&gt;&#10;)&#10;&#10;data class SavedCellState(&#10;    val value: Int,&#10;    val notes: List&lt;Int&gt;,&#10;    val isOriginal: Boolean,&#10;    val hasError: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/MainMenu.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/MainMenu.kt" />
              <option name="originalContent" value="/**&#10; * MainMenu.kt&#10; * This file defines the main menu screen for the Sudoku app.&#10; * It includes options to start a game, select difficulty, and toggle themes.&#10; * It also includes a settings button.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.rounded.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.R&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;@Composable&#10;fun MainMenu (&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onContinueGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onStartNewGame: (String) -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToRecords: () -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToLeaderboard: () -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    var isDifficultyDropdownOpen by remember { mutableStateOf(false) }&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;Easy&quot;) }&#10;    val hasActiveGame = GameStateManager.hasActiveGame()&#10;&#10;    Column (&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.End,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconToggleButton(&#10;                checked = isDarkTheme,&#10;                onCheckedChange = onThemeToggle,  // Use the callback&#10;                modifier = Modifier.size(24.dp)&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(&#10;                        id = if (!isDarkTheme) R.drawable.light_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                        else R.drawable.dark_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                    ),&#10;                    contentDescription = &quot;Toggle Dark/Light Mode&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            IconButton(onClick = { /* TODO: Open Settings */ }) {&#10;                Icon(&#10;                    imageVector = Icons.Rounded.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier&#10;                        .size(24.dp)&#10;                        .fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Title&#10;        Spacer(modifier = Modifier.height(64.dp))&#10;        Text(&#10;            text = &quot;Welcome to Sudoku!&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;        Spacer(modifier = Modifier.height(256.dp))&#10;&#10;        // Continue game button - only show if there's an active game&#10;        if (hasActiveGame) {&#10;            Button(&#10;                onClick = {&#10;                    GameStateManager.continueGame()&#10;                    onContinueGame()&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Continue Game&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // Start new game button&#10;        Button(&#10;            onClick = {&#10;                GameStateManager.startNewGame(selectedDifficulty)&#10;                onStartNewGame(selectedDifficulty)&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Text(&#10;                text = if (hasActiveGame) &quot;New Game&quot; else &quot;Start Game&quot;,&#10;                color = MaterialTheme.colorScheme.onPrimary,&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Select difficulty&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = { isDifficultyDropdownOpen = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Difficulty: $selectedDifficulty&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.arrow_drop_down),&#10;                        contentDescription = &quot;Dropdown arrow&quot;,&#10;                        modifier = Modifier&#10;                            .align(Alignment.CenterEnd)&#10;                            .size(24.dp),&#10;                        tint = MaterialTheme.colorScheme.onBackground&#10;                    )&#10;                }&#10;            }&#10;&#10;            DropdownMenu(&#10;                expanded = isDifficultyDropdownOpen,&#10;                onDismissRequest = { isDifficultyDropdownOpen = false }&#10;            ) {&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Easy&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Easy&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Medium&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Medium&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Hard&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Hard&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(128.dp))&#10;&#10;        // Row for Leaderboard button (left) and Records button (right)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;        ) {&#10;            Button(&#10;                onClick = { /* TODO: Navigate to Leaderboard */ },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Leaderboard&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp)) // Space between buttons&#10;            Button(&#10;                onClick = { onNavigateToRecords() },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Records&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainMenuPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        MainMenu(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * MainMenu.kt&#10; * This file defines the main menu screen for the Sudoku app.&#10; * It includes options to start a game, select difficulty, and toggle themes.&#10; * It also includes a settings button.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.rounded.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.R&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import androidx.compose.ui.platform.LocalContext&#10;&#10;@Composable&#10;fun MainMenu (&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onContinueGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onStartNewGame: (String) -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToRecords: () -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToLeaderboard: () -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    var isDifficultyDropdownOpen by remember { mutableStateOf(false) }&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;Easy&quot;) }&#10;    &#10;    val context = LocalContext.current&#10;    val hasActiveGame = remember {&#10;        GameStateManager.hasActiveGame() || GameStateManager.hasSavedGame(context)&#10;    }&#10;&#10;    Column (&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.End,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconToggleButton(&#10;                checked = isDarkTheme,&#10;                onCheckedChange = onThemeToggle,  // Use the callback&#10;                modifier = Modifier.size(24.dp)&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(&#10;                        id = if (!isDarkTheme) R.drawable.light_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                        else R.drawable.dark_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                    ),&#10;                    contentDescription = &quot;Toggle Dark/Light Mode&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            IconButton(onClick = { /* TODO: Open Settings */ }) {&#10;                Icon(&#10;                    imageVector = Icons.Rounded.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier&#10;                        .size(24.dp)&#10;                        .fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Title&#10;        Spacer(modifier = Modifier.height(64.dp))&#10;        Text(&#10;            text = &quot;Welcome to Sudoku!&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;        Spacer(modifier = Modifier.height(256.dp))&#10;&#10;        // Continue game button - only show if there's an active game&#10;        if (hasActiveGame) {&#10;            Button(&#10;                onClick = {&#10;                    if (!GameStateManager.hasActiveGame()) {&#10;                        GameStateManager.loadSavedGame(context)&#10;                    }&#10;                    GameStateManager.continueGame()&#10;                    onContinueGame()&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Continue Game&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // Start new game button&#10;        Button(&#10;            onClick = {&#10;                GameStateManager.startNewGame(selectedDifficulty, context)&#10;                onStartNewGame(selectedDifficulty)&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Text(&#10;                text = if (hasActiveGame) &quot;New Game&quot; else &quot;Start Game&quot;,&#10;                color = MaterialTheme.colorScheme.onPrimary,&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Select difficulty&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = { isDifficultyDropdownOpen = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Difficulty: $selectedDifficulty&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.arrow_drop_down),&#10;                        contentDescription = &quot;Dropdown arrow&quot;,&#10;                        modifier = Modifier&#10;                            .align(Alignment.CenterEnd)&#10;                            .size(24.dp),&#10;                        tint = MaterialTheme.colorScheme.onBackground&#10;                    )&#10;                }&#10;            }&#10;&#10;            DropdownMenu(&#10;                expanded = isDifficultyDropdownOpen,&#10;                onDismissRequest = { isDifficultyDropdownOpen = false }&#10;            ) {&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Easy&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Easy&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Medium&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Medium&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Hard&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Hard&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(128.dp))&#10;&#10;        // Row for Leaderboard button (left) and Records button (right)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;        ) {&#10;            Button(&#10;                onClick = { /* TODO: Navigate to Leaderboard */ },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Leaderboard&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp)) // Space between buttons&#10;            Button(&#10;                onClick = { onNavigateToRecords() },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Records&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainMenuPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        MainMenu(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordsScreen.kt" />
              <option name="originalContent" value="/**&#10; * Displays best times for each difficulty.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;&#10;@Composable&#10;fun RecordScreen(&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {}&#10;) {&#10;    var refresh by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    val difficulties = listOf(&quot;Easy&quot;, &quot;Medium&quot;, &quot;Hard&quot;)&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Best Times&quot;,&#10;            style = MaterialTheme.typography.headlineLarge,&#10;            color = MaterialTheme.colorScheme.onBackground&#10;        )&#10;        difficulties.forEach { difficulty -&gt;&#10;            Text(&#10;                text = &quot;$difficulty: ${BestTimeManager.getBestTimeFormatted(context, difficulty)}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;            )&#10;            Text(&#10;                text = &quot;$difficulty (No Mistakes): ${BestTimeManager.getBestTimeNoMistakeFormatted(&#10;                    context, difficulty)}&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.weight(1f))&#10;        Row (&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            horizontalArrangement = Arrangement.Center,&#10;&#10;        ){&#10;            Button(&#10;                onClick = {&#10;                    BestTimeManager.clearBestTimes(context)&#10;                    refresh = !refresh // Toggle to force recomposition&#10;                          },&#10;                modifier = Modifier.padding(top = 16.dp, end = 4.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error,&#10;                    contentColor = MaterialTheme.colorScheme.onError&#10;                )&#10;            ) {&#10;                Text(text = &quot;Reset Times&quot;)&#10;            }&#10;            Button(&#10;                onClick = onNavigateBack,&#10;                modifier = Modifier.padding(start = 4.dp, top = 16.dp),&#10;            ) {&#10;                Text(text = &quot;Back to Menu&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun RecordScreenPreview() {&#10;    RecordScreen(&#10;        modifier = Modifier.fillMaxSize(),&#10;        onNavigateBack = {}&#10;    )&#10;}" />
              <option name="updatedContent" value="/**&#10; * Displays best times for each difficulty.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;&#10;@Composable&#10;fun RecordScreen(&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {}&#10;) {&#10;    var refresh by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    val difficulties = listOf(&quot;Easy&quot;, &quot;Medium&quot;, &quot;Hard&quot;)&#10;&#10;    // Make best times reactive to refresh state&#10;    val bestTimes = remember(refresh) {&#10;        difficulties.associateWith { difficulty -&gt;&#10;            Pair(&#10;                BestTimeManager.getBestTimeFormatted(context, difficulty),&#10;                BestTimeManager.getBestTimeNoMistakeFormatted(context, difficulty)&#10;            )&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Best Times&quot;,&#10;            style = MaterialTheme.typography.headlineLarge,&#10;            color = MaterialTheme.colorScheme.onBackground&#10;        )&#10;        difficulties.forEach { difficulty -&gt;&#10;            val (bestTime, bestTimeNoMistakes) = bestTimes[difficulty] ?: Pair(&quot;No best time&quot;, &quot;No best time&quot;)&#10;            Text(&#10;                text = &quot;$difficulty: $bestTime&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;            )&#10;            Text(&#10;                text = &quot;$difficulty (No Mistakes): $bestTimeNoMistakes&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.weight(1f))&#10;        Row (&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            horizontalArrangement = Arrangement.Center,&#10;&#10;        ){&#10;            Button(&#10;                onClick = {&#10;                    BestTimeManager.clearBestTimes(context)&#10;                    refresh = !refresh // Toggle to force recomposition&#10;                          },&#10;                modifier = Modifier.padding(top = 16.dp, end = 4.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error,&#10;                    contentColor = MaterialTheme.colorScheme.onError&#10;                )&#10;            ) {&#10;                Text(text = &quot;Reset Times&quot;)&#10;            }&#10;            Button(&#10;                onClick = onNavigateBack,&#10;                modifier = Modifier.padding(start = 4.dp, top = 16.dp),&#10;            ) {&#10;                Text(text = &quot;Back to Menu&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun RecordScreenPreview() {&#10;    RecordScreen(&#10;        modifier = Modifier.fillMaxSize(),&#10;        onNavigateBack = {}&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt" />
              <option name="updatedContent" value="/**&#10; * Handles persistence of game state using SharedPreferences&#10; * Serializes game state to JSON for storage&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import com.kooshmeen.sudoku.data.*&#10;&#10;object GameStatePersistence {&#10;    private const val PREFS_NAME = &quot;SudokuGameState&quot;&#10;    private const val KEY_SAVED_GAME = &quot;saved_game&quot;&#10;    &#10;    fun saveGameState(context: Context, gameState: GameState) {&#10;        // Only save if game is active and not completed&#10;        if (!gameState.isGameActive || gameState.isGameCompleted) return&#10;        &#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = serializeGameState(gameState)&#10;        prefs.edit().putString(KEY_SAVED_GAME, json).apply()&#10;    }&#10;    &#10;    fun loadGameState(context: Context): SavedGameState? {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = prefs.getString(KEY_SAVED_GAME, null) ?: return null&#10;        return deserializeGameState(json)&#10;    }&#10;    &#10;    fun clearSavedGame(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit().remove(KEY_SAVED_GAME).apply()&#10;    }&#10;    &#10;    private fun serializeGameState(gameState: GameState): String {&#10;        val jsonObject = JSONObject().apply {&#10;            put(&quot;difficulty&quot;, gameState.difficulty)&#10;            put(&quot;elapsedTime&quot;, gameState.elapsedTimeSeconds)&#10;            put(&quot;mistakesCount&quot;, gameState.mistakesCount)&#10;            put(&quot;grid&quot;, serializeGrid(gameState.grid))&#10;            put(&quot;solutionGrid&quot;, serializeSolutionGrid(gameState.solutionGrid))&#10;        }&#10;        return jsonObject.toString()&#10;    }&#10;    &#10;    private fun serializeGrid(grid: Array&lt;Array&lt;SudokuCell&gt;&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            grid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { cell -&gt;&#10;                        val cellObj = JSONObject().apply {&#10;                            put(&quot;value&quot;, cell.value)&#10;                            put(&quot;notes&quot;, JSONArray(cell.notes.toList()))&#10;                            put(&quot;isOriginal&quot;, cell.isOriginal)&#10;                            put(&quot;hasError&quot;, cell.hasError)&#10;                        }&#10;                        put(cellObj)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun serializeSolutionGrid(solutionGrid: Array&lt;IntArray&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            solutionGrid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { value -&gt;&#10;                        put(value)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun deserializeGameState(json: String): SavedGameState? {&#10;        return try {&#10;            val jsonObject = JSONObject(json)&#10;            &#10;            val gridArray = jsonObject.getJSONArray(&quot;grid&quot;)&#10;            val grid = mutableListOf&lt;List&lt;SavedCellState&gt;&gt;()&#10;            &#10;            for (i in 0 until gridArray.length()) {&#10;                val rowArray = gridArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;SavedCellState&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    val cellObj = rowArray.getJSONObject(j)&#10;                    val notesArray = cellObj.getJSONArray(&quot;notes&quot;)&#10;                    val notes = mutableListOf&lt;Int&gt;()&#10;                    &#10;                    for (k in 0 until notesArray.length()) {&#10;                        notes.add(notesArray.getInt(k))&#10;                    }&#10;                    &#10;                    row.add(SavedCellState(&#10;                        value = cellObj.getInt(&quot;value&quot;),&#10;                        notes = notes,&#10;                        isOriginal = cellObj.getBoolean(&quot;isOriginal&quot;),&#10;                        hasError = cellObj.getBoolean(&quot;hasError&quot;)&#10;                    ))&#10;                }&#10;                grid.add(row)&#10;            }&#10;            &#10;            val solutionArray = jsonObject.getJSONArray(&quot;solutionGrid&quot;)&#10;            val solutionGrid = mutableListOf&lt;List&lt;Int&gt;&gt;()&#10;            &#10;            for (i in 0 until solutionArray.length()) {&#10;                val rowArray = solutionArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;Int&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    row.add(rowArray.getInt(j))&#10;                }&#10;                solutionGrid.add(row)&#10;            }&#10;            &#10;            SavedGameState(&#10;                grid = grid,&#10;                difficulty = jsonObject.getString(&quot;difficulty&quot;),&#10;                elapsedTimeSeconds = jsonObject.getInt(&quot;elapsedTime&quot;),&#10;                mistakesCount = jsonObject.getInt(&quot;mistakesCount&quot;),&#10;                solutionGrid = solutionGrid&#10;            )&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>