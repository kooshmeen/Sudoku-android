<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt" />
              <option name="originalContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Store the original puzzle (before any player input)&#10;    internal var originalPuzzleGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Current number of mistakes made by the player&#10;    var mistakesCount by mutableIntStateOf(0)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    // Store the original solution grid for error checking&#10;    internal var solutionGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;        private set&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    private lateinit var repository: SudokuRepository&#10;&#10;    fun initializeRepository(context: Context) {&#10;        repository = SudokuRepository(context)&#10;    }&#10;&#10;    suspend fun submitScoreToServer(): Boolean {&#10;        return if (isGameCompleted &amp;&amp; ::repository.isInitialized &amp;&amp; repository.isLoggedIn()) {&#10;            val result = repository.submitGame(&#10;                difficulty = difficulty,&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;            result.isSuccess&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Record game completion in local statistics&#10;     */&#10;    fun recordGameCompletion(context: Context) {&#10;        if (isGameCompleted) {&#10;            com.kooshmeen.sudoku.utils.StatisticsManager.recordCompletedGame(&#10;                context = context,&#10;                difficulty = difficulty,&#10;                score = highestPossibleScore(),&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Returns highest possible score from current game state&#10;     * Calculated as:&#10;     * const score = Math.round((difficultyMultiplier * mistakePenalty) * (Math.max(0, (timeScore - timeSeconds) * 2) + basePoints));&#10;     * With: difficultyMultiplier = 0.33 for Easy, 0.7 for Medium, 1.5 for Hard&#10;     * timeScore = 600 for Easy, 1200 for Medium, 1800 for Hard&#10;     * mistakePenalty = max(0.4, 1 - (numberOfMistakes * 0.1)&#10;     * basePoints = 1000&#10;     */&#10;    fun highestPossibleScore(): Int {&#10;        val difficultyMultiplier = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 0.33&#10;            &quot;medium&quot; -&gt; 0.7&#10;            &quot;hard&quot; -&gt; 1.5&#10;            else -&gt; 0.33 // Default to Easy if unknown&#10;        }&#10;&#10;        val timeScore = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 600&#10;            &quot;medium&quot; -&gt; 1200&#10;            &quot;hard&quot; -&gt; 1800&#10;            else -&gt; 600 // Default to Easy if unknown&#10;        }&#10;&#10;        val mistakePenalty = maxOf(0.4, 1 - (mistakesCount * 0.1))&#10;        val basePoints = 1000&#10;&#10;        return ((difficultyMultiplier * mistakePenalty) * (maxOf(0, (timeScore - elapsedTimeSeconds) * 2) + basePoints)).toInt()&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;        if (currentCell.isOriginal) return&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        // Error: compare to solutionGrid&#10;        val hasError = solutionGrid[row][col] != value&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(),&#10;            hasError = hasError&#10;        )&#10;        // Track cells and old notes for undo&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val affectedOldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;        // Remove notes of this value in row&#10;        for (c in 0..8) {&#10;            if (c != col) {&#10;                val cell = newGrid[row][c]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(row, c))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[row][c] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from column&#10;        for (r in 0..8) {&#10;            if (r != row) {&#10;                val cell = newGrid[r][col]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(r, col))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[r][col] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if ((r != row || c != col)) {&#10;                    val cell = newGrid[r][c]&#10;                    if (cell.notes.contains(value)) {&#10;                        affectedCells.add(Pair(r, c))&#10;                        affectedOldNotes.add(cell.notes)&#10;                        newGrid[r][c] = cell.copy(notes = cell.notes - value)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // Push batch note removal to action stack for undo&#10;        if (affectedCells.isNotEmpty()) {&#10;            actionHistory.push(GameAction.RemoveNotesBatch(affectedCells, value, affectedOldNotes))&#10;        }&#10;        if (hasError) {&#10;            errorCells = errorCells + Pair(row, col)&#10;            // Mark as mistake&#10;            mistakesCount++&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;        grid = newGrid&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    private fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = SudokuCell() // Create a new empty cell&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    hasError = false&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = SudokuCell(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    isOriginal = grid[action.row][action.col].isOriginal&#10;                )&#10;            }&#10;            is GameAction.RemoveNotesBatch -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;            is GameAction.AutofillNotes -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if minimum time requirement is met (5 seconds)&#10;        if (elapsedTimeSeconds &lt; 5) {&#10;            return false&#10;        }&#10;&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Empty grid&#10;     */&#10;    fun clearGrid() {&#10;        grid = Array(9) { Array(9) { SudokuCell() } }&#10;        selectedCell = null&#10;        selectedNumber = null&#10;        actionHistory.clear()&#10;        mistakesCount = 0&#10;        elapsedTimeSeconds = 0&#10;        isPaused = false&#10;        isGameActive = false&#10;        isGameCompleted = false&#10;        errorCells = emptySet()&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        // Generate a new puzzle and store the solution grid&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Load a challenge game with specific puzzle data&#10;     */&#10;    fun loadChallengeGame(puzzleData: Map&lt;*, *&gt;, difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        try {&#10;            val puzzleList = puzzleData[&quot;puzzle&quot;] as? List&lt;*&gt;&#10;            val solutionList = puzzleData[&quot;solution&quot;] as? List&lt;*&gt;&#10;&#10;            if (puzzleList != null &amp;&amp; solutionList != null) {&#10;                // Handle flat array format (81 elements)&#10;                if (puzzleList.size == 81 &amp;&amp; solutionList.size == 81) {&#10;                    // Convert flat arrays to 2D&#10;                    this.solutionGrid = Array(9) { row -&gt;&#10;                        IntArray(9) { col -&gt;&#10;                            val index = row * 9 + col&#10;                            (solutionList[index] as? Number)?.toInt() ?: 0&#10;                        }&#10;                    }&#10;&#10;                    this.grid = Array(9) { row -&gt;&#10;                        Array(9) { col -&gt;&#10;                            val index = row * 9 + col&#10;                            val cellValue = (puzzleList[index] as? Number)?.toInt() ?: 0&#10;                            SudokuCell(&#10;                                value = cellValue,&#10;                                isOriginal = cellValue != 0&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    // Handle 2D array format (9x9)&#10;                    this.solutionGrid = Array(9) { row -&gt;&#10;                        IntArray(9) { col -&gt;&#10;                            val rowData = solutionList[row] as? List&lt;*&gt;&#10;                            (rowData?.get(col) as? Number)?.toInt() ?: 0&#10;                        }&#10;                    }&#10;&#10;                    this.grid = Array(9) { row -&gt;&#10;                        Array(9) { col -&gt;&#10;                            val rowData = puzzleList[row] as? List&lt;*&gt;&#10;                            val cellValue = (rowData?.get(col) as? Number)?.toInt() ?: 0&#10;                            SudokuCell(&#10;                                value = cellValue,&#10;                                isOriginal = cellValue != 0&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Fallback to new puzzle generation&#10;                generateNewPuzzle(difficulty)&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback to new puzzle generation&#10;            generateNewPuzzle(difficulty)&#10;        }&#10;    }&#10;&#10;    private fun generateNewPuzzle(difficulty: String) {&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        this.solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        this.grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused &amp;&amp; isGameActive) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Force reset game completion state - used to prevent race conditions&#10;     */&#10;    fun resetGameCompletion() {&#10;        isGameCompleted = false&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;&#10;    /**&#10;     * Load game state from saved data&#10;     */&#10;    fun loadFromSavedState(savedState: SavedGameState) {&#10;        this.difficulty = savedState.difficulty&#10;        this.elapsedTimeSeconds = savedState.elapsedTimeSeconds&#10;        this.mistakesCount = savedState.mistakesCount&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.errorCells = emptySet()&#10;&#10;        // Convert saved grid to SudokuCell array&#10;        this.grid = Array(9) { row -&gt;&#10;            Array(9) { col -&gt;&#10;                val saved = savedState.grid[row][col]&#10;                SudokuCell(&#10;                    value = saved.value,&#10;                    notes = saved.notes.toSet(),&#10;                    isOriginal = saved.isOriginal,&#10;                    hasError = saved.hasError&#10;                )&#10;            }&#10;        }&#10;&#10;        // Convert solution grid&#10;        this.solutionGrid = Array(9) { row -&gt;&#10;            IntArray(9) { col -&gt;&#10;                savedState.solutionGrid[row][col]&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Autofill all valid notes for empty cells&#10;     */&#10;    fun autofillNotes() {&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val oldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty &amp;&amp; !cell.isOriginal) {&#10;                    val validNotes = getValidNotesForCell(row, col)&#10;                    if (validNotes != cell.notes) {&#10;                        affectedCells.add(Pair(row, col))&#10;                        oldNotes.add(cell.notes)&#10;                        newGrid[row][col] = cell.copy(notes = validNotes)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Only update grid and add to history if there were changes&#10;        if (affectedCells.isNotEmpty()) {&#10;            // Create action for undo&#10;            val action = GameAction.AutofillNotes(affectedCells, oldNotes)&#10;            actionHistory.push(action)&#10;            grid = newGrid&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all valid notes for a cell based on current grid state&#10;     */&#10;    private fun getValidNotesForCell(row: Int, col: Int): Set&lt;Int&gt; {&#10;        val validNotes = mutableSetOf&lt;Int&gt;()&#10;&#10;        for (number in 1..9) {&#10;            if (isValidPlacement(row, col, number)) {&#10;                validNotes.add(number)&#10;            }&#10;        }&#10;&#10;        return validNotes&#10;    }&#10;&#10;    /**&#10;     * Check if placing a number at the given position would be valid&#10;     */&#10;    private fun isValidPlacement(row: Int, col: Int, number: Int): Boolean {&#10;        // Check row&#10;        for (c in 0..8) {&#10;            if (grid[row][c].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check column&#10;        for (r in 0..8) {&#10;            if (grid[r][col].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check 3x3 box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if (grid[r][c].value == number) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Selects the next available number&#10;     */&#10;    fun selectNextAvailableNumber() {&#10;        if (selectedNumber != null &amp;&amp; selectedNumber == 9) {&#10;            selectedNumber = 1 // Wrap around to 1&#10;        } else {&#10;            selectedNumber = (selectedNumber ?: 0) + 1&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Store the original puzzle (before any player input)&#10;    internal var originalPuzzleGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Current number of mistakes made by the player&#10;    var mistakesCount by mutableIntStateOf(0)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    // Store the original solution grid for error checking&#10;    internal var solutionGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;        private set&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    private lateinit var repository: SudokuRepository&#10;&#10;    fun initializeRepository(context: Context) {&#10;        repository = SudokuRepository(context)&#10;    }&#10;&#10;    suspend fun submitScoreToServer(): Boolean {&#10;        return if (isGameCompleted &amp;&amp; ::repository.isInitialized &amp;&amp; repository.isLoggedIn()) {&#10;            val result = repository.submitGame(&#10;                difficulty = difficulty,&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;            result.isSuccess&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Record game completion in local statistics&#10;     */&#10;    fun recordGameCompletion(context: Context) {&#10;        if (isGameCompleted) {&#10;            com.kooshmeen.sudoku.utils.StatisticsManager.recordCompletedGame(&#10;                context = context,&#10;                difficulty = difficulty,&#10;                score = highestPossibleScore(),&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Returns highest possible score from current game state&#10;     * Calculated as:&#10;     * const score = Math.round((difficultyMultiplier * mistakePenalty) * (Math.max(0, (timeScore - timeSeconds) * 2) + basePoints));&#10;     * With: difficultyMultiplier = 0.33 for Easy, 0.7 for Medium, 1.5 for Hard&#10;     * timeScore = 600 for Easy, 1200 for Medium, 1800 for Hard&#10;     * mistakePenalty = max(0.4, 1 - (numberOfMistakes * 0.1)&#10;     * basePoints = 1000&#10;     */&#10;    fun highestPossibleScore(): Int {&#10;        val difficultyMultiplier = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 0.33&#10;            &quot;medium&quot; -&gt; 0.7&#10;            &quot;hard&quot; -&gt; 1.5&#10;            else -&gt; 0.33 // Default to Easy if unknown&#10;        }&#10;&#10;        val timeScore = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 600&#10;            &quot;medium&quot; -&gt; 1200&#10;            &quot;hard&quot; -&gt; 1800&#10;            else -&gt; 600 // Default to Easy if unknown&#10;        }&#10;&#10;        val mistakePenalty = maxOf(0.4, 1 - (mistakesCount * 0.1))&#10;        val basePoints = 1000&#10;&#10;        return ((difficultyMultiplier * mistakePenalty) * (maxOf(0, (timeScore - elapsedTimeSeconds) * 2) + basePoints)).toInt()&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;        if (currentCell.isOriginal) return&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        // Error: compare to solutionGrid&#10;        val hasError = solutionGrid[row][col] != value&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(),&#10;            hasError = hasError&#10;        )&#10;        // Track cells and old notes for undo&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val affectedOldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;        // Remove notes of this value in row&#10;        for (c in 0..8) {&#10;            if (c != col) {&#10;                val cell = newGrid[row][c]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(row, c))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[row][c] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from column&#10;        for (r in 0..8) {&#10;            if (r != row) {&#10;                val cell = newGrid[r][col]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(r, col))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[r][col] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if ((r != row || c != col)) {&#10;                    val cell = newGrid[r][c]&#10;                    if (cell.notes.contains(value)) {&#10;                        affectedCells.add(Pair(r, c))&#10;                        affectedOldNotes.add(cell.notes)&#10;                        newGrid[r][c] = cell.copy(notes = cell.notes - value)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // Push batch note removal to action stack for undo&#10;        if (affectedCells.isNotEmpty()) {&#10;            actionHistory.push(GameAction.RemoveNotesBatch(affectedCells, value, affectedOldNotes))&#10;        }&#10;        if (hasError) {&#10;            errorCells = errorCells + Pair(row, col)&#10;            // Mark as mistake&#10;            mistakesCount++&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;        grid = newGrid&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = SudokuCell() // Create a new empty cell&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    hasError = false&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = SudokuCell(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    isOriginal = grid[action.row][action.col].isOriginal&#10;                )&#10;            }&#10;            is GameAction.RemoveNotesBatch -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;            is GameAction.AutofillNotes -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if minimum time requirement is met (5 seconds)&#10;        if (elapsedTimeSeconds &lt; 5) {&#10;            return false&#10;        }&#10;&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Empty grid&#10;     */&#10;    fun clearGrid() {&#10;        grid = Array(9) { Array(9) { SudokuCell() } }&#10;        selectedCell = null&#10;        selectedNumber = null&#10;        actionHistory.clear()&#10;        mistakesCount = 0&#10;        elapsedTimeSeconds = 0&#10;        isPaused = false&#10;        isGameActive = false&#10;        isGameCompleted = false&#10;        errorCells = emptySet()&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        // Generate a new puzzle and store the solution grid&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Load a challenge game with specific puzzle data&#10;     */&#10;    fun loadChallengeGame(puzzleData: Map&lt;*, *&gt;, difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        try {&#10;            val puzzleList = puzzleData[&quot;puzzle&quot;] as? List&lt;*&gt;&#10;            val solutionList = puzzleData[&quot;solution&quot;] as? List&lt;*&gt;&#10;&#10;            if (puzzleList != null &amp;&amp; solutionList != null) {&#10;                // Handle flat array format (81 elements)&#10;                if (puzzleList.size == 81 &amp;&amp; solutionList.size == 81) {&#10;                    // Convert flat arrays to 2D&#10;                    this.solutionGrid = Array(9) { row -&gt;&#10;                        IntArray(9) { col -&gt;&#10;                            val index = row * 9 + col&#10;                            (solutionList[index] as? Number)?.toInt() ?: 0&#10;                        }&#10;                    }&#10;&#10;                    this.grid = Array(9) { row -&gt;&#10;                        Array(9) { col -&gt;&#10;                            val index = row * 9 + col&#10;                            val cellValue = (puzzleList[index] as? Number)?.toInt() ?: 0&#10;                            SudokuCell(&#10;                                value = cellValue,&#10;                                isOriginal = cellValue != 0&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    // Handle 2D array format (9x9)&#10;                    this.solutionGrid = Array(9) { row -&gt;&#10;                        IntArray(9) { col -&gt;&#10;                            val rowData = solutionList[row] as? List&lt;*&gt;&#10;                            (rowData?.get(col) as? Number)?.toInt() ?: 0&#10;                        }&#10;                    }&#10;&#10;                    this.grid = Array(9) { row -&gt;&#10;                        Array(9) { col -&gt;&#10;                            val rowData = puzzleList[row] as? List&lt;*&gt;&#10;                            val cellValue = (rowData?.get(col) as? Number)?.toInt() ?: 0&#10;                            SudokuCell(&#10;                                value = cellValue,&#10;                                isOriginal = cellValue != 0&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Fallback to new puzzle generation&#10;                generateNewPuzzle(difficulty)&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback to new puzzle generation&#10;            generateNewPuzzle(difficulty)&#10;        }&#10;    }&#10;&#10;    private fun generateNewPuzzle(difficulty: String) {&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        this.solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        this.grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused &amp;&amp; isGameActive) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Force reset game completion state - used to prevent race conditions&#10;     */&#10;    fun resetGameCompletion() {&#10;        isGameCompleted = false&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;&#10;    /**&#10;     * Load game state from saved data&#10;     */&#10;    fun loadFromSavedState(savedState: SavedGameState) {&#10;        this.difficulty = savedState.difficulty&#10;        this.elapsedTimeSeconds = savedState.elapsedTimeSeconds&#10;        this.mistakesCount = savedState.mistakesCount&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.errorCells = emptySet()&#10;&#10;        // Convert saved grid to SudokuCell array&#10;        this.grid = Array(9) { row -&gt;&#10;            Array(9) { col -&gt;&#10;                val saved = savedState.grid[row][col]&#10;                SudokuCell(&#10;                    value = saved.value,&#10;                    notes = saved.notes.toSet(),&#10;                    isOriginal = saved.isOriginal,&#10;                    hasError = saved.hasError&#10;                )&#10;            }&#10;        }&#10;&#10;        // Convert solution grid&#10;        this.solutionGrid = Array(9) { row -&gt;&#10;            IntArray(9) { col -&gt;&#10;                savedState.solutionGrid[row][col]&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Autofill all valid notes for empty cells&#10;     */&#10;    fun autofillNotes() {&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val oldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty &amp;&amp; !cell.isOriginal) {&#10;                    val validNotes = getValidNotesForCell(row, col)&#10;                    if (validNotes != cell.notes) {&#10;                        affectedCells.add(Pair(row, col))&#10;                        oldNotes.add(cell.notes)&#10;                        newGrid[row][col] = cell.copy(notes = validNotes)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Only update grid and add to history if there were changes&#10;        if (affectedCells.isNotEmpty()) {&#10;            // Create action for undo&#10;            val action = GameAction.AutofillNotes(affectedCells, oldNotes)&#10;            actionHistory.push(action)&#10;            grid = newGrid&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all valid notes for a cell based on current grid state&#10;     */&#10;    private fun getValidNotesForCell(row: Int, col: Int): Set&lt;Int&gt; {&#10;        val validNotes = mutableSetOf&lt;Int&gt;()&#10;&#10;        for (number in 1..9) {&#10;            if (isValidPlacement(row, col, number)) {&#10;                validNotes.add(number)&#10;            }&#10;        }&#10;&#10;        return validNotes&#10;    }&#10;&#10;    /**&#10;     * Check if placing a number at the given position would be valid&#10;     */&#10;    private fun isValidPlacement(row: Int, col: Int, number: Int): Boolean {&#10;        // Check row&#10;        for (c in 0..8) {&#10;            if (grid[row][c].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check column&#10;        for (r in 0..8) {&#10;            if (grid[r][col].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check 3x3 box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if (grid[r][c].value == number) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Selects the next available number&#10;     */&#10;    fun selectNextAvailableNumber() {&#10;        if (selectedNumber != null &amp;&amp; selectedNumber == 9) {&#10;            selectedNumber = 1 // Wrap around to 1&#10;        } else {&#10;            selectedNumber = (selectedNumber ?: 0) + 1&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/LiveMatchAcceptingCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/LiveMatchAcceptingCard.kt" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun LiveMatchAcceptingCard(&#10;    matchId: Int,&#10;    difficulty: String,&#10;    challengerName: String,&#10;    onNavigateToGame: (String, Int?, Int?) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var waitingForPuzzle by remember { mutableStateOf(true) }&#10;    var statusMessage by remember { mutableStateOf(&quot;Match accepted! Waiting for puzzle...&quot;) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    &#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Start polling for active status&#10;    LaunchedEffect(matchId) {&#10;        var pollCount = 0&#10;        while (waitingForPuzzle &amp;&amp; pollCount &lt; 30) { // Max 60 seconds&#10;            delay(2000) // Poll every 2 seconds&#10;            scope.launch {&#10;                val statusResult = repository.getLiveMatchStatus(matchId)&#10;                statusResult.fold(&#10;                    onSuccess = { matchStatus -&gt;&#10;                        when (matchStatus.status) {&#10;                            &quot;active&quot; -&gt; {&#10;                                statusMessage = &quot;Puzzle ready! Starting game...&quot;&#10;                                delay(1000)&#10;                                onNavigateToGame(difficulty, null, matchId)&#10;                                waitingForPuzzle = false&#10;                                onDismiss()&#10;                            }&#10;                            &quot;cancelled&quot; -&gt; {&#10;                                statusMessage = &quot;Match was cancelled&quot;&#10;                                waitingForPuzzle = false&#10;                                onDismiss()&#10;                            }&#10;                        }&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        // Continue polling on error, but log it&#10;                        println(&quot;Polling error: ${exception.message}&quot;)&#10;                    }&#10;                )&#10;            }&#10;            pollCount++&#10;        }&#10;        &#10;        if (pollCount &gt;= 30) {&#10;            statusMessage = &quot;Timeout waiting for puzzle&quot;&#10;            errorMessage = &quot;The challenger took too long to generate the puzzle&quot;&#10;            waitingForPuzzle = false&#10;        }&#10;    }&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Header text&#10;            Text(&#10;                text = &quot;Live Match Starting&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onPrimaryContainer&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Status message&#10;            Text(&#10;                text = statusMessage,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                textAlign = TextAlign.Center&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Loading indicator (only show if still waiting)&#10;            if (waitingForPuzzle) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(40.dp),&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    strokeWidth = 3.dp&#10;                )&#10;            }&#10;&#10;            // Error message if any&#10;            errorMessage?.let { message -&gt;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&#10;                    text = message,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.error,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                Button(&#10;                    onClick = onDismiss,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Close&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GameScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GameScreen.kt" />
              <option name="originalContent" value="/**&#10; * Game Screen for the Sudoku Game&#10; * This screen displays the Sudoku grid and allows users to play the game.&#10; * Includes a timer from the start of the game, a difficulty indicator,&#10; * a back button to return to the main menu, and a pause button - which pauses the timer&#10; * and covers the grid.&#10; *&#10; * The grid is displayed using a SudokuGrid composable, and the input numbers are handled by an InputRow composable.&#10; * Below is a UtilityRow composable.&#10;*/&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Accessibility&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.GameState&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.components.InputRow&#10;import com.kooshmeen.sudoku.ui.components.SudokuGrid&#10;import com.kooshmeen.sudoku.ui.components.UtilityRow&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.collections.flatten&#10;import kotlin.collections.toList&#10;&#10;@Composable&#10;fun GameScreen(&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToMenu: () -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToChallengeResult: (Int, Int, Int) -&gt; Unit = { _, _, _ -&gt; }, // challengeId, timeSeconds, mistakes&#10;    onNavigateToLiveMatchResult: (Int, Int, Int) -&gt; Unit = { _, _, _ -&gt; }, // liveMatchId, timeSeconds, mistakes&#10;    challengeId: Int? = null, // Optional challenge ID for challenges mode&#10;    liveMatchId: Int? = null, // Optional live match ID for live matches&#10;    difficulty: String? = null, // Optional difficulty override for challenges&#10;    challengeRole: String? = null, // &quot;challenger&quot; or &quot;challenged&quot; to distinguish roles&#10;    isLiveMatch: Boolean = false // Flag to indicate if this is a live match&#10;) {&#10;    val gameState = GameStateManager.gameState&#10;    var showCompletionDialog by remember { mutableStateOf(false) }&#10;&#10;    var opponentTime by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;    var isChallenge by remember { mutableStateOf(challengeId != null) }&#10;    var challengeData by remember { mutableStateOf&lt;Map&lt;String, Any&gt;?&gt;(null) }&#10;&#10;    // Live match specific state variables&#10;    var opponentFinished by remember { mutableStateOf(false) }&#10;    var isPolling by remember { mutableStateOf(isLiveMatch) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Live match polling logic&#10;    LaunchedEffect(isLiveMatch, liveMatchId, isPolling) {&#10;        gameState.resetGameCompletion()&#10;        if (isLiveMatch &amp;&amp; liveMatchId != null &amp;&amp; isPolling) {&#10;            while (isPolling) {&#10;                delay(1000) // Poll every second&#10;                scope.launch {&#10;                    val result = repository.getLiveMatchStatus(liveMatchId)&#10;                    result.fold(&#10;                        onSuccess = { matchStatus -&gt;&#10;                            // Update opponent status based on match data&#10;                            val currentUserId = repository.fetchCurrentUser()?.id&#10;                            if (currentUserId == matchStatus.challenger_id) {&#10;                                // Current user is challenger, check challenged status&#10;                                opponentFinished = matchStatus.challenged_finished&#10;                                if (matchStatus.challenged_time != null) {&#10;                                    opponentTime = matchStatus.challenged_time&#10;                                }&#10;                            } else {&#10;                                // Current user is challenged, check challenger status&#10;                                opponentFinished = matchStatus.challenger_finished&#10;                                if (matchStatus.challenger_time != null) {&#10;                                    opponentTime = matchStatus.challenger_time&#10;                                }&#10;                            }&#10;&#10;                            // Stop polling if match is completed&#10;                            if (matchStatus.status == &quot;completed&quot; || matchStatus.status == &quot;results_ready&quot;) {&#10;                                isPolling = false&#10;                            }&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            // Handle polling error - maybe reduce frequency or stop&#10;                            println(&quot;Live match polling error: ${exception.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Load challenge data if this is a challenge game&#10;    LaunchedEffect(challengeId, difficulty) {&#10;        gameState.resetGameCompletion()&#10;        challengeId?.let { id -&gt;&#10;            isChallenge = true&#10;&#10;            // Check if this is accepting an existing challenge (challenged player)&#10;            // or creating a new puzzle for offline challenge (challenger)&#10;            scope.launch {&#10;                val result = repository.getChallengeData(id)&#10;                result.fold(&#10;                    onSuccess = { data -&gt;&#10;                        challengeData = data&#10;                        opponentTime = (data[&quot;challengerTime&quot;] as? Number)?.toInt()&#10;&#10;                        // If puzzle data exists, load that specific puzzle&#10;                        val puzzleData = data[&quot;puzzleData&quot;] as? Map&lt;*, *&gt;&#10;                        if (puzzleData != null) {&#10;                            // Load the exact same puzzle the challenger played&#10;                            GameStateManager.loadChallengeGame(puzzleData, difficulty ?: &quot;medium&quot;, context)&#10;                        } else {&#10;                            // This is the challenger creating a new puzzle&#10;                            difficulty?.let { diff -&gt;&#10;                                GameStateManager.startNewGame(diff, context)&#10;                            }&#10;                        }&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        // If no challenge data exists, this is a new challenge being created&#10;                        difficulty?.let { diff -&gt;&#10;                            GameStateManager.startNewGame(diff, context)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Load live match data if this is a live match&#10;    LaunchedEffect(liveMatchId, isLiveMatch) {&#10;        gameState.resetGameCompletion()&#10;        if (isLiveMatch &amp;&amp; liveMatchId != null) {&#10;            scope.launch {&#10;                val result = repository.getLiveMatchStatus(liveMatchId)&#10;                result.fold(&#10;                    onSuccess = { matchStatus -&gt;&#10;                        // Parse the puzzle data from JSON string&#10;                        try {&#10;                            val puzzleDataString = matchStatus.puzzle_data&#10;                            if (puzzleDataString.isNotEmpty()) {&#10;                                // Parse the JSON string to extract puzzle data&#10;                                // The JSON contains: {&quot;puzzle&quot;:[...], &quot;solution&quot;:[...], &quot;difficulty&quot;:&quot;...&quot;}&#10;                                val gson = com.google.gson.Gson()&#10;                                val puzzleData = gson.fromJson(puzzleDataString, Map::class.java) as Map&lt;String, Any&gt;&#10;                                GameStateManager.loadChallengeGame(puzzleData, matchStatus.difficulty, context)&#10;                            } else {&#10;                                // Fallback to creating new game&#10;                                difficulty?.let { diff -&gt;&#10;                                    GameStateManager.startNewGame(diff, context)&#10;                                }&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            // Handle JSON parsing error&#10;                            println(&quot;Error parsing puzzle data: ${e.message}&quot;)&#10;                            difficulty?.let { diff -&gt;&#10;                                GameStateManager.startNewGame(diff, context)&#10;                            }&#10;                        }&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        // Handle error loading live match data&#10;                        difficulty?.let { diff -&gt;&#10;                            GameStateManager.startNewGame(diff, context)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timer effect - only run when game is active and not paused&#10;    LaunchedEffect(gameState.isGameActive, gameState.isPaused) {&#10;        while (gameState.isGameActive &amp;&amp; !gameState.isPaused) {&#10;            delay(1000)&#10;            gameState.updateTimer()&#10;        }&#10;    }&#10;&#10;    // Check for game completion&#10;    LaunchedEffect(gameState.isGameCompleted) {&#10;        if (gameState.isGameCompleted) {&#10;            showCompletionDialog = true&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(12.dp)&#10;            .background(MaterialTheme.colorScheme.background) // Use MaterialTheme for background color&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // Timer with color logic for live matches&#10;            Text(&#10;                text = &quot;Elapsed: ${gameState.getFormattedTime()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp),&#10;                color = if (isLiveMatch) {&#10;                    if (opponentFinished) MaterialTheme.colorScheme.error // Red when opponent finished&#10;                    else MaterialTheme.colorScheme.primary // Blue when opponent hasn't finished&#10;                } else MaterialTheme.colorScheme.onSurface // Default color for non-live matches&#10;            )&#10;&#10;            // Show opponent info for both challenges and live matches&#10;            if ((isChallenge || isLiveMatch) &amp;&amp; opponentTime != null) {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Accessibility,&#10;                        contentDescription = null,&#10;                        tint = if (isLiveMatch &amp;&amp; opponentFinished)&#10;                            MaterialTheme.colorScheme.error&#10;                        else MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = formatTime(opponentTime!!),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = if (isLiveMatch &amp;&amp; opponentFinished)&#10;                            MaterialTheme.colorScheme.error&#10;                        else MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = if (isLiveMatch) &quot;Live Opponent&quot; else &quot;Opponent&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the difficulty indicator to the end&#10;            // Difficulty indicator&#10;            Text(&#10;                text = gameState.difficulty,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 32.dp)&#10;            )&#10;        }&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // back to menu button&#10;            IconButton(&#10;                onClick = onNavigateToMenu,&#10;                modifier = Modifier.padding(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back to Main Menu&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground // Use MaterialTheme for icon color&#10;                )&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the pause button to the end&#10;            // Pause button - will pause timer, but cover the grid&#10;            IconButton(&#10;                onClick = { gameState.togglePause() },&#10;                modifier = Modifier.padding(8.dp),&#10;                // align the icon to the end of the row&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Lock,&#10;                    contentDescription = &quot;Pause Game&quot;,&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        // Display number of mistakes and highest possible score&#10;        Row (&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Mistakes: ${gameState.mistakesCount}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;            Spacer(Modifier.weight(1f)) // Push the highest possible score to the end&#10;            Text(&#10;                text = &quot;Max Score: ${gameState.highestPossibleScore()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(end = 8.dp)&#10;            )&#10;        }&#10;&#10;        Spacer(Modifier.height(14.dp))&#10;        // Grid - show overlay when paused&#10;        Box(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            SudokuGrid(&#10;                grid = gameState.grid,&#10;                selectedCell = null,&#10;                selectedNumber = gameState.selectedNumber, // Pass selectedNumber&#10;                onCellClick = { row, col -&gt;&#10;                    gameState.inputToCell(row, col)&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Pause overlay&#10;            if (gameState.isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 1f)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Paused&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Compute which numbers are disabled (already filled in all spots)&#10;        val numberCounts = IntArray(9) { 0 }&#10;        for (row in gameState.grid) {&#10;            for (cell in row) {&#10;                if (cell.value in 1..9) {&#10;                    numberCounts[cell.value - 1]++&#10;                }&#10;            }&#10;        }&#10;        val disabledNumbers = numberCounts.mapIndexed { idx, count -&gt; if (count &gt;= 9) { idx + 1 }&#10;        else null }.filterNotNull()&#10;&#10;        // If selected number is disabled, select the next available number&#10;        if (gameState.selectedNumber != null &amp;&amp; disabledNumbers.contains(gameState.selectedNumber)) {&#10;            gameState.selectNextAvailableNumber()&#10;        }&#10;&#10;        // Input numbers row&#10;        InputRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            input = List(9) { it + 1 },&#10;            onInputChange = { index, value -&gt;&#10;                val number = value.toInt()&#10;                if (!disabledNumbers.contains(number)) {&#10;                    gameState.selectNumber(number)&#10;                }&#10;            },&#10;            selectedNumber = gameState.selectedNumber,&#10;            disabledNumbers = disabledNumbers // Pass disabled numbers&#10;        )&#10;        Spacer(Modifier.height(24.dp))&#10;        // Utility Row&#10;        UtilityRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            selectedButton = when (gameState.gameMode) {&#10;                GameState.GameMode.NOTES -&gt; &quot;notes&quot;&#10;                GameState.GameMode.ERASE -&gt; &quot;erase&quot;&#10;                else -&gt; null&#10;            },&#10;            onEraseClick = { gameState.toggleEraseMode() },&#10;            onNotesClick = { gameState.toggleNotesMode() },&#10;            onUndoClick = { gameState.undo() },&#10;            onAutofillNotesClick = { gameState.autofillNotes() }&#10;        )&#10;&#10;        // Completion Dialog&#10;        if (showCompletionDialog) {&#10;            // Check for new best time&#10;            val (isNewBest, isNewBestNoMistakes) = BestTimeManager.setBestTime(&#10;                context = LocalContext.current,&#10;                difficulty = gameState.difficulty,&#10;                time = gameState.getFormattedTime(),&#10;                numMistakes = gameState.mistakesCount,&#10;            )&#10;&#10;            val context = LocalContext.current&#10;&#10;            LaunchedEffect(Unit) {&#10;                // Initialize repository if not done&#10;                gameState.initializeRepository(context)&#10;&#10;                // Record game completion in local statistics&#10;                gameState.recordGameCompletion(context)&#10;&#10;                // Try to submit score&#10;                val submitted = gameState.submitScoreToServer()&#10;                if (!submitted) { // off line mode or not connected to server&#10;                    // Show a toast or some indication that score submission failed&#10;                    // Toast.makeText(context, &quot;Score submission failed. Please try again later.&quot;, Toast.LENGTH_SHORT).show()&#10;                    // For now, we will just log it&#10;                    println(&quot;Score submission failed. Please try again later.&quot;)&#10;                }&#10;&#10;                // log the isChallenge, isLiveMatch, challengeId, liveMatchId, challengeRole values&#10;                Log.d(&quot;GameScreen&quot;, &quot;isChallenge: $isChallenge, isLiveMatch: $isLiveMatch, challengeId: $challengeId, liveMatchId: $liveMatchId, challengeRole: $challengeRole&quot;)&#10;                // challenge - handle offline challenges differently based on role&#10;                if (isChallenge &amp;&amp; challengeId != null) {&#10;                    if (challengeRole == &quot;challenger&quot;) {&#10;                        // For offline challenges, the challenger needs to send puzzle data along with completion&#10;                        val challengeResult = repository.completeChallengerGame(&#10;                            challengeId = challengeId,&#10;                            timeSeconds = gameState.elapsedTimeSeconds,&#10;                            numberOfMistakes = gameState.mistakesCount,&#10;                            puzzleData = mapOf&lt;String, Any&gt;(&#10;                                &quot;puzzle&quot; to gameState.grid.flatMap { row -&gt;&#10;                                    row.map { cell -&gt; if (cell.isOriginal) cell.value else 0 }&#10;                                },&#10;                                &quot;solution&quot; to gameState.solutionGrid.flatMap { it.toList() },&#10;                                &quot;difficulty&quot; to gameState.difficulty&#10;                            )&#10;                        )&#10;                        challengeResult.fold(&#10;                            onSuccess = {&#10;                                // Successfully submitted challenger's game completion&#10;                                println(&quot;Challenger game completed successfully. Invitation sent to challenged player.&quot;)&#10;                            },&#10;                            onFailure = { exception -&gt;&#10;                                // Handle error submitting challenger's game&#10;                                println(&quot;Error submitting challenger game: ${exception.message}&quot;)&#10;                            }&#10;                        )&#10;                    } else if (challengeRole == &quot;challenged&quot;) {&#10;                        // For challenged player, complete the challenge and navigate to results&#10;                        showCompletionDialog = false&#10;                        GameStateManager.endGame()&#10;                        onNavigateToChallengeResult(challengeId, gameState.elapsedTimeSeconds, gameState.mistakesCount)&#10;                        return@LaunchedEffect&#10;                    }&#10;                } else if (isLiveMatch &amp;&amp; liveMatchId != null) {&#10;                    // log if the app has reached here&#10;                    Log.d(&quot;GameScreen&quot;, &quot;Submitting live match completion for matchId: $liveMatchId&quot;)&#10;                    // Handle live match completion&#10;                    val liveMatchResult = repository.completeLiveMatch(&#10;                        matchId = liveMatchId,&#10;                        timeSeconds = gameState.elapsedTimeSeconds,&#10;                        mistakes = gameState.mistakesCount,&#10;                        update = false&#10;                    )&#10;                    liveMatchResult.fold(&#10;                        onSuccess = {&#10;                            // Successfully submitted live match completion&#10;                            println(&quot;Live match completed successfully.&quot;)&#10;                            // Navigate to live match results&#10;                            onNavigateToLiveMatchResult(liveMatchId, gameState.elapsedTimeSeconds, gameState.mistakesCount)&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            // Handle error submitting live match completion&#10;                            println(&quot;Error submitting live match completion: ${exception.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            GameStateManager.endGame()&#10;            AlertDialog(&#10;                onDismissRequest = {&#10;                    showCompletionDialog = false&#10;                    GameStateManager.endGame()&#10;                },&#10;                title = { Text(&quot;Congratulations! Final score: ${gameState.highestPossibleScore()}&quot;) },&#10;                text = {&#10;                    if (isNewBest) {&#10;                        Text(&quot;You completed the game in a new best time for ${gameState.difficulty}: ${gameState.getFormattedTime()}!&quot;)&#10;                    } else {&#10;                        Text(&quot;You completed the game in ${gameState.getFormattedTime()}! Your best time for ${gameState.difficulty} is ${BestTimeManager.getBestTimeFormatted(LocalContext.current, gameState.difficulty)}.&quot;)&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    Button(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                            onNavigateToMenu()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Back to Menu&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Stay Here&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(&quot;%02d:%02d&quot;, minutes, remainingSeconds)&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GameScreenPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        GameScreen(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it },&#10;&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game Screen for the Sudoku Game&#10; * This screen displays the Sudoku grid and allows users to play the game.&#10; * Includes a timer from the start of the game, a difficulty indicator,&#10; * a back button to return to the main menu, and a pause button - which pauses the timer&#10; * and covers the grid.&#10; *&#10; * The grid is displayed using a SudokuGrid composable, and the input numbers are handled by an InputRow composable.&#10; * Below is a UtilityRow composable.&#10;*/&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Accessibility&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.GameState&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.components.InputRow&#10;import com.kooshmeen.sudoku.ui.components.SudokuGrid&#10;import com.kooshmeen.sudoku.ui.components.UtilityRow&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.collections.flatten&#10;import kotlin.collections.toList&#10;&#10;@Composable&#10;fun GameScreen(&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToMenu: () -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToChallengeResult: (Int, Int, Int) -&gt; Unit = { _, _, _ -&gt; }, // challengeId, timeSeconds, mistakes&#10;    onNavigateToLiveMatchResult: (Int, Int, Int) -&gt; Unit = { _, _, _ -&gt; }, // liveMatchId, timeSeconds, mistakes&#10;    challengeId: Int? = null, // Optional challenge ID for challenges mode&#10;    liveMatchId: Int? = null, // Optional live match ID for live matches&#10;    difficulty: String? = null, // Optional difficulty override for challenges&#10;    challengeRole: String? = null, // &quot;challenger&quot; or &quot;challenged&quot; to distinguish roles&#10;    isLiveMatch: Boolean = false // Flag to indicate if this is a live match&#10;) {&#10;    val gameState = GameStateManager.gameState&#10;    var showCompletionDialog by remember { mutableStateOf(false) }&#10;&#10;    var opponentTime by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;    var isChallenge by remember { mutableStateOf(challengeId != null) }&#10;    var challengeData by remember { mutableStateOf&lt;Map&lt;String, Any&gt;?&gt;(null) }&#10;&#10;    // Live match specific state variables&#10;    var opponentFinished by remember { mutableStateOf(false) }&#10;    var isPolling by remember { mutableStateOf(isLiveMatch) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Live match polling logic&#10;    LaunchedEffect(isLiveMatch, liveMatchId, isPolling) {&#10;        gameState.resetGameCompletion()&#10;        if (isLiveMatch &amp;&amp; liveMatchId != null &amp;&amp; isPolling) {&#10;            while (isPolling) {&#10;                delay(1000) // Poll every second&#10;                scope.launch {&#10;                    val result = repository.getLiveMatchStatus(liveMatchId)&#10;                    result.fold(&#10;                        onSuccess = { matchStatus -&gt;&#10;                            // Update opponent status based on match data&#10;                            val currentUserId = repository.fetchCurrentUser()?.id&#10;                            if (currentUserId == matchStatus.challenger_id) {&#10;                                // Current user is challenger, check challenged status&#10;                                opponentFinished = matchStatus.challenged_finished&#10;                                if (matchStatus.challenged_time != null) {&#10;                                    opponentTime = matchStatus.challenged_time&#10;                                }&#10;                            } else {&#10;                                // Current user is challenged, check challenger status&#10;                                opponentFinished = matchStatus.challenger_finished&#10;                                if (matchStatus.challenger_time != null) {&#10;                                    opponentTime = matchStatus.challenger_time&#10;                                }&#10;                            }&#10;&#10;                            // Stop polling if match is completed&#10;                            if (matchStatus.status == &quot;completed&quot; || matchStatus.status == &quot;results_ready&quot;) {&#10;                                isPolling = false&#10;                            }&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            // Handle polling error - maybe reduce frequency or stop&#10;                            println(&quot;Live match polling error: ${exception.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Load challenge data if this is a challenge game&#10;    LaunchedEffect(challengeId, difficulty) {&#10;        gameState.resetGameCompletion()&#10;        challengeId?.let { id -&gt;&#10;            isChallenge = true&#10;&#10;            // Check if this is accepting an existing challenge (challenged player)&#10;            // or creating a new puzzle for offline challenge (challenger)&#10;            scope.launch {&#10;                val result = repository.getChallengeData(id)&#10;                result.fold(&#10;                    onSuccess = { data -&gt;&#10;                        challengeData = data&#10;                        opponentTime = (data[&quot;challengerTime&quot;] as? Number)?.toInt()&#10;&#10;                        // If puzzle data exists, load that specific puzzle&#10;                        val puzzleData = data[&quot;puzzleData&quot;] as? Map&lt;*, *&gt;&#10;                        if (puzzleData != null) {&#10;                            // Load the exact same puzzle the challenger played&#10;                            GameStateManager.loadChallengeGame(puzzleData, difficulty ?: &quot;medium&quot;, context)&#10;                        } else {&#10;                            // This is the challenger creating a new puzzle&#10;                            difficulty?.let { diff -&gt;&#10;                                GameStateManager.startNewGame(diff, context)&#10;                            }&#10;                        }&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        // If no challenge data exists, this is a new challenge being created&#10;                        difficulty?.let { diff -&gt;&#10;                            GameStateManager.startNewGame(diff, context)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Load live match data if this is a live match&#10;    LaunchedEffect(liveMatchId, isLiveMatch) {&#10;        gameState.resetGameCompletion()&#10;        if (isLiveMatch &amp;&amp; liveMatchId != null) {&#10;            scope.launch {&#10;                val result = repository.getLiveMatchStatus(liveMatchId)&#10;                result.fold(&#10;                    onSuccess = { matchStatus -&gt;&#10;                        // Parse the puzzle data from JSON string&#10;                        try {&#10;                            val puzzleDataString = matchStatus.puzzle_data&#10;                            if (puzzleDataString.isNotEmpty()) {&#10;                                // Parse the JSON string to extract puzzle data&#10;                                // The JSON contains: {&quot;puzzle&quot;:[...], &quot;solution&quot;:[...], &quot;difficulty&quot;:&quot;...&quot;}&#10;                                val gson = com.google.gson.Gson()&#10;                                val puzzleData = gson.fromJson(puzzleDataString, Map::class.java) as Map&lt;String, Any&gt;&#10;                                GameStateManager.loadChallengeGame(puzzleData, matchStatus.difficulty, context)&#10;                            } else {&#10;                                // Fallback to creating new game&#10;                                difficulty?.let { diff -&gt;&#10;                                    GameStateManager.startNewGame(diff, context)&#10;                                }&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            // Handle JSON parsing error&#10;                            println(&quot;Error parsing puzzle data: ${e.message}&quot;)&#10;                            difficulty?.let { diff -&gt;&#10;                                GameStateManager.startNewGame(diff, context)&#10;                            }&#10;                        }&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        // Handle error loading live match data&#10;                        difficulty?.let { diff -&gt;&#10;                            GameStateManager.startNewGame(diff, context)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timer effect - only run when game is active and not paused&#10;    LaunchedEffect(gameState.isGameActive, gameState.isPaused) {&#10;        while (gameState.isGameActive &amp;&amp; !gameState.isPaused) {&#10;            delay(1000)&#10;            gameState.updateTimer()&#10;        }&#10;    }&#10;&#10;    // Check for game completion&#10;    LaunchedEffect(gameState.isGameCompleted) {&#10;        if (gameState.isGameCompleted) {&#10;            showCompletionDialog = true&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(12.dp)&#10;            .background(MaterialTheme.colorScheme.background) // Use MaterialTheme for background color&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // Timer with color logic for live matches&#10;            Text(&#10;                text = &quot;Elapsed: ${gameState.getFormattedTime()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp),&#10;                color = if (isLiveMatch) {&#10;                    if (opponentFinished) MaterialTheme.colorScheme.error // Red when opponent finished&#10;                    else MaterialTheme.colorScheme.primary // Blue when opponent hasn't finished&#10;                } else MaterialTheme.colorScheme.onSurface // Default color for non-live matches&#10;            )&#10;&#10;            // Show opponent info for both challenges and live matches&#10;            if ((isChallenge || isLiveMatch) &amp;&amp; opponentTime != null) {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Accessibility,&#10;                        contentDescription = null,&#10;                        tint = if (isLiveMatch &amp;&amp; opponentFinished)&#10;                            MaterialTheme.colorScheme.error&#10;                        else MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = formatTime(opponentTime!!),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = if (isLiveMatch &amp;&amp; opponentFinished)&#10;                            MaterialTheme.colorScheme.error&#10;                        else MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = if (isLiveMatch) &quot;Live Opponent&quot; else &quot;Opponent&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the difficulty indicator to the end&#10;            // Difficulty indicator&#10;            Text(&#10;                text = gameState.difficulty,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 32.dp)&#10;            )&#10;        }&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // back to menu button&#10;            IconButton(&#10;                onClick = onNavigateToMenu,&#10;                modifier = Modifier.padding(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back to Main Menu&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground // Use MaterialTheme for icon color&#10;                )&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the pause button to the end&#10;            // Pause button - will pause timer, but cover the grid&#10;            IconButton(&#10;                onClick = { gameState.togglePause() },&#10;                modifier = Modifier.padding(8.dp),&#10;                // align the icon to the end of the row&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Lock,&#10;                    contentDescription = &quot;Pause Game&quot;,&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        // Display number of mistakes and highest possible score&#10;        Row (&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Mistakes: ${gameState.mistakesCount}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;            Spacer(Modifier.weight(1f)) // Push the highest possible score to the end&#10;            Text(&#10;                text = &quot;Max Score: ${gameState.highestPossibleScore()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(end = 8.dp)&#10;            )&#10;        }&#10;&#10;        Spacer(Modifier.height(14.dp))&#10;        // Grid - show overlay when paused&#10;        Box(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            SudokuGrid(&#10;                grid = gameState.grid,&#10;                selectedCell = null,&#10;                selectedNumber = gameState.selectedNumber, // Pass selectedNumber&#10;                onCellClick = { row, col -&gt;&#10;                    gameState.inputToCell(row, col)&#10;                },&#10;                onNoteToggle = { row, col, number -&gt;&#10;                    gameState.toggleNote(row, col, number)&#10;                },&#10;                gameMode = gameState.gameMode,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Pause overlay&#10;            if (gameState.isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 1f)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Paused&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Compute which numbers are disabled (already filled in all spots)&#10;        val numberCounts = IntArray(9) { 0 }&#10;        for (row in gameState.grid) {&#10;            for (cell in row) {&#10;                if (cell.value in 1..9) {&#10;                    numberCounts[cell.value - 1]++&#10;                }&#10;            }&#10;        }&#10;        val disabledNumbers = numberCounts.mapIndexed { idx, count -&gt; if (count &gt;= 9) { idx + 1 }&#10;        else null }.filterNotNull()&#10;&#10;        // If selected number is disabled, select the next available number&#10;        if (gameState.selectedNumber != null &amp;&amp; disabledNumbers.contains(gameState.selectedNumber)) {&#10;            gameState.selectNextAvailableNumber()&#10;        }&#10;&#10;        // Input numbers row&#10;        InputRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            input = List(9) { it + 1 },&#10;            onInputChange = { index, value -&gt;&#10;                val number = value.toInt()&#10;                if (!disabledNumbers.contains(number)) {&#10;                    gameState.selectNumber(number)&#10;                }&#10;            },&#10;            selectedNumber = gameState.selectedNumber,&#10;            disabledNumbers = disabledNumbers // Pass disabled numbers&#10;        )&#10;        Spacer(Modifier.height(24.dp))&#10;        // Utility Row&#10;        UtilityRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            selectedButton = when (gameState.gameMode) {&#10;                GameState.GameMode.NOTES -&gt; &quot;notes&quot;&#10;                GameState.GameMode.ERASE -&gt; &quot;erase&quot;&#10;                else -&gt; null&#10;            },&#10;            onEraseClick = { gameState.toggleEraseMode() },&#10;            onNotesClick = { gameState.toggleNotesMode() },&#10;            onUndoClick = { gameState.undo() },&#10;            onAutofillNotesClick = { gameState.autofillNotes() }&#10;        )&#10;&#10;        // Completion Dialog&#10;        if (showCompletionDialog) {&#10;            // Check for new best time&#10;            val (isNewBest, isNewBestNoMistakes) = BestTimeManager.setBestTime(&#10;                context = LocalContext.current,&#10;                difficulty = gameState.difficulty,&#10;                time = gameState.getFormattedTime(),&#10;                numMistakes = gameState.mistakesCount,&#10;            )&#10;&#10;            val context = LocalContext.current&#10;&#10;            LaunchedEffect(Unit) {&#10;                // Initialize repository if not done&#10;                gameState.initializeRepository(context)&#10;&#10;                // Record game completion in local statistics&#10;                gameState.recordGameCompletion(context)&#10;&#10;                // Try to submit score&#10;                val submitted = gameState.submitScoreToServer()&#10;                if (!submitted) { // off line mode or not connected to server&#10;                    // Show a toast or some indication that score submission failed&#10;                    // Toast.makeText(context, &quot;Score submission failed. Please try again later.&quot;, Toast.LENGTH_SHORT).show()&#10;                    // For now, we will just log it&#10;                    println(&quot;Score submission failed. Please try again later.&quot;)&#10;                }&#10;&#10;                // log the isChallenge, isLiveMatch, challengeId, liveMatchId, challengeRole values&#10;                Log.d(&quot;GameScreen&quot;, &quot;isChallenge: $isChallenge, isLiveMatch: $isLiveMatch, challengeId: $challengeId, liveMatchId: $liveMatchId, challengeRole: $challengeRole&quot;)&#10;                // challenge - handle offline challenges differently based on role&#10;                if (isChallenge &amp;&amp; challengeId != null) {&#10;                    if (challengeRole == &quot;challenger&quot;) {&#10;                        // For offline challenges, the challenger needs to send puzzle data along with completion&#10;                        val challengeResult = repository.completeChallengerGame(&#10;                            challengeId = challengeId,&#10;                            timeSeconds = gameState.elapsedTimeSeconds,&#10;                            numberOfMistakes = gameState.mistakesCount,&#10;                            puzzleData = mapOf&lt;String, Any&gt;(&#10;                                &quot;puzzle&quot; to gameState.grid.flatMap { row -&gt;&#10;                                    row.map { cell -&gt; if (cell.isOriginal) cell.value else 0 }&#10;                                },&#10;                                &quot;solution&quot; to gameState.solutionGrid.flatMap { it.toList() },&#10;                                &quot;difficulty&quot; to gameState.difficulty&#10;                            )&#10;                        )&#10;                        challengeResult.fold(&#10;                            onSuccess = {&#10;                                // Successfully submitted challenger's game completion&#10;                                println(&quot;Challenger game completed successfully. Invitation sent to challenged player.&quot;)&#10;                            },&#10;                            onFailure = { exception -&gt;&#10;                                // Handle error submitting challenger's game&#10;                                println(&quot;Error submitting challenger game: ${exception.message}&quot;)&#10;                            }&#10;                        )&#10;                    } else if (challengeRole == &quot;challenged&quot;) {&#10;                        // For challenged player, complete the challenge and navigate to results&#10;                        showCompletionDialog = false&#10;                        GameStateManager.endGame()&#10;                        onNavigateToChallengeResult(challengeId, gameState.elapsedTimeSeconds, gameState.mistakesCount)&#10;                        return@LaunchedEffect&#10;                    }&#10;                } else if (isLiveMatch &amp;&amp; liveMatchId != null) {&#10;                    // log if the app has reached here&#10;                    Log.d(&quot;GameScreen&quot;, &quot;Submitting live match completion for matchId: $liveMatchId&quot;)&#10;                    // Handle live match completion&#10;                    val liveMatchResult = repository.completeLiveMatch(&#10;                        matchId = liveMatchId,&#10;                        timeSeconds = gameState.elapsedTimeSeconds,&#10;                        mistakes = gameState.mistakesCount,&#10;                        update = false&#10;                    )&#10;                    liveMatchResult.fold(&#10;                        onSuccess = {&#10;                            // Successfully submitted live match completion&#10;                            println(&quot;Live match completed successfully.&quot;)&#10;                            // Navigate to live match results&#10;                            onNavigateToLiveMatchResult(liveMatchId, gameState.elapsedTimeSeconds, gameState.mistakesCount)&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            // Handle error submitting live match completion&#10;                            println(&quot;Error submitting live match completion: ${exception.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            GameStateManager.endGame()&#10;            AlertDialog(&#10;                onDismissRequest = {&#10;                    showCompletionDialog = false&#10;                    GameStateManager.endGame()&#10;                },&#10;                title = { Text(&quot;Congratulations! Final score: ${gameState.highestPossibleScore()}&quot;) },&#10;                text = {&#10;                    if (isNewBest) {&#10;                        Text(&quot;You completed the game in a new best time for ${gameState.difficulty}: ${gameState.getFormattedTime()}!&quot;)&#10;                    } else {&#10;                        Text(&quot;You completed the game in ${gameState.getFormattedTime()}! Your best time for ${gameState.difficulty} is ${BestTimeManager.getBestTimeFormatted(LocalContext.current, gameState.difficulty)}.&quot;)&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    Button(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                            onNavigateToMenu()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Back to Menu&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Stay Here&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(&quot;%02d:%02d&quot;, minutes, remainingSeconds)&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GameScreenPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        GameScreen(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it },&#10;&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordScreen.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>