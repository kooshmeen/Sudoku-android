<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt" />
              <option name="originalContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class RemoveNotesBatch(&#10;        val cells: List&lt;Pair&lt;Int, Int&gt;&gt;,&#10;        val note: Int,&#10;        val oldNotes: List&lt;Set&lt;Int&gt;&gt;&#10;    ) : GameAction()&#10;&#10;    data class AutofillNotes(&#10;        val cells: List&lt;Pair&lt;Int, Int&gt;&gt;,&#10;        val oldNotes: List&lt;Set&lt;Int&gt;&gt;&#10;    ) : GameAction()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt" />
              <option name="updatedContent" value="/**&#10; * Data class representing the serializable game state&#10; * Used for saving/loading games from SharedPreferences&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;data class SavedGameState(&#10;    val grid: List&lt;List&lt;SavedCellState&gt;&gt;,&#10;    val difficulty: String,&#10;    val elapsedTimeSeconds: Int,&#10;    val mistakesCount: Int,&#10;    val solutionGrid: List&lt;List&lt;Int&gt;&gt;&#10;)&#10;&#10;data class SavedCellState(&#10;    val value: Int,&#10;    val notes: List&lt;Int&gt;,&#10;    val isOriginal: Boolean,&#10;    val hasError: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/UtilityRow.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/UtilityRow.kt" />
              <option name="originalContent" value="/**&#10; * UtilityRow.kt&#10; * This file defines a composable function for displaying a row of utility buttons in the Sudoku app.&#10; * These buttons are, from left to right:&#10; * Erase: selecting it will enable erasing mode, clearing non-starting cells when clicked.&#10; * Notes: selecting it will toggle notes mode, allowing users to add notes to cells.&#10; * Undo: selecting it will undo the last action.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.kooshmeen.sudoku.R&#10;&#10;@Composable&#10;fun UtilityRow(&#10;    modifier: Modifier = Modifier,&#10;    selectedButton: String? = null,&#10;    onEraseClick: () -&gt; Unit = {},&#10;    onNotesClick: () -&gt; Unit = {},&#10;    onUndoClick: () -&gt; Unit = {}&#10;        }&#10;            )&#10;        }&#10;" />
              <option name="updatedContent" value="/**&#10; * UtilityRow.kt&#10; * This file defines a composable function for displaying a row of utility buttons in the Sudoku app.&#10; * These buttons are, from left to right:&#10; * Erase: selecting it will enable erasing mode, clearing non-starting cells when clicked.&#10; * Notes: selecting it will toggle notes mode, allowing users to add notes to cells.&#10; * Undo: selecting it will undo the last action.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.kooshmeen.sudoku.R&#10;&#10;@Composable&#10;fun UtilityRow(&#10;    modifier: Modifier = Modifier,&#10;    selectedButton: String? = null,&#10;    onEraseClick: () -&gt; Unit = {},&#10;    onNotesClick: () -&gt; Unit = {},&#10;    onUndoClick: () -&gt; Unit = {},&#10;    onAutofillNotesClick: () -&gt; Unit = {}&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        horizontalArrangement = androidx.compose.foundation.layout.Arrangement.SpaceEvenly,&#10;        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically&#10;    ) {&#10;        // Autofill Notes Button&#10;        IconButton(&#10;            onClick = onAutofillNotesClick,&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.add_notes_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Autofill Notes&quot;,&#10;                tint = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        // Erase Button&#10;        IconToggleButton(&#10;            checked = selectedButton == &quot;erase&quot;,&#10;            onCheckedChange = { onEraseClick() }, // Always call onEraseClick, let GameState handle toggle&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.ink_eraser_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Erase&quot;,&#10;                tint = if (selectedButton == &quot;erase&quot;) MaterialTheme.colorScheme.primary&#10;                else MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        // Notes Button&#10;        IconToggleButton(&#10;            checked = selectedButton == &quot;notes&quot;,&#10;            onCheckedChange = { onNotesClick() }, // Always call onNotesClick, let GameState handle toggle&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.add_notes_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Notes&quot;,&#10;                tint = if (selectedButton == &quot;notes&quot;) MaterialTheme.colorScheme.primary&#10;                else MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        // Undo Button&#10;        IconButton(&#10;            onClick = onUndoClick,&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.undo_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Undo&quot;,&#10;                tint = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview (showBackground = true)&#10;@Composable&#10;fun UtilityRowPreview() {&#10;    UtilityRow(&#10;        selectedButton = null,&#10;        modifier = Modifier.fillMaxSize()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/AuthScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/AuthScreen.kt" />
              <option name="updatedContent" value="/**&#10; * Authentication screen for login and registration&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun AuthScreen(&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    onLoginSuccess: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var isLoginMode by remember { mutableStateOf(true) }&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var username by remember { mutableStateOf(&quot;&quot;) }&#10;    var confirmPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;    var confirmPasswordVisible by remember { mutableStateOf(false) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var successMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header with back button&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = onNavigateBack) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        // Title&#10;        Text(&#10;            text = if (isLoginMode) &quot;Login&quot; else &quot;Register&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        // Username field (only for registration)&#10;        if (!isLoginMode) {&#10;            OutlinedTextField(&#10;                value = username,&#10;                onValueChange = { username = it },&#10;                label = { Text(&quot;Username&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;&#10;        // Email field&#10;        OutlinedTextField(&#10;            value = email,&#10;            onValueChange = { email = it },&#10;            label = { Text(&quot;Email&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true,&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),&#10;            enabled = !isLoading&#10;        )&#10;&#10;        // Password field&#10;        OutlinedTextField(&#10;            value = password,&#10;            onValueChange = { password = it },&#10;            label = { Text(&quot;Password&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true,&#10;            visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;            trailingIcon = {&#10;                IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                    Icon(&#10;                        imageVector = if (passwordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                        contentDescription = if (passwordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                    )&#10;                }&#10;            },&#10;            enabled = !isLoading&#10;        )&#10;&#10;        // Confirm password field (only for registration)&#10;        if (!isLoginMode) {&#10;            OutlinedTextField(&#10;                value = confirmPassword,&#10;                onValueChange = { confirmPassword = it },&#10;                label = { Text(&quot;Confirm Password&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                visualTransformation = if (confirmPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;                trailingIcon = {&#10;                    IconButton(onClick = { confirmPasswordVisible = !confirmPasswordVisible }) {&#10;                        Icon(&#10;                            imageVector = if (confirmPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                            contentDescription = if (confirmPasswordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                        )&#10;                    }&#10;                },&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;&#10;        // Error message&#10;        errorMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = message,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Success message&#10;        successMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = message,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Submit button&#10;        Button(&#10;            onClick = {&#10;                errorMessage = null&#10;                successMessage = null&#10;&#10;                // Validation&#10;                if (email.isBlank() || password.isBlank()) {&#10;                    errorMessage = &quot;Please fill in all fields&quot;&#10;                    return@Button&#10;                }&#10;&#10;                if (!isLoginMode) {&#10;                    if (username.isBlank()) {&#10;                        errorMessage = &quot;Please enter a username&quot;&#10;                        return@Button&#10;                    }&#10;                    if (password != confirmPassword) {&#10;                        errorMessage = &quot;Passwords do not match&quot;&#10;                        return@Button&#10;                    }&#10;                    if (password.length &lt; 6) {&#10;                        errorMessage = &quot;Password must be at least 6 characters&quot;&#10;                        return@Button&#10;                    }&#10;                }&#10;&#10;                isLoading = true&#10;                scope.launch {&#10;                    try {&#10;                        if (isLoginMode) {&#10;                            val result = repository.login(email, password)&#10;                            if (result.isSuccess) {&#10;                                onLoginSuccess()&#10;                            } else {&#10;                                errorMessage = result.exceptionOrNull()?.message ?: &quot;Login failed&quot;&#10;                            }&#10;                        } else {&#10;                            val result = repository.register(username, email, password)&#10;                            if (result.isSuccess) {&#10;                                successMessage = &quot;Registration successful! Please login.&quot;&#10;                                isLoginMode = true&#10;                                // Clear fields&#10;                                username = &quot;&quot;&#10;                                password = &quot;&quot;&#10;                                confirmPassword = &quot;&quot;&#10;                            } else {&#10;                                errorMessage = result.exceptionOrNull()?.message ?: &quot;Registration failed&quot;&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        errorMessage = e.message ?: &quot;An error occurred&quot;&#10;                    } finally {&#10;                        isLoading = false&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            enabled = !isLoading&#10;        ) {&#10;            if (isLoading) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(20.dp),&#10;                    color = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            } else {&#10;                Text(if (isLoginMode) &quot;Login&quot; else &quot;Register&quot;)&#10;            }&#10;        }&#10;&#10;        // Toggle mode button&#10;        TextButton(&#10;            onClick = {&#10;                isLoginMode = !isLoginMode&#10;                errorMessage = null&#10;                successMessage = null&#10;            },&#10;            modifier = Modifier.align(Alignment.CenterHorizontally),&#10;            enabled = !isLoading&#10;        ) {&#10;            Text(&#10;                if (isLoginMode) &quot;Don't have an account? Register&quot; else &quot;Already have an account? Login&quot;&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AuthScreenPreview() {&#10;    SudokuTheme {&#10;        AuthScreen()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordScreen.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/theme/Theme.kt" />
              <option name="originalContent" value="package com.kooshmeen.sudoku.ui.theme&#10;&#10;import android.os.Build&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.ColorScheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;private val DarkColorScheme = darkColorScheme(&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80,&#10;    background = Color(0xFF121212),&#10;    surface = Color(0xFF1E1E1E),&#10;    onPrimary = Color.DarkGray,&#10;    onSecondary = Color.LightGray,&#10;    onTertiary = Color.LightGray,&#10;    onBackground = Color.LightGray,&#10;    onSurface = Color.LightGray,&#10;)&#10;private val DarkColorScheme = darkColorScheme(&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Purple40,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40,&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;)&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80,&#10;    background = Color(0xFF121212),&#10;    surface = Color(0xFF1E1E1E),&#10;    onPrimary = Color.DarkGray,&#10;    onSurface = Color.LightGray,&#10;)&#10;            val context = LocalContext.current&#10;    onBackground = Color.LightGray,&#10;private val LightColorScheme = lightColorScheme(&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;&#10;    // Animate the color scheme&#10;    val animatedColorScheme = animateColorScheme(targetColorScheme)&#10;&#10;    MaterialTheme(&#10;        colorScheme = animatedColorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}&#10;&#10;@Composable&#10;fun animateColorScheme(targetScheme: ColorScheme): ColorScheme {&#10;    val primary by animateColorAsState(&#10;        targetValue = targetScheme.primary,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val background by animateColorAsState(&#10;        targetValue = targetScheme.background,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val surface by animateColorAsState(&#10;        targetValue = targetScheme.surface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onBackground by animateColorAsState(&#10;        targetValue = targetScheme.onBackground,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onSurface by animateColorAsState(&#10;        targetValue = targetScheme.onSurface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;    return targetScheme.copy(&#10;        primary = primary,&#10;        background = background,&#10;        surface = surface,&#10;        onBackground = onBackground,&#10;        onSurface = onSurface&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.ui.theme&#10;&#10;import android.os.Build&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.ColorScheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.kooshmeen.sudoku.utils.ThemeManager&#10;&#10;@Composable&#10;fun SudokuTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    dynamicColor: Boolean = false,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val customTheme = ThemeManager.loadCustomTheme(context)&#10;&#10;    val targetColorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;        darkTheme -&gt; darkColorScheme(&#10;            primary = customTheme.darkPrimary,&#10;            secondary = customTheme.darkSecondary,&#10;            tertiary = customTheme.darkTertiary,&#10;            background = customTheme.darkBackground,&#10;            surface = customTheme.darkSurface,&#10;            onPrimary = customTheme.darkOnPrimary,&#10;            onSecondary = customTheme.darkOnSecondary,&#10;            onTertiary = customTheme.darkOnTertiary,&#10;            onBackground = customTheme.darkOnBackground,&#10;            onSurface = customTheme.darkOnSurface&#10;        )&#10;        else -&gt; lightColorScheme(&#10;            primary = customTheme.lightPrimary,&#10;            secondary = customTheme.lightSecondary,&#10;            tertiary = customTheme.lightTertiary,&#10;            background = customTheme.lightBackground,&#10;            surface = customTheme.lightSurface,&#10;            onPrimary = customTheme.lightOnPrimary,&#10;            onSecondary = customTheme.lightOnSecondary,&#10;            onTertiary = customTheme.lightOnTertiary,&#10;            onBackground = customTheme.lightOnBackground,&#10;            onSurface = customTheme.lightOnSurface&#10;        )&#10;    }&#10;&#10;    // Animate the color scheme&#10;    val animatedColorScheme = animateColorScheme(targetColorScheme)&#10;&#10;    MaterialTheme(&#10;        colorScheme = animatedColorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}&#10;&#10;@Composable&#10;fun animateColorScheme(targetScheme: ColorScheme): ColorScheme {&#10;    val primary by animateColorAsState(&#10;        targetValue = targetScheme.primary,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val background by animateColorAsState(&#10;        targetValue = targetScheme.background,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val surface by animateColorAsState(&#10;        targetValue = targetScheme.surface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onBackground by animateColorAsState(&#10;        targetValue = targetScheme.onBackground,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onSurface by animateColorAsState(&#10;        targetValue = targetScheme.onSurface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;    return targetScheme.copy(&#10;        primary = primary,&#10;        background = background,&#10;        surface = surface,&#10;        onBackground = onBackground,&#10;        onSurface = onSurface&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt" />
              <option name="updatedContent" value="/**&#10; * Handles persistence of game state using SharedPreferences&#10; * Serializes game state to JSON for storage&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import com.kooshmeen.sudoku.data.*&#10;&#10;object GameStatePersistence {&#10;    private const val PREFS_NAME = &quot;SudokuGameState&quot;&#10;    private const val KEY_SAVED_GAME = &quot;saved_game&quot;&#10;    &#10;    fun saveGameState(context: Context, gameState: GameState) {&#10;        // Only save if game is active and not completed&#10;        if (!gameState.isGameActive || gameState.isGameCompleted) return&#10;        &#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = serializeGameState(gameState)&#10;        prefs.edit().putString(KEY_SAVED_GAME, json).apply()&#10;    }&#10;    &#10;    fun loadGameState(context: Context): SavedGameState? {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = prefs.getString(KEY_SAVED_GAME, null) ?: return null&#10;        return deserializeGameState(json)&#10;    }&#10;    &#10;    fun clearSavedGame(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit().remove(KEY_SAVED_GAME).apply()&#10;    }&#10;    &#10;    private fun serializeGameState(gameState: GameState): String {&#10;        val jsonObject = JSONObject().apply {&#10;            put(&quot;difficulty&quot;, gameState.difficulty)&#10;            put(&quot;elapsedTime&quot;, gameState.elapsedTimeSeconds)&#10;            put(&quot;mistakesCount&quot;, gameState.mistakesCount)&#10;            put(&quot;grid&quot;, serializeGrid(gameState.grid))&#10;            put(&quot;solutionGrid&quot;, serializeSolutionGrid(gameState.solutionGrid))&#10;        }&#10;        return jsonObject.toString()&#10;    }&#10;    &#10;    private fun serializeGrid(grid: Array&lt;Array&lt;SudokuCell&gt;&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            grid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { cell -&gt;&#10;                        val cellObj = JSONObject().apply {&#10;                            put(&quot;value&quot;, cell.value)&#10;                            put(&quot;notes&quot;, JSONArray(cell.notes.toList()))&#10;                            put(&quot;isOriginal&quot;, cell.isOriginal)&#10;                            put(&quot;hasError&quot;, cell.hasError)&#10;                        }&#10;                        put(cellObj)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun serializeSolutionGrid(solutionGrid: Array&lt;IntArray&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            solutionGrid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { value -&gt;&#10;                        put(value)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun deserializeGameState(json: String): SavedGameState? {&#10;        return try {&#10;            val jsonObject = JSONObject(json)&#10;            &#10;            val gridArray = jsonObject.getJSONArray(&quot;grid&quot;)&#10;            val grid = mutableListOf&lt;List&lt;SavedCellState&gt;&gt;()&#10;            &#10;            for (i in 0 until gridArray.length()) {&#10;                val rowArray = gridArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;SavedCellState&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    val cellObj = rowArray.getJSONObject(j)&#10;                    val notesArray = cellObj.getJSONArray(&quot;notes&quot;)&#10;                    val notes = mutableListOf&lt;Int&gt;()&#10;                    &#10;                    for (k in 0 until notesArray.length()) {&#10;                        notes.add(notesArray.getInt(k))&#10;                    }&#10;                    &#10;                    row.add(SavedCellState(&#10;                        value = cellObj.getInt(&quot;value&quot;),&#10;                        notes = notes,&#10;                        isOriginal = cellObj.getBoolean(&quot;isOriginal&quot;),&#10;                        hasError = cellObj.getBoolean(&quot;hasError&quot;)&#10;                    ))&#10;                }&#10;                grid.add(row)&#10;            }&#10;            &#10;            val solutionArray = jsonObject.getJSONArray(&quot;solutionGrid&quot;)&#10;            val solutionGrid = mutableListOf&lt;List&lt;Int&gt;&gt;()&#10;            &#10;            for (i in 0 until solutionArray.length()) {&#10;                val rowArray = solutionArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;Int&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    row.add(rowArray.getInt(j))&#10;                }&#10;                solutionGrid.add(row)&#10;            }&#10;            &#10;            SavedGameState(&#10;                grid = grid,&#10;                difficulty = jsonObject.getString(&quot;difficulty&quot;),&#10;                elapsedTimeSeconds = jsonObject.getInt(&quot;elapsedTime&quot;),&#10;                mistakesCount = jsonObject.getInt(&quot;mistakesCount&quot;),&#10;                solutionGrid = solutionGrid&#10;            )&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/StatisticsManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/StatisticsManager.kt" />
              <option name="originalContent" value="/**&#10; * Comprehensive statistics manager for tracking player performance&#10; * Handles local storage of game statistics including completion counts, scores, and time-based tracking&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;object StatisticsManager {&#10;    private const val PREFS_NAME = &quot;SudokuStatistics&quot;&#10;&#10;    // Keys for different statistics&#10;    private const val KEY_GAMES_COMPLETED = &quot;games_completed_&quot;&#10;    private const val KEY_GAMES_PERFECT = &quot;games_perfect_&quot; // without mistakes&#10;    private const val KEY_TOTAL_SCORE = &quot;total_score_&quot;&#10;    private const val KEY_DAILY_SCORE = &quot;daily_score_&quot;&#10;    private const val KEY_WEEKLY_SCORE = &quot;weekly_score_&quot;&#10;    private const val KEY_MONTHLY_SCORE = &quot;monthly_score_&quot;&#10;    private const val KEY_LAST_PLAY_DATE = &quot;last_play_date&quot;&#10;    private const val KEY_CURRENT_STREAK = &quot;current_streak&quot;&#10;    private const val KEY_LONGEST_STREAK = &quot;longest_streak&quot;&#10;    private const val KEY_TOTAL_TIME_PLAYED = &quot;total_time_played&quot;&#10;    private const val KEY_AVERAGE_SCORE = &quot;average_score_&quot;&#10;&#10;    data class PlayerStats(&#10;        val easyGamesCompleted: Int = 0,&#10;        val mediumGamesCompleted: Int = 0,&#10;        val hardGamesCompleted: Int = 0,&#10;        val easyGamesPerfect: Int = 0,&#10;        val mediumGamesPerfect: Int = 0,&#10;        val hardGamesPerfect: Int = 0,&#10;        val easyTotalScore: Int = 0,&#10;        val mediumTotalScore: Int = 0,&#10;        val hardTotalScore: Int = 0,&#10;        val dailyScore: Int = 0,&#10;        val weeklyScore: Int = 0,&#10;        val monthlyScore: Int = 0,&#10;        val currentStreak: Int = 0,&#10;        val longestStreak: Int = 0,&#10;        val totalTimePlayed: Long = 0, // in seconds&#10;        val easyAverageScore: Float = 0f,&#10;        val mediumAverageScore: Float = 0f,&#10;        val hardAverageScore: Float = 0f&#10;    )&#10;&#10;    /**&#10;     * Record a completed game and update all relevant statistics&#10;     */&#10;    fun recordCompletedGame(&#10;        context: Context,&#10;        difficulty: String,&#10;        score: Int,&#10;        timeSeconds: Int,&#10;        mistakes: Int&#10;    ) {&#10;            val currentCompleted = getInt(completedKey, 0)&#10;        val difficultyKey = difficulty.lowercase()&#10;            val currentCompleted = getInt(completedKey, 0)&#10;        prefs.edit {&#10;            val currentCompleted = getInt(completedKey, 0)&#10;            val completedKey = KEY_GAMES_COMPLETED + difficultyKey&#10;                val currentPerfect = getInt(perfectKey, 0)&#10;            putInt(completedKey, currentCompleted + 1)&#10;                val currentPerfect = getInt(perfectKey, 0)&#10;            // Update perfect games count (no mistakes)&#10;                val currentPerfect = getInt(perfectKey, 0)&#10;                val perfectKey = KEY_GAMES_PERFECT + difficultyKey&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;                putInt(perfectKey, currentPerfect + 1)&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;            val totalScoreKey = KEY_TOTAL_SCORE + difficultyKey&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;            putInt(totalScoreKey, currentTotalScore + score)&#10;&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val averageKey = KEY_AVERAGE_SCORE + difficultyKey&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            // Update playing streak&#10;            updatePlayingStreak(this, context)&#10;&#10;            // Update total time played&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            putLong(KEY_TOTAL_TIME_PLAYED, currentTotalTime + timeSeconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update daily, weekly, and monthly scores&#10;     */&#10;    private fun updateTimeBasedScores(editor: SharedPreferences.Editor, score: Int, context: Context) {&#10;        val currentDate = Calendar.getInstance()&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        // Get current date strings&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(currentDate.time)&#10;        val thisWeek = &quot;${currentDate.get(Calendar.YEAR)}-W${currentDate.get(Calendar.WEEK_OF_YEAR)}&quot;&#10;        val thisMonth = SimpleDateFormat(&quot;yyyy-MM&quot;, Locale.getDefault()).format(currentDate.time)&#10;&#10;        // Check if we need to reset daily score&#10;        val lastDailyUpdate = prefs.getString(&quot;last_daily_update&quot;, &quot;&quot;)&#10;        if (lastDailyUpdate != today) {&#10;            editor.putInt(KEY_DAILY_SCORE, score)&#10;            editor.putString(&quot;last_daily_update&quot;, today)&#10;        } else {&#10;            val currentDaily = prefs.getInt(KEY_DAILY_SCORE, 0)&#10;            editor.putInt(KEY_DAILY_SCORE, currentDaily + score)&#10;        }&#10;&#10;        // Check if we need to reset weekly score&#10;        val lastWeeklyUpdate = prefs.getString(&quot;last_weekly_update&quot;, &quot;&quot;)&#10;        if (lastWeeklyUpdate != thisWeek) {&#10;            editor.putInt(KEY_WEEKLY_SCORE, score)&#10;            editor.putString(&quot;last_weekly_update&quot;, thisWeek)&#10;        } else {&#10;            val currentWeekly = prefs.getInt(KEY_WEEKLY_SCORE, 0)&#10;            editor.putInt(KEY_WEEKLY_SCORE, currentWeekly + score)&#10;        }&#10;&#10;        // Check if we need to reset monthly score&#10;        val lastMonthlyUpdate = prefs.getString(&quot;last_monthly_update&quot;, &quot;&quot;)&#10;        if (lastMonthlyUpdate != thisMonth) {&#10;            editor.putInt(KEY_MONTHLY_SCORE, score)&#10;            editor.putString(&quot;last_monthly_update&quot;, thisMonth)&#10;        } else {&#10;            val currentMonthly = prefs.getInt(KEY_MONTHLY_SCORE, 0)&#10;            editor.putInt(KEY_MONTHLY_SCORE, currentMonthly + score)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update playing streak (consecutive days played)&#10;     */&#10;    private fun updatePlayingStreak(editor: SharedPreferences.Editor, context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;        val lastPlayDate = prefs.getString(KEY_LAST_PLAY_DATE, &quot;&quot;)&#10;&#10;        val currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0)&#10;        val longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0)&#10;&#10;        if (lastPlayDate == today) {&#10;            // Already played today, don't update streak&#10;            return&#10;        }&#10;&#10;        val yesterday = Calendar.getInstance().apply {&#10;            add(Calendar.DAY_OF_YEAR, -1)&#10;        }&#10;        val yesterdayStr = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(yesterday.time)&#10;&#10;        val newStreak = if (lastPlayDate == yesterdayStr) {&#10;            // Consecutive day&#10;            currentStreak + 1&#10;        } else {&#10;            // Streak broken or first time playing&#10;            1&#10;        }&#10;&#10;        editor.putString(KEY_LAST_PLAY_DATE, today)&#10;        editor.putInt(KEY_CURRENT_STREAK, newStreak)&#10;&#10;        if (newStreak &gt; longestStreak) {&#10;            editor.putInt(KEY_LONGEST_STREAK, newStreak)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all player statistics&#10;     */&#10;    fun getPlayerStats(context: Context): PlayerStats {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        return PlayerStats(&#10;            easyGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;easy&quot;, 0),&#10;            mediumGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;medium&quot;, 0),&#10;            hardGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;hard&quot;, 0),&#10;            easyGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;easy&quot;, 0),&#10;            mediumGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;medium&quot;, 0),&#10;            hardGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;hard&quot;, 0),&#10;            easyTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;easy&quot;, 0),&#10;            mediumTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;medium&quot;, 0),&#10;            hardTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;hard&quot;, 0),&#10;            dailyScore = prefs.getInt(KEY_DAILY_SCORE, 0),&#10;            weeklyScore = prefs.getInt(KEY_WEEKLY_SCORE, 0),&#10;            monthlyScore = prefs.getInt(KEY_MONTHLY_SCORE, 0),&#10;            currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0),&#10;            longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0),&#10;            totalTimePlayed = prefs.getLong(KEY_TOTAL_TIME_PLAYED, 0),&#10;            easyAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;easy&quot;, 0f),&#10;            mediumAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;medium&quot;, 0f),&#10;            hardAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;hard&quot;, 0f)&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Clear all statistics&#10;     */&#10;    fun clearAllStats(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { clear() }&#10;    }&#10;&#10;    /**&#10;     * Format time in a human-readable way&#10;     */&#10;    fun formatPlayTime(totalSeconds: Long): String {&#10;        val hours = totalSeconds / 3600&#10;        val minutes = (totalSeconds % 3600) / 60&#10;        val seconds = totalSeconds % 60&#10;&#10;        return when {&#10;            hours &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dh %dm %ds&quot;, hours, minutes, seconds)&#10;            minutes &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dm %ds&quot;, minutes, seconds)&#10;            else -&gt; String.format(Locale.getDefault(), &quot;%ds&quot;, seconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate completion rate for a difficulty&#10;     */&#10;    fun getCompletionRate(completed: Int, perfect: Int): Float {&#10;        return if (completed &gt; 0) (perfect.toFloat() / completed.toFloat()) * 100 else 0f&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Comprehensive statistics manager for tracking player performance&#10; * Handles local storage of game statistics including completion counts, scores, and time-based tracking&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;object StatisticsManager {&#10;    private const val PREFS_NAME = &quot;SudokuStatistics&quot;&#10;&#10;    // Keys for different statistics&#10;    private const val KEY_GAMES_COMPLETED = &quot;games_completed_&quot;&#10;    private const val KEY_GAMES_PERFECT = &quot;games_perfect_&quot; // without mistakes&#10;    private const val KEY_TOTAL_SCORE = &quot;total_score_&quot;&#10;    private const val KEY_DAILY_SCORE = &quot;daily_score_&quot;&#10;    private const val KEY_WEEKLY_SCORE = &quot;weekly_score_&quot;&#10;    private const val KEY_MONTHLY_SCORE = &quot;monthly_score_&quot;&#10;    private const val KEY_LAST_PLAY_DATE = &quot;last_play_date&quot;&#10;    private const val KEY_CURRENT_STREAK = &quot;current_streak&quot;&#10;    private const val KEY_LONGEST_STREAK = &quot;longest_streak&quot;&#10;    private const val KEY_TOTAL_TIME_PLAYED = &quot;total_time_played&quot;&#10;    private const val KEY_AVERAGE_SCORE = &quot;average_score_&quot;&#10;&#10;    data class PlayerStats(&#10;        val easyGamesCompleted: Int = 0,&#10;        val mediumGamesCompleted: Int = 0,&#10;        val hardGamesCompleted: Int = 0,&#10;        val easyGamesPerfect: Int = 0,&#10;        val mediumGamesPerfect: Int = 0,&#10;        val hardGamesPerfect: Int = 0,&#10;        val easyTotalScore: Int = 0,&#10;        val mediumTotalScore: Int = 0,&#10;        val hardTotalScore: Int = 0,&#10;        val dailyScore: Int = 0,&#10;        val weeklyScore: Int = 0,&#10;        val monthlyScore: Int = 0,&#10;        val currentStreak: Int = 0,&#10;        val longestStreak: Int = 0,&#10;        val totalTimePlayed: Long = 0, // in seconds&#10;        val easyAverageScore: Float = 0f,&#10;        val mediumAverageScore: Float = 0f,&#10;        val hardAverageScore: Float = 0f&#10;    )&#10;&#10;    /**&#10;     * Record a completed game and update all relevant statistics&#10;     */&#10;    fun recordCompletedGame(&#10;        context: Context,&#10;        difficulty: String,&#10;        score: Int,&#10;        timeSeconds: Int,&#10;        mistakes: Int&#10;    ) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val difficultyKey = difficulty.lowercase()&#10;&#10;        prefs.edit {&#10;            // Update game completion counts&#10;            val completedKey = KEY_GAMES_COMPLETED + difficultyKey&#10;            val currentCompleted = prefs.getInt(completedKey, 0)&#10;            putInt(completedKey, currentCompleted + 1)&#10;&#10;            // Update perfect games count (no mistakes)&#10;            if (mistakes == 0) {&#10;                val perfectKey = KEY_GAMES_PERFECT + difficultyKey&#10;                val currentPerfect = prefs.getInt(perfectKey, 0)&#10;                putInt(perfectKey, currentPerfect + 1)&#10;            }&#10;&#10;            // Update total scores&#10;            val totalScoreKey = KEY_TOTAL_SCORE + difficultyKey&#10;            val currentTotalScore = prefs.getInt(totalScoreKey, 0)&#10;            putInt(totalScoreKey, currentTotalScore + score)&#10;&#10;            // Update average score&#10;            val averageKey = KEY_AVERAGE_SCORE + difficultyKey&#10;            val newAverage = (currentTotalScore + score).toFloat() / (currentCompleted + 1)&#10;            putFloat(averageKey, newAverage)&#10;&#10;            // Update time-based scores&#10;            updateTimeBasedScores(this, score, context)&#10;&#10;            // Update playing streak&#10;            updatePlayingStreak(this, context)&#10;&#10;            // Update total time played&#10;            val currentTotalTime = prefs.getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            putLong(KEY_TOTAL_TIME_PLAYED, currentTotalTime + timeSeconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update daily, weekly, and monthly scores&#10;     */&#10;    private fun updateTimeBasedScores(editor: SharedPreferences.Editor, score: Int, context: Context) {&#10;        val currentDate = Calendar.getInstance()&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        // Get current date strings&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(currentDate.time)&#10;        val thisWeek = &quot;${currentDate.get(Calendar.YEAR)}-W${currentDate.get(Calendar.WEEK_OF_YEAR)}&quot;&#10;        val thisMonth = SimpleDateFormat(&quot;yyyy-MM&quot;, Locale.getDefault()).format(currentDate.time)&#10;&#10;        // Check if we need to reset daily score&#10;        val lastDailyUpdate = prefs.getString(&quot;last_daily_update&quot;, &quot;&quot;)&#10;        if (lastDailyUpdate != today) {&#10;            editor.putInt(KEY_DAILY_SCORE, score)&#10;            editor.putString(&quot;last_daily_update&quot;, today)&#10;        } else {&#10;            val currentDaily = prefs.getInt(KEY_DAILY_SCORE, 0)&#10;            editor.putInt(KEY_DAILY_SCORE, currentDaily + score)&#10;        }&#10;&#10;        // Check if we need to reset weekly score&#10;        val lastWeeklyUpdate = prefs.getString(&quot;last_weekly_update&quot;, &quot;&quot;)&#10;        if (lastWeeklyUpdate != thisWeek) {&#10;            editor.putInt(KEY_WEEKLY_SCORE, score)&#10;            editor.putString(&quot;last_weekly_update&quot;, thisWeek)&#10;        } else {&#10;            val currentWeekly = prefs.getInt(KEY_WEEKLY_SCORE, 0)&#10;            editor.putInt(KEY_WEEKLY_SCORE, currentWeekly + score)&#10;        }&#10;&#10;        // Check if we need to reset monthly score&#10;        val lastMonthlyUpdate = prefs.getString(&quot;last_monthly_update&quot;, &quot;&quot;)&#10;        if (lastMonthlyUpdate != thisMonth) {&#10;            editor.putInt(KEY_MONTHLY_SCORE, score)&#10;            editor.putString(&quot;last_monthly_update&quot;, thisMonth)&#10;        } else {&#10;            val currentMonthly = prefs.getInt(KEY_MONTHLY_SCORE, 0)&#10;            editor.putInt(KEY_MONTHLY_SCORE, currentMonthly + score)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update playing streak (consecutive days played)&#10;     */&#10;    private fun updatePlayingStreak(editor: SharedPreferences.Editor, context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;        val lastPlayDate = prefs.getString(KEY_LAST_PLAY_DATE, &quot;&quot;)&#10;&#10;        val currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0)&#10;        val longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0)&#10;&#10;        if (lastPlayDate == today) {&#10;            // Already played today, don't update streak&#10;            return&#10;        }&#10;&#10;        val yesterday = Calendar.getInstance().apply {&#10;            add(Calendar.DAY_OF_YEAR, -1)&#10;        }&#10;        val yesterdayStr = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(yesterday.time)&#10;&#10;        val newStreak = if (lastPlayDate == yesterdayStr) {&#10;            // Consecutive day&#10;            currentStreak + 1&#10;        } else {&#10;            // Streak broken or first time playing&#10;            1&#10;        }&#10;&#10;        editor.putString(KEY_LAST_PLAY_DATE, today)&#10;        editor.putInt(KEY_CURRENT_STREAK, newStreak)&#10;&#10;        if (newStreak &gt; longestStreak) {&#10;            editor.putInt(KEY_LONGEST_STREAK, newStreak)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all player statistics&#10;     */&#10;    fun getPlayerStats(context: Context): PlayerStats {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        return PlayerStats(&#10;            easyGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;easy&quot;, 0),&#10;            mediumGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;medium&quot;, 0),&#10;            hardGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;hard&quot;, 0),&#10;            easyGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;easy&quot;, 0),&#10;            mediumGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;medium&quot;, 0),&#10;            hardGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;hard&quot;, 0),&#10;            easyTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;easy&quot;, 0),&#10;            mediumTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;medium&quot;, 0),&#10;            hardTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;hard&quot;, 0),&#10;            dailyScore = prefs.getInt(KEY_DAILY_SCORE, 0),&#10;            weeklyScore = prefs.getInt(KEY_WEEKLY_SCORE, 0),&#10;            monthlyScore = prefs.getInt(KEY_MONTHLY_SCORE, 0),&#10;            currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0),&#10;            longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0),&#10;            totalTimePlayed = prefs.getLong(KEY_TOTAL_TIME_PLAYED, 0),&#10;            easyAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;easy&quot;, 0f),&#10;            mediumAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;medium&quot;, 0f),&#10;            hardAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;hard&quot;, 0f)&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Clear all statistics&#10;     */&#10;    fun clearAllStats(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { clear() }&#10;    }&#10;&#10;    /**&#10;     * Format time in a human-readable way&#10;     */&#10;    fun formatPlayTime(totalSeconds: Long): String {&#10;        val hours = totalSeconds / 3600&#10;        val minutes = (totalSeconds % 3600) / 60&#10;        val seconds = totalSeconds % 60&#10;&#10;        return when {&#10;            hours &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dh %dm %ds&quot;, hours, minutes, seconds)&#10;            minutes &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dm %ds&quot;, minutes, seconds)&#10;            else -&gt; String.format(Locale.getDefault(), &quot;%ds&quot;, seconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate completion rate for a difficulty&#10;     */&#10;    fun getCompletionRate(completed: Int, perfect: Int): Float {&#10;        return if (completed &gt; 0) (perfect.toFloat() / completed.toFloat()) * 100 else 0f&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/ThemeManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/ThemeManager.kt" />
              <option name="updatedContent" value="/**&#10; * Theme manager for handling custom color schemes and theme persistence&#10; * Includes color contrast validation to prevent UI lockout scenarios&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.luminance&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.core.content.edit&#10;import com.kooshmeen.sudoku.ui.theme.DefaultColors&#10;import kotlin.math.abs&#10;import kotlin.math.max&#10;import kotlin.math.min&#10;&#10;object ThemeManager {&#10;    private const val PREFS_NAME = &quot;SudokuTheme&quot;&#10;    private const val MIN_CONTRAST_RATIO = 3.0f // Minimum contrast ratio for accessibility&#10;    &#10;    // Keys for storing theme colors&#10;    private const val KEY_LIGHT_PRIMARY = &quot;light_primary&quot;&#10;    private const val KEY_LIGHT_SECONDARY = &quot;light_secondary&quot;&#10;    private const val KEY_LIGHT_TERTIARY = &quot;light_tertiary&quot;&#10;    private const val KEY_LIGHT_BACKGROUND = &quot;light_background&quot;&#10;    private const val KEY_LIGHT_SURFACE = &quot;light_surface&quot;&#10;    private const val KEY_LIGHT_ON_PRIMARY = &quot;light_on_primary&quot;&#10;    private const val KEY_LIGHT_ON_SECONDARY = &quot;light_on_secondary&quot;&#10;    private const val KEY_LIGHT_ON_TERTIARY = &quot;light_on_tertiary&quot;&#10;    private const val KEY_LIGHT_ON_BACKGROUND = &quot;light_on_background&quot;&#10;    private const val KEY_LIGHT_ON_SURFACE = &quot;light_on_surface&quot;&#10;    &#10;    private const val KEY_DARK_PRIMARY = &quot;dark_primary&quot;&#10;    private const val KEY_DARK_SECONDARY = &quot;dark_secondary&quot;&#10;    private const val KEY_DARK_TERTIARY = &quot;dark_tertiary&quot;&#10;    private const val KEY_DARK_BACKGROUND = &quot;dark_background&quot;&#10;    private const val KEY_DARK_SURFACE = &quot;dark_surface&quot;&#10;    private const val KEY_DARK_ON_PRIMARY = &quot;dark_on_primary&quot;&#10;    private const val KEY_DARK_ON_SECONDARY = &quot;dark_on_secondary&quot;&#10;    private const val KEY_DARK_ON_TERTIARY = &quot;dark_on_tertiary&quot;&#10;    private const val KEY_DARK_ON_BACKGROUND = &quot;dark_on_background&quot;&#10;    private const val KEY_DARK_ON_SURFACE = &quot;dark_on_surface&quot;&#10;&#10;    data class CustomTheme(&#10;        // Light theme colors&#10;        val lightPrimary: Color,&#10;        val lightSecondary: Color,&#10;        val lightTertiary: Color,&#10;        val lightBackground: Color,&#10;        val lightSurface: Color,&#10;        val lightOnPrimary: Color,&#10;        val lightOnSecondary: Color,&#10;        val lightOnTertiary: Color,&#10;        val lightOnBackground: Color,&#10;        val lightOnSurface: Color,&#10;        &#10;        // Dark theme colors&#10;        val darkPrimary: Color,&#10;        val darkSecondary: Color,&#10;        val darkTertiary: Color,&#10;        val darkBackground: Color,&#10;        val darkSurface: Color,&#10;        val darkOnPrimary: Color,&#10;        val darkOnSecondary: Color,&#10;        val darkOnTertiary: Color,&#10;        val darkOnBackground: Color,&#10;        val darkOnSurface: Color&#10;    )&#10;&#10;    /**&#10;     * Calculate contrast ratio between two colors&#10;     */&#10;    private fun calculateContrastRatio(color1: Color, color2: Color): Float {&#10;        val luminance1 = color1.luminance()&#10;        val luminance2 = color2.luminance()&#10;        val lighter = max(luminance1, luminance2)&#10;        val darker = min(luminance1, luminance2)&#10;        return (lighter + 0.05f) / (darker + 0.05f)&#10;    }&#10;&#10;    /**&#10;     * Validate color combination to prevent UI lockout&#10;     */&#10;    fun validateColorCombination(backgroundColor: Color, onBackgroundColor: Color, surfaceColor: Color, onSurfaceColor: Color): ValidationResult {&#10;        val backgroundContrast = calculateContrastRatio(backgroundColor, onBackgroundColor)&#10;        val surfaceContrast = calculateContrastRatio(surfaceColor, onSurfaceColor)&#10;        &#10;        val issues = mutableListOf&lt;String&gt;()&#10;        &#10;        if (backgroundContrast &lt; MIN_CONTRAST_RATIO) {&#10;            issues.add(&quot;Background and text colors have insufficient contrast (${String.format(&quot;%.1f&quot;, backgroundContrast)}:1, minimum: ${MIN_CONTRAST_RATIO}:1)&quot;)&#10;        }&#10;        &#10;        if (surfaceContrast &lt; MIN_CONTRAST_RATIO) {&#10;            issues.add(&quot;Surface and text colors have insufficient contrast (${String.format(&quot;%.1f&quot;, surfaceContrast)}:1, minimum: ${MIN_CONTRAST_RATIO}:1)&quot;)&#10;        }&#10;        &#10;        // Additional check for very similar colors&#10;        val backgroundSimilarity = abs(backgroundColor.luminance() - onBackgroundColor.luminance())&#10;        if (backgroundSimilarity &lt; 0.1f) {&#10;            issues.add(&quot;Background and text colors are too similar&quot;)&#10;        }&#10;&#10;        return ValidationResult(&#10;            isValid = issues.isEmpty(),&#10;            issues = issues&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Auto-adjust colors to ensure accessibility&#10;     */&#10;    fun ensureAccessibleColors(backgroundColor: Color, textColor: Color): Pair&lt;Color, Color&gt; {&#10;        val contrast = calculateContrastRatio(backgroundColor, textColor)&#10;        &#10;        if (contrast &gt;= MIN_CONTRAST_RATIO) {&#10;            return Pair(backgroundColor, textColor)&#10;        }&#10;        &#10;        // Adjust text color to ensure sufficient contrast&#10;        val backgroundLuminance = backgroundColor.luminance()&#10;        val adjustedTextColor = if (backgroundLuminance &gt; 0.5f) {&#10;            Color.Black // Use black text on light backgrounds&#10;        } else {&#10;            Color.White // Use white text on dark backgrounds&#10;        }&#10;        &#10;        return Pair(backgroundColor, adjustedTextColor)&#10;    }&#10;&#10;    /**&#10;     * Save custom theme to SharedPreferences&#10;     */&#10;    fun saveCustomTheme(context: Context, theme: CustomTheme) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            // Light theme colors&#10;            putInt(KEY_LIGHT_PRIMARY, theme.lightPrimary.toArgb())&#10;            putInt(KEY_LIGHT_SECONDARY, theme.lightSecondary.toArgb())&#10;            putInt(KEY_LIGHT_TERTIARY, theme.lightTertiary.toArgb())&#10;            putInt(KEY_LIGHT_BACKGROUND, theme.lightBackground.toArgb())&#10;            putInt(KEY_LIGHT_SURFACE, theme.lightSurface.toArgb())&#10;            putInt(KEY_LIGHT_ON_PRIMARY, theme.lightOnPrimary.toArgb())&#10;            putInt(KEY_LIGHT_ON_SECONDARY, theme.lightOnSecondary.toArgb())&#10;            putInt(KEY_LIGHT_ON_TERTIARY, theme.lightOnTertiary.toArgb())&#10;            putInt(KEY_LIGHT_ON_BACKGROUND, theme.lightOnBackground.toArgb())&#10;            putInt(KEY_LIGHT_ON_SURFACE, theme.lightOnSurface.toArgb())&#10;            &#10;            // Dark theme colors&#10;            putInt(KEY_DARK_PRIMARY, theme.darkPrimary.toArgb())&#10;            putInt(KEY_DARK_SECONDARY, theme.darkSecondary.toArgb())&#10;            putInt(KEY_DARK_TERTIARY, theme.darkTertiary.toArgb())&#10;            putInt(KEY_DARK_BACKGROUND, theme.darkBackground.toArgb())&#10;            putInt(KEY_DARK_SURFACE, theme.darkSurface.toArgb())&#10;            putInt(KEY_DARK_ON_PRIMARY, theme.darkOnPrimary.toArgb())&#10;            putInt(KEY_DARK_ON_SECONDARY, theme.darkOnSecondary.toArgb())&#10;            putInt(KEY_DARK_ON_TERTIARY, theme.darkOnTertiary.toArgb())&#10;            putInt(KEY_DARK_ON_BACKGROUND, theme.darkOnBackground.toArgb())&#10;            putInt(KEY_DARK_ON_SURFACE, theme.darkOnSurface.toArgb())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load custom theme from SharedPreferences&#10;     */&#10;    fun loadCustomTheme(context: Context): CustomTheme {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        &#10;        return CustomTheme(&#10;            // Light theme colors&#10;            lightPrimary = Color(prefs.getInt(KEY_LIGHT_PRIMARY, DefaultColors.LightPrimary.toArgb())),&#10;            lightSecondary = Color(prefs.getInt(KEY_LIGHT_SECONDARY, DefaultColors.LightSecondary.toArgb())),&#10;            lightTertiary = Color(prefs.getInt(KEY_LIGHT_TERTIARY, DefaultColors.LightTertiary.toArgb())),&#10;            lightBackground = Color(prefs.getInt(KEY_LIGHT_BACKGROUND, DefaultColors.LightBackground.toArgb())),&#10;            lightSurface = Color(prefs.getInt(KEY_LIGHT_SURFACE, DefaultColors.LightSurface.toArgb())),&#10;            lightOnPrimary = Color(prefs.getInt(KEY_LIGHT_ON_PRIMARY, DefaultColors.LightOnPrimary.toArgb())),&#10;            lightOnSecondary = Color(prefs.getInt(KEY_LIGHT_ON_SECONDARY, DefaultColors.LightOnSecondary.toArgb())),&#10;            lightOnTertiary = Color(prefs.getInt(KEY_LIGHT_ON_TERTIARY, DefaultColors.LightOnTertiary.toArgb())),&#10;            lightOnBackground = Color(prefs.getInt(KEY_LIGHT_ON_BACKGROUND, DefaultColors.LightOnBackground.toArgb())),&#10;            lightOnSurface = Color(prefs.getInt(KEY_LIGHT_ON_SURFACE, DefaultColors.LightOnSurface.toArgb())),&#10;            &#10;            // Dark theme colors&#10;            darkPrimary = Color(prefs.getInt(KEY_DARK_PRIMARY, DefaultColors.DarkPrimary.toArgb())),&#10;            darkSecondary = Color(prefs.getInt(KEY_DARK_SECONDARY, DefaultColors.DarkSecondary.toArgb())),&#10;            darkTertiary = Color(prefs.getInt(KEY_DARK_TERTIARY, DefaultColors.DarkTertiary.toArgb())),&#10;            darkBackground = Color(prefs.getInt(KEY_DARK_BACKGROUND, DefaultColors.DarkBackground.toArgb())),&#10;            darkSurface = Color(prefs.getInt(KEY_DARK_SURFACE, DefaultColors.DarkSurface.toArgb())),&#10;            darkOnPrimary = Color(prefs.getInt(KEY_DARK_ON_PRIMARY, DefaultColors.DarkOnPrimary.toArgb())),&#10;            darkOnSecondary = Color(prefs.getInt(KEY_DARK_ON_SECONDARY, DefaultColors.DarkOnSecondary.toArgb())),&#10;            darkOnTertiary = Color(prefs.getInt(KEY_DARK_ON_TERTIARY, DefaultColors.DarkOnTertiary.toArgb())),&#10;            darkOnBackground = Color(prefs.getInt(KEY_DARK_ON_BACKGROUND, DefaultColors.DarkOnBackground.toArgb())),&#10;            darkOnSurface = Color(prefs.getInt(KEY_DARK_ON_SURFACE, DefaultColors.DarkOnSurface.toArgb()))&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Reset theme to defaults&#10;     */&#10;    fun resetToDefaults(context: Context) {&#10;        val defaultTheme = CustomTheme(&#10;            lightPrimary = DefaultColors.LightPrimary,&#10;            lightSecondary = DefaultColors.LightSecondary,&#10;            lightTertiary = DefaultColors.LightTertiary,&#10;            lightBackground = DefaultColors.LightBackground,&#10;            lightSurface = DefaultColors.LightSurface,&#10;            lightOnPrimary = DefaultColors.LightOnPrimary,&#10;            lightOnSecondary = DefaultColors.LightOnSecondary,&#10;            lightOnTertiary = DefaultColors.LightOnTertiary,&#10;            lightOnBackground = DefaultColors.LightOnBackground,&#10;            lightOnSurface = DefaultColors.LightOnSurface,&#10;            &#10;            darkPrimary = DefaultColors.DarkPrimary,&#10;            darkSecondary = DefaultColors.DarkSecondary,&#10;            darkTertiary = DefaultColors.DarkTertiary,&#10;            darkBackground = DefaultColors.DarkBackground,&#10;            darkSurface = DefaultColors.DarkSurface,&#10;            darkOnPrimary = DefaultColors.DarkOnPrimary,&#10;            darkOnSecondary = DefaultColors.DarkOnSecondary,&#10;            darkOnTertiary = DefaultColors.DarkOnTertiary,&#10;            darkOnBackground = DefaultColors.DarkOnBackground,&#10;            darkOnSurface = DefaultColors.DarkOnSurface&#10;        )&#10;        saveCustomTheme(context, defaultTheme)&#10;    }&#10;&#10;    data class ValidationResult(&#10;        val isValid: Boolean,&#10;        val issues: List&lt;String&gt;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>