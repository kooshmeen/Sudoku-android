<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt" />
              <option name="originalContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.screens.AuthScreen&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.screens.RecordScreen&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onContinueGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onStartNewGame = { difficulty -&gt;&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onNavigateToRecords = {&#10;                                    NavController.navigate(&quot;record_screen&quot;)&#10;                                },&#10;                                onNavigateToAuth = {&#10;                                    NavController.navigate(&quot;auth_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;auth_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            AuthScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onLoginSuccess = {&#10;                                    NavController.navigate(&quot;main_menu&quot;) {&#10;                                        popUpTo(&quot;main_menu&quot;) { inclusive = true }&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;game_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;record_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            RecordScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Save game state when app goes to background&#10;        GameStateManager.saveCurrentGame(this)&#10;    }&#10;}" />
              <option name="updatedContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.screens.AuthScreen&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.LeaderboardScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.screens.RecordScreen&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onContinueGame = {&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onStartNewGame = { difficulty -&gt;&#10;                                    NavController.navigate(&quot;game_screen&quot;)&#10;                                },&#10;                                onNavigateToRecords = {&#10;                                    NavController.navigate(&quot;record_screen&quot;)&#10;                                },&#10;                                onNavigateToAuth = {&#10;                                    NavController.navigate(&quot;auth_screen&quot;)&#10;                                },&#10;                                onNavigateToLeaderboard = {&#10;                                    NavController.navigate(&quot;leaderboard_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;auth_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            AuthScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onLoginSuccess = {&#10;                                    NavController.navigate(&quot;main_menu&quot;) {&#10;                                        popUpTo(&quot;main_menu&quot;) { inclusive = true }&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;game_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;record_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            RecordScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;leaderboard_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            LeaderboardScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Save game state when app goes to background&#10;        GameStateManager.saveCurrentGame(this)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/api/SudokuApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/api/SudokuApiService.kt" />
              <option name="originalContent" value="package com.kooshmeen.sudoku.api&#10;&#10;import com.kooshmeen.sudoku.data.api.ApiResponse&#10;import com.kooshmeen.sudoku.data.api.GameSubmission&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.data.api.LoginRequest&#10;import com.kooshmeen.sudoku.data.api.LoginResponse&#10;import com.kooshmeen.sudoku.data.api.RegisterRequest&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;import retrofit2.http.POST&#10;import retrofit2.http.PUT&#10;import retrofit2.http.Path&#10;import retrofit2.http.Query&#10;&#10;interface SudokuApiService {&#10;    // Authentication&#10;    @POST(&quot;register&quot;)&#10;    suspend fun register(@Body request: RegisterRequest): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;login&quot;)&#10;    suspend fun login(@Body request: LoginRequest): Response&lt;LoginResponse&gt;&#10;&#10;    // Profile management&#10;    @PUT(&quot;profile&quot;)&#10;    suspend fun updateProfile(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body update: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @PUT(&quot;password&quot;)&#10;    suspend fun changePassword(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body request: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Game submission&#10;    @POST(&quot;submit-game&quot;)&#10;    suspend fun submitGame(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body gameData: GameSubmission&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Statistics&#10;    @GET(&quot;stats&quot;)&#10;    suspend fun getPlayerStats(@Header(&quot;Authorization&quot;) token: String): Response&lt;Any&gt;&#10;&#10;    @GET(&quot;medals&quot;)&#10;    suspend fun getPlayerMedals(@Header(&quot;Authorization&quot;) token: String): Response&lt;Any&gt;&#10;&#10;    // Leaderboards&#10;    @GET(&quot;leaderboard/global&quot;)&#10;    suspend fun getGlobalLeaderboard(&#10;        @Query(&quot;periodType&quot;) periodType: String = &quot;all&quot;,&#10;        @Query(&quot;limit&quot;) limit: Int = 10&#10;    ): Response&lt;Any&gt;&#10;&#10;    // Groups&#10;    @POST(&quot;groups&quot;)&#10;    suspend fun createGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body groupData: GroupData&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @GET(&quot;groups&quot;)&#10;    suspend fun getAllGroups(): Response&lt;Any&gt;&#10;&#10;    @GET(&quot;my-groups&quot;)&#10;    suspend fun getMyGroups(@Header(&quot;Authorization&quot;) token: String): Response&lt;Any&gt;&#10;&#10;    @GET(&quot;groups/{groupId}&quot;)&#10;    suspend fun getGroupDetails(@Path(&quot;groupId&quot;) groupId: Int): Response&lt;Any&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/join&quot;)&#10;    suspend fun joinGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Body password: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;}" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.api&#10;&#10;import com.kooshmeen.sudoku.data.api.ApiResponse&#10;import com.kooshmeen.sudoku.data.api.GameSubmission&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.data.api.LeaderboardResponse&#10;import com.kooshmeen.sudoku.data.api.LoginRequest&#10;import com.kooshmeen.sudoku.data.api.LoginResponse&#10;import com.kooshmeen.sudoku.data.api.RegisterRequest&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.DELETE&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;import retrofit2.http.POST&#10;import retrofit2.http.PUT&#10;import retrofit2.http.Path&#10;import retrofit2.http.Query&#10;&#10;interface SudokuApiService {&#10;    // Public routes (no authentication required)&#10;    @POST(&quot;register&quot;)&#10;    suspend fun register(@Body request: RegisterRequest): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;login&quot;)&#10;    suspend fun login(@Body request: LoginRequest): Response&lt;LoginResponse&gt;&#10;&#10;    @GET(&quot;groups&quot;)&#10;    suspend fun getAllGroups(): Response&lt;List&lt;GroupData&gt;&gt;&#10;&#10;    @GET(&quot;groups/search&quot;)&#10;    suspend fun searchGroups(@Query(&quot;q&quot;) query: String): Response&lt;List&lt;GroupData&gt;&gt;&#10;&#10;    @GET(&quot;leaderboard/global&quot;)&#10;    suspend fun getGlobalLeaderboard(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Specific leaderboard routes&#10;    @GET(&quot;leaderboard/global/all-time&quot;)&#10;    suspend fun getTop100GlobalAllTime(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/monthly&quot;)&#10;    suspend fun getTop100GlobalMonth(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/weekly&quot;)&#10;    suspend fun getTop100GlobalWeek(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/daily&quot;)&#10;    suspend fun getTop100GlobalDay(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Protected routes (authentication required)&#10;    @PUT(&quot;profile&quot;)&#10;    suspend fun updateProfile(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body update: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @PUT(&quot;password&quot;)&#10;    suspend fun changePassword(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body request: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Game submission&#10;    @POST(&quot;submit-game&quot;)&#10;    suspend fun submitGame(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body gameData: GameSubmission&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Player statistics and medals&#10;    @GET(&quot;stats&quot;)&#10;    suspend fun getPlayerStats(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;Map&lt;String, Any&gt;&gt;&#10;&#10;    @GET(&quot;medals&quot;)&#10;    suspend fun getPlayerMedals(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt;&#10;&#10;    // Group management routes&#10;    @POST(&quot;groups&quot;)&#10;    suspend fun createGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body groupData: GroupData&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @GET(&quot;my-groups&quot;)&#10;    suspend fun getMyGroups(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;List&lt;GroupData&gt;&gt;&#10;&#10;    @GET(&quot;groups/{groupId}&quot;)&#10;    suspend fun getGroupDetails(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;GroupData&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/join&quot;)&#10;    suspend fun joinGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Body password: Map&lt;String, String&gt;? = null&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @DELETE(&quot;groups/{groupId}/leave&quot;)&#10;    suspend fun leaveGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @DELETE(&quot;groups/{groupId}&quot;)&#10;    suspend fun deleteGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Group leaderboard&#10;    @GET(&quot;groups/{groupId}/leaderboard&quot;)&#10;    suspend fun getGroupLeaderboard(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Group member management (leaders only)&#10;    @PUT(&quot;groups/{groupId}/members/{memberId}/role&quot;)&#10;    suspend fun setMemberRole(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Path(&quot;memberId&quot;) memberId: Int,&#10;        @Body roleData: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Admin routes (for awarding medals)&#10;    @POST(&quot;players/{playerId}/medals&quot;)&#10;    suspend fun awardMedal(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;playerId&quot;) playerId: Int,&#10;        @Body medalData: Map&lt;String, Any&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt" />
              <option name="originalContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class RemoveNotesBatch(&#10;        val cells: List&lt;Pair&lt;Int, Int&gt;&gt;,&#10;        val note: Int,&#10;        val oldNotes: List&lt;Set&lt;Int&gt;&gt;&#10;    ) : GameAction()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt" />
              <option name="updatedContent" value="/**&#10; * Data class representing the serializable game state&#10; * Used for saving/loading games from SharedPreferences&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;data class SavedGameState(&#10;    val grid: List&lt;List&lt;SavedCellState&gt;&gt;,&#10;    val difficulty: String,&#10;    val elapsedTimeSeconds: Int,&#10;    val mistakesCount: Int,&#10;    val solutionGrid: List&lt;List&lt;Int&gt;&gt;&#10;)&#10;&#10;data class SavedCellState(&#10;    val value: Int,&#10;    val notes: List&lt;Int&gt;,&#10;    val isOriginal: Boolean,&#10;    val hasError: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/api/ApiModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/api/ApiModels.kt" />
              <option name="originalContent" value="package com.kooshmeen.sudoku.data.api&#10;&#10;data class RegisterRequest(&#10;    val username: String,&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class LoginRequest(&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class LoginResponse(&#10;    val message: String,&#10;    val token: String,&#10;    val user: User&#10;)&#10;&#10;data class User(&#10;    val id: Int,&#10;    val username: String,&#10;    val email: String&#10;)&#10;&#10;data class GameSubmission(&#10;    val timeSeconds: Int,&#10;    val difficulty: String,&#10;    val numberOfMistakes: Int&#10;)&#10;&#10;data class LeaderboardEntry(&#10;    val player_id: Int,&#10;    val score: Int,&#10;    val period_type: String&#10;)&#10;&#10;data class GroupData(&#10;    val group_name: String,&#10;    val group_description: String?,&#10;    val group_password: String?&#10;)&#10;&#10;data class ApiResponse(&#10;    val message: String&#10;)" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.data.api&#10;&#10;data class RegisterRequest(&#10;    val username: String,&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class LoginRequest(&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class LoginResponse(&#10;    val message: String,&#10;    val token: String,&#10;    val user: User&#10;)&#10;&#10;data class User(&#10;    val id: Int,&#10;    val username: String,&#10;    val email: String&#10;)&#10;&#10;data class GameSubmission(&#10;    val timeSeconds: Int,&#10;    val difficulty: String,&#10;    val numberOfMistakes: Int&#10;)&#10;&#10;data class LeaderboardEntry(&#10;    val player_id: Int,&#10;    val username: String,&#10;    val score: Int,&#10;    val rank: Int? = null&#10;)&#10;&#10;data class LeaderboardResponse(&#10;    val leaderboard: List&lt;LeaderboardEntry&gt;,&#10;    val total: Int? = null&#10;)&#10;&#10;data class GroupData(&#10;    val group_name: String,&#10;    val group_description: String?,&#10;    val group_password: String?&#10;)&#10;&#10;data class ApiResponse(&#10;    val message: String&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/repository/SudokuRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/repository/SudokuRepository.kt" />
              <option name="originalContent" value="package com.kooshmeen.sudoku.repository&#10;&#10;import android.content.Context&#10;import com.kooshmeen.sudoku.api.ApiClient&#10;import com.kooshmeen.sudoku.data.api.*&#10;&#10;class SudokuRepository(private val context: Context) {&#10;    private val apiService = ApiClient.apiService&#10;    private val prefs = context.getSharedPreferences(&quot;sudoku_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    private var authToken: String?&#10;        get() = prefs.getString(&quot;auth_token&quot;, null)&#10;        set(value) = prefs.edit().putString(&quot;auth_token&quot;, value).apply()&#10;&#10;    private var currentUser: User?&#10;        get() {&#10;            val id = prefs.getInt(&quot;user_id&quot;, -1)&#10;            val username = prefs.getString(&quot;user_username&quot;, null)&#10;            val email = prefs.getString(&quot;user_email&quot;, null)&#10;            return if (id != -1 &amp;&amp; username != null &amp;&amp; email != null) {&#10;                User(id, username, email)&#10;            } else null&#10;        }&#10;        set(value) {&#10;            if (value != null) {&#10;                prefs.edit().apply {&#10;                    putInt(&quot;user_id&quot;, value.id)&#10;                    putString(&quot;user_username&quot;, value.username)&#10;                    putString(&quot;user_email&quot;, value.email)&#10;                    apply()&#10;                }&#10;            } else {&#10;                prefs.edit().apply {&#10;                    remove(&quot;user_id&quot;)&#10;                    remove(&quot;user_username&quot;)&#10;                    remove(&quot;user_email&quot;)&#10;                    apply()&#10;                }&#10;            }&#10;        }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;LoginResponse&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val loginResponse = response.body()!!&#10;                authToken = loginResponse.token&#10;                currentUser = loginResponse.user&#10;                Result.success(loginResponse)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registration failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun submitGame(difficulty: String, timeSeconds: Int, mistakes: Int): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.submitGame(&#10;                &quot;Bearer $token&quot;,&#10;                GameSubmission(timeSeconds, difficulty.lowercase(), mistakes)&#10;            )&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to submit game&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun isLoggedIn(): Boolean = authToken != null&#10;&#10;    fun fetchCurrentUser(): User? = currentUser&#10;&#10;    fun logout() {&#10;        authToken = null&#10;        currentUser = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.repository&#10;&#10;import android.content.Context&#10;import com.kooshmeen.sudoku.api.ApiClient&#10;import com.kooshmeen.sudoku.data.api.*&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;&#10;class SudokuRepository(private val context: Context) {&#10;    private val apiService = ApiClient.apiService&#10;    private val prefs = context.getSharedPreferences(&quot;sudoku_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    private var authToken: String?&#10;        get() = prefs.getString(&quot;auth_token&quot;, null)&#10;        set(value) = prefs.edit().putString(&quot;auth_token&quot;, value).apply()&#10;&#10;    private var currentUser: User?&#10;        get() {&#10;            val id = prefs.getInt(&quot;user_id&quot;, -1)&#10;            val username = prefs.getString(&quot;user_username&quot;, null)&#10;            val email = prefs.getString(&quot;user_email&quot;, null)&#10;            return if (id != -1 &amp;&amp; username != null &amp;&amp; email != null) {&#10;                User(id, username, email)&#10;            } else null&#10;        }&#10;        set(value) {&#10;            if (value != null) {&#10;                prefs.edit().apply {&#10;                    putInt(&quot;user_id&quot;, value.id)&#10;                    putString(&quot;user_username&quot;, value.username)&#10;                    putString(&quot;user_email&quot;, value.email)&#10;                    apply()&#10;                }&#10;            } else {&#10;                prefs.edit().apply {&#10;                    remove(&quot;user_id&quot;)&#10;                    remove(&quot;user_username&quot;)&#10;                    remove(&quot;user_email&quot;)&#10;                    apply()&#10;                }&#10;            }&#10;        }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;LoginResponse&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val loginResponse = response.body()!!&#10;                authToken = loginResponse.token&#10;                currentUser = loginResponse.user&#10;                Result.success(loginResponse)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registration failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun submitGame(difficulty: String, timeSeconds: Int, mistakes: Int): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.submitGame(&#10;                &quot;Bearer $token&quot;,&#10;                GameSubmission(timeSeconds, difficulty.lowercase(), mistakes)&#10;            )&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to submit game&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Leaderboard methods&#10;    suspend fun getLeaderboardTotal(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalAllTime()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardMonth(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalMonth()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load monthly leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardWeek(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalWeek()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load weekly leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardDay(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalDay()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load daily leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun isLoggedIn(): Boolean = authToken != null&#10;&#10;    fun fetchCurrentUser(): User? = currentUser&#10;&#10;    fun logout() {&#10;        authToken = null&#10;        currentUser = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/AuthScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/AuthScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="/**&#10; * Authentication screen for login and registration&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun AuthScreen(&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    onLoginSuccess: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var isLoginMode by remember { mutableStateOf(true) }&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var username by remember { mutableStateOf(&quot;&quot;) }&#10;    var confirmPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;    var confirmPasswordVisible by remember { mutableStateOf(false) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var successMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header with back button&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = onNavigateBack) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        // Title&#10;        Text(&#10;            text = if (isLoginMode) &quot;Login&quot; else &quot;Register&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        // Username field (only for registration)&#10;        if (!isLoginMode) {&#10;            OutlinedTextField(&#10;                value = username,&#10;                onValueChange = { username = it },&#10;                label = { Text(&quot;Username&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;&#10;        // Email field&#10;        OutlinedTextField(&#10;            value = email,&#10;            onValueChange = { email = it },&#10;            label = { Text(&quot;Email&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true,&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),&#10;            enabled = !isLoading&#10;        )&#10;&#10;        // Password field&#10;        OutlinedTextField(&#10;            value = password,&#10;            onValueChange = { password = it },&#10;            label = { Text(&quot;Password&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true,&#10;            visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;            trailingIcon = {&#10;                IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                    Icon(&#10;                        imageVector = if (passwordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                        contentDescription = if (passwordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                    )&#10;                }&#10;            },&#10;            enabled = !isLoading&#10;        )&#10;&#10;        // Confirm password field (only for registration)&#10;        if (!isLoginMode) {&#10;            OutlinedTextField(&#10;                value = confirmPassword,&#10;                onValueChange = { confirmPassword = it },&#10;                label = { Text(&quot;Confirm Password&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                visualTransformation = if (confirmPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;                trailingIcon = {&#10;                    IconButton(onClick = { confirmPasswordVisible = !confirmPasswordVisible }) {&#10;                        Icon(&#10;                            imageVector = if (confirmPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                            contentDescription = if (confirmPasswordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                        )&#10;                    }&#10;                },&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;&#10;        // Error message&#10;        errorMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = message,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Success message&#10;        successMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = message,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Submit button&#10;        Button(&#10;            onClick = {&#10;                errorMessage = null&#10;                successMessage = null&#10;&#10;                // Validation&#10;                if (email.isBlank() || password.isBlank()) {&#10;                    errorMessage = &quot;Please fill in all fields&quot;&#10;                    return@Button&#10;                }&#10;&#10;                if (!isLoginMode) {&#10;                    if (username.isBlank()) {&#10;                        errorMessage = &quot;Please enter a username&quot;&#10;                        return@Button&#10;                    }&#10;                    if (password != confirmPassword) {&#10;                        errorMessage = &quot;Passwords do not match&quot;&#10;                        return@Button&#10;                    }&#10;                    if (password.length &lt; 6) {&#10;                        errorMessage = &quot;Password must be at least 6 characters&quot;&#10;                        return@Button&#10;                    }&#10;                }&#10;&#10;                isLoading = true&#10;                scope.launch {&#10;                    try {&#10;                        if (isLoginMode) {&#10;                            val result = repository.login(email, password)&#10;                            if (result.isSuccess) {&#10;                                onLoginSuccess()&#10;                            } else {&#10;                                errorMessage = result.exceptionOrNull()?.message ?: &quot;Login failed&quot;&#10;                            }&#10;                        } else {&#10;                            val result = repository.register(username, email, password)&#10;                            if (result.isSuccess) {&#10;                                successMessage = &quot;Registration successful! Please login.&quot;&#10;                                isLoginMode = true&#10;                                // Clear fields&#10;                                username = &quot;&quot;&#10;                                password = &quot;&quot;&#10;                                confirmPassword = &quot;&quot;&#10;                            } else {&#10;                                errorMessage = result.exceptionOrNull()?.message ?: &quot;Registration failed&quot;&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        errorMessage = e.message ?: &quot;An error occurred&quot;&#10;                    } finally {&#10;                        isLoading = false&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            enabled = !isLoading&#10;        ) {&#10;            if (isLoading) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(20.dp),&#10;                    color = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            } else {&#10;                Text(if (isLoginMode) &quot;Login&quot; else &quot;Register&quot;)&#10;            }&#10;        }&#10;&#10;        // Toggle mode button&#10;        TextButton(&#10;            onClick = {&#10;                isLoginMode = !isLoginMode&#10;                errorMessage = null&#10;                successMessage = null&#10;            },&#10;            modifier = Modifier.align(Alignment.CenterHorizontally),&#10;            enabled = !isLoading&#10;        ) {&#10;            Text(&#10;                if (isLoginMode) &quot;Don't have an account? Register&quot; else &quot;Already have an account? Login&quot;&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AuthScreenPreview() {&#10;    SudokuTheme {&#10;        AuthScreen()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/LeaderboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/LeaderboardScreen.kt" />
              <option name="updatedContent" value="/**&#10; * Leaderboard screen displaying top 100 players across different time periods&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.data.api.LeaderboardEntry&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LeaderboardScreen(&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {}&#10;) {&#10;    var selectedTabIndex by remember { mutableIntStateOf(0) }&#10;    var leaderboardData by remember { mutableStateOf&lt;List&lt;LeaderboardEntry&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val tabTitles = listOf(&quot;All Time&quot;, &quot;This Month&quot;, &quot;This Week&quot;, &quot;Today&quot;)&#10;&#10;    // Load leaderboard data based on selected tab&#10;    LaunchedEffect(selectedTabIndex) {&#10;        isLoading = true&#10;        errorMessage = null&#10;&#10;        scope.launch {&#10;            val result = when (selectedTabIndex) {&#10;                0 -&gt; repository.getLeaderboardTotal()&#10;                1 -&gt; repository.getLeaderboardMonth()&#10;                2 -&gt; repository.getLeaderboardWeek()&#10;                3 -&gt; repository.getLeaderboardDay()&#10;                else -&gt; repository.getLeaderboardTotal()&#10;            }&#10;&#10;            result.fold(&#10;                onSuccess = { response -&gt;&#10;                    leaderboardData = response.leaderboard.mapIndexed { index, entry -&gt;&#10;                        entry.copy(rank = index + 1)&#10;                    }&#10;                    isLoading = false&#10;                },&#10;                onFailure = { exception -&gt;&#10;                    errorMessage = exception.message ?: &quot;Failed to load leaderboard&quot;&#10;                    isLoading = false&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        // Header with back button and title&#10;        TopAppBar(&#10;            title = {&#10;                Text(&#10;                    text = &quot;Leaderboard&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            },&#10;            navigationIcon = {&#10;                IconButton(onClick = onNavigateBack) {&#10;                    Icon(&#10;                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                        contentDescription = &quot;Back&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            },&#10;            colors = TopAppBarDefaults.topAppBarColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            )&#10;        )&#10;&#10;        // Tab Row&#10;        TabRow(&#10;            selectedTabIndex = selectedTabIndex,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            containerColor = MaterialTheme.colorScheme.surface,&#10;            contentColor = MaterialTheme.colorScheme.onSurface&#10;        ) {&#10;            tabTitles.forEachIndexed { index, title -&gt;&#10;                Tab(&#10;                    selected = selectedTabIndex == index,&#10;                    onClick = { selectedTabIndex = index },&#10;                    text = {&#10;                        Text(&#10;                            text = title,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = if (selectedTabIndex == index) FontWeight.Bold else FontWeight.Normal&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        // Content&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            when {&#10;                isLoading -&gt; {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.align(Alignment.Center),&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;                &#10;                errorMessage != null -&gt; {&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .align(Alignment.Center),&#10;                        colors = CardDefaults.cardColors(&#10;                            containerColor = MaterialTheme.colorScheme.errorContainer&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp)&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(16.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Error&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = MaterialTheme.colorScheme.onErrorContainer&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Text(&#10;                                text = errorMessage!!,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onErrorContainer,&#10;                                textAlign = TextAlign.Center&#10;                            )&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Button(&#10;                                onClick = {&#10;                                    selectedTabIndex = selectedTabIndex // Trigger reload&#10;                                },&#10;                                colors = ButtonDefaults.buttonColors(&#10;                                    containerColor = MaterialTheme.colorScheme.error&#10;                                )&#10;                            ) {&#10;                                Text(&quot;Retry&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                leaderboardData.isEmpty() -&gt; {&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .align(Alignment.Center),&#10;                        shape = RoundedCornerShape(12.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;No leaderboard data available&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            modifier = Modifier.padding(32.dp),&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        itemsIndexed(leaderboardData) { index, entry -&gt;&#10;                            LeaderboardItem(&#10;                                entry = entry,&#10;                                rank = index + 1&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LeaderboardItem(&#10;    entry: LeaderboardEntry,&#10;    rank: Int&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = when (rank) {&#10;                1 -&gt; Color(0xFFFFD700).copy(alpha = 0.2f) // Gold&#10;                2 -&gt; Color(0xFFC0C0C0).copy(alpha = 0.2f) // Silver&#10;                3 -&gt; Color(0xFFCD7F32).copy(alpha = 0.2f) // Bronze&#10;                else -&gt; MaterialTheme.colorScheme.surface&#10;            }&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            // Rank indicator&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(40.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        when (rank) {&#10;                            1 -&gt; Color(0xFFFFD700) // Gold&#10;                            2 -&gt; Color(0xFFC0C0C0) // Silver&#10;                            3 -&gt; Color(0xFFCD7F32) // Bronze&#10;                            else -&gt; MaterialTheme.colorScheme.primary&#10;                        }&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = rank.toString(),&#10;                    color = when (rank) {&#10;                        in 1..3 -&gt; Color.Black&#10;                        else -&gt; MaterialTheme.colorScheme.onPrimary&#10;                    },&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 16.sp&#10;                )&#10;            }&#10;&#10;            // Username&#10;            Text(&#10;                text = entry.username,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = if (rank &lt;= 3) FontWeight.Bold else FontWeight.Medium,&#10;                color = MaterialTheme.colorScheme.onSurface,&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(horizontal = 16.dp),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;&#10;            // Score&#10;            Text(&#10;                text = &quot;${entry.score}&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = when (rank) {&#10;                    1 -&gt; Color(0xFFB8860B) // Dark gold&#10;                    2 -&gt; Color(0xFF708090) // Dark silver&#10;                    3 -&gt; Color(0xFF8B4513) // Dark bronze&#10;                    else -&gt; MaterialTheme.colorScheme.primary&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun LeaderboardScreenPreview() {&#10;    SudokuTheme {&#10;        LeaderboardScreen()&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun LeaderboardItemPreview() {&#10;    SudokuTheme {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            LeaderboardItem(&#10;                entry = LeaderboardEntry(1, &quot;GoldPlayer&quot;, 15000),&#10;                rank = 1&#10;            )&#10;            LeaderboardItem(&#10;                entry = LeaderboardEntry(2, &quot;SilverChamp&quot;, 12500),&#10;                rank = 2&#10;            )&#10;            LeaderboardItem(&#10;                entry = LeaderboardEntry(3, &quot;BronzeMaster&quot;, 10000),&#10;                rank = 3&#10;            )&#10;            LeaderboardItem(&#10;                entry = LeaderboardEntry(4, &quot;RegularPlayer&quot;, 8500),&#10;                rank = 4&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/MainMenu.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/MainMenu.kt" />
              <option name="originalContent" value="/**&#10; * MainMenu.kt&#10; * This file defines the main menu screen for the Sudoku app.&#10; * It includes options to start a game, select difficulty, and toggle themes.&#10; * It also includes a settings button.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.rounded.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.R&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;&#10;@Composable&#10;fun MainMenu (&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onContinueGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onStartNewGame: (String) -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToRecords: () -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToLeaderboard: () -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    var isDifficultyDropdownOpen by remember { mutableStateOf(false) }&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;Easy&quot;) }&#10;    var isLoggedIn by remember { mutableStateOf(false) }&#10;&#10;    val context = LocalContext.current&#10;    val hasActiveGame = remember {&#10;        GameStateManager.hasActiveGame() || GameStateManager.hasSavedGame(context)&#10;    }&#10;    val repository = remember { SudokuRepository(context) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        isLoggedIn = repository.isLoggedIn()&#10;    }&#10;&#10;    Column (&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.End,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconToggleButton(&#10;                checked = isDarkTheme,&#10;                onCheckedChange = onThemeToggle,  // Use the callback&#10;                modifier = Modifier.size(24.dp)&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(&#10;                        id = if (!isDarkTheme) R.drawable.light_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                        else R.drawable.dark_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                    ),&#10;                    contentDescription = &quot;Toggle Dark/Light Mode&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            IconButton(onClick = { /* TODO: Open Settings */ }) {&#10;                Icon(&#10;                    imageVector = Icons.Rounded.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier&#10;                        .size(24.dp)&#10;                        .fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Title&#10;        Spacer(modifier = Modifier.height(64.dp))&#10;        Text(&#10;            text = &quot;Welcome to Sudoku!&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;        Spacer(modifier = Modifier.height(256.dp))&#10;&#10;        // Continue game button - only show if there's an active game&#10;        if (hasActiveGame) {&#10;            Button(&#10;                onClick = {&#10;                    if (!GameStateManager.hasActiveGame()) {&#10;                        GameStateManager.loadSavedGame(context)&#10;                    }&#10;                    GameStateManager.continueGame()&#10;                    onContinueGame()&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Continue Game&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // Start new game button&#10;        Button(&#10;            onClick = {&#10;                GameStateManager.startNewGame(selectedDifficulty, context)&#10;                onStartNewGame(selectedDifficulty)&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Text(&#10;                text = if (hasActiveGame) &quot;New Game&quot; else &quot;Start Game&quot;,&#10;                color = MaterialTheme.colorScheme.onPrimary,&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Select difficulty&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = { isDifficultyDropdownOpen = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Difficulty: $selectedDifficulty&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.arrow_drop_down),&#10;                        contentDescription = &quot;Dropdown arrow&quot;,&#10;                        modifier = Modifier&#10;                            .align(Alignment.CenterEnd)&#10;                            .size(24.dp),&#10;                        tint = MaterialTheme.colorScheme.onBackground&#10;                    )&#10;                }&#10;            }&#10;&#10;            DropdownMenu(&#10;                expanded = isDifficultyDropdownOpen,&#10;                onDismissRequest = { isDifficultyDropdownOpen = false }&#10;            ) {&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Easy&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Easy&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Medium&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Medium&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Hard&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Hard&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(128.dp))&#10;&#10;        // Row for Leaderboard button (left) and Records button (right)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;        ) {&#10;            Button(&#10;                onClick = { /* TODO: Navigate to Leaderboard */ },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Leaderboard&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp)) // Space between buttons&#10;            Button(&#10;                onClick = { onNavigateToRecords() },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Records&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainMenuPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        MainMenu(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * MainMenu.kt&#10; * This file defines the main menu screen for the Sudoku app.&#10; * It includes options to start a game, select difficulty, and toggle themes.&#10; * It also includes a settings button.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.rounded.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.R&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.data.api.User&#10;&#10;@Composable&#10;fun MainMenu (&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onContinueGame: () -&gt; Unit = { /* Default no-op */ },&#10;    onStartNewGame: (String) -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToRecords: () -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToLeaderboard: () -&gt; Unit = { /* Default no-op */ },&#10;    onNavigateToAuth: () -&gt; Unit = { /* Default no-op */ }&#10;) {&#10;    var isDifficultyDropdownOpen by remember { mutableStateOf(false) }&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;Easy&quot;) }&#10;    var isLoggedIn by remember { mutableStateOf(false) }&#10;    var currentUser by remember { mutableStateOf&lt;User?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val hasActiveGame = remember {&#10;        GameStateManager.hasActiveGame() || GameStateManager.hasSavedGame(context)&#10;    }&#10;    val repository = remember { SudokuRepository(context) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        isLoggedIn = repository.isLoggedIn()&#10;        currentUser = repository.getCurrentUser()&#10;    }&#10;&#10;    Column (&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.End,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconToggleButton(&#10;                checked = isDarkTheme,&#10;                onCheckedChange = onThemeToggle,  // Use the callback&#10;                modifier = Modifier.size(24.dp)&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(&#10;                        id = if (!isDarkTheme) R.drawable.light_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                        else R.drawable.dark_mode_24dp_e3e3e3_fill0_wght400_grad0_opsz24&#10;                    ),&#10;                    contentDescription = &quot;Toggle Dark/Light Mode&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            IconButton(onClick = { /* TODO: Open Settings */ }) {&#10;                Icon(&#10;                    imageVector = Icons.Rounded.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier&#10;                        .size(24.dp)&#10;                        .fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Login/User status section&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            if (isLoggedIn &amp;&amp; currentUser != null) {&#10;                // Show welcome message and logout button&#10;                Column {&#10;                    Text(&#10;                        text = &quot;Hello, ${currentUser!!.username}!&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = MaterialTheme.colorScheme.onBackground,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    TextButton(&#10;                        onClick = {&#10;                            repository.logout()&#10;                            isLoggedIn = false&#10;                            currentUser = null&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Logout&quot;, style = MaterialTheme.typography.bodySmall)&#10;                    }&#10;                }&#10;            } else {&#10;                // Show login button&#10;                Button(&#10;                    onClick = onNavigateToAuth,&#10;                    modifier = Modifier.padding(vertical = 8.dp)&#10;                ) {&#10;                    Text(&quot;Login&quot;)&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        // Title&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        Text(&#10;            text = &quot;Welcome to Sudoku!&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;        Spacer(modifier = Modifier.height(192.dp))&#10;&#10;        // Continue game button - only show if there's an active game&#10;        if (hasActiveGame) {&#10;            Button(&#10;                onClick = {&#10;                    if (!GameStateManager.hasActiveGame()) {&#10;                        GameStateManager.loadSavedGame(context)&#10;                    }&#10;                    GameStateManager.continueGame()&#10;                    onContinueGame()&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Continue Game&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // Start new game button&#10;        Button(&#10;            onClick = {&#10;                GameStateManager.startNewGame(selectedDifficulty, context)&#10;                onStartNewGame(selectedDifficulty)&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Text(&#10;                text = if (hasActiveGame) &quot;New Game&quot; else &quot;Start Game&quot;,&#10;                color = MaterialTheme.colorScheme.onPrimary,&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Select difficulty&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = { isDifficultyDropdownOpen = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Difficulty: $selectedDifficulty&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.arrow_drop_down),&#10;                        contentDescription = &quot;Dropdown arrow&quot;,&#10;                        modifier = Modifier&#10;                            .align(Alignment.CenterEnd)&#10;                            .size(24.dp),&#10;                        tint = MaterialTheme.colorScheme.onBackground&#10;                    )&#10;                }&#10;            }&#10;&#10;            DropdownMenu(&#10;                expanded = isDifficultyDropdownOpen,&#10;                onDismissRequest = { isDifficultyDropdownOpen = false }&#10;            ) {&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Easy&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Easy&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Medium&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Medium&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;Hard&quot;) },&#10;                    onClick = {&#10;                        selectedDifficulty = &quot;Hard&quot;&#10;                        isDifficultyDropdownOpen = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(128.dp))&#10;&#10;        // Row for Leaderboard button (left) and Records button (right)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;        ) {&#10;            Button(&#10;                onClick = { /* TODO: Navigate to Leaderboard */ },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Leaderboard&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp)) // Space between buttons&#10;            Button(&#10;                onClick = { onNavigateToRecords() },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Records&quot;,&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainMenuPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        MainMenu(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordsScreen.kt" />
              <option name="originalContent" value="/**&#10; * Displays best times for each difficulty.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;&#10;@Composable&#10;fun RecordScreen(&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {}&#10;) {&#10;    var refresh by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    val difficulties = listOf(&quot;Easy&quot;, &quot;Medium&quot;, &quot;Hard&quot;)&#10;&#10;        )&#10;        difficulties.forEach { difficulty -&gt;&#10;            Text(&#10;                text = &quot;$difficulty: ${BestTimeManager.getBestTimeFormatted(context, difficulty)}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;            )&#10;            Text(&#10;                text = &quot;$difficulty (No Mistakes): ${BestTimeManager.getBestTimeNoMistakeFormatted(&#10;                    context, difficulty)}&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;        }&#10;                text = &quot;$difficulty: ${BestTimeManager.getBestTimeFormatted(context, difficulty)}&quot;,&#10;        Row (&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;                text = &quot;$difficulty (No Mistakes): ${BestTimeManager.getBestTimeNoMistakeFormatted(&#10;                    context, difficulty)}&quot;,&#10;&#10;        ){&#10;            Button(&#10;                onClick = {&#10;                    BestTimeManager.clearBestTimes(context)&#10;                    refresh = !refresh // Toggle to force recomposition&#10;                          },&#10;                modifier = Modifier.padding(top = 16.dp, end = 4.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error,&#10;                    contentColor = MaterialTheme.colorScheme.onError&#10;                )&#10;            ) {&#10;                Text(text = &quot;Reset Times&quot;)&#10;            }&#10;            Button(&#10;                onClick = onNavigateBack,&#10;                modifier = Modifier.padding(start = 4.dp, top = 16.dp),&#10;            ) {&#10;                Text(text = &quot;Back to Menu&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun RecordScreenPreview() {&#10;    RecordScreen(&#10;        modifier = Modifier.fillMaxSize(),&#10;        onNavigateBack = {}&#10;    )&#10;}" />
              <option name="updatedContent" value="/**&#10; * Displays best times for each difficulty.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;&#10;@Composable&#10;fun RecordScreen(&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {}&#10;) {&#10;    var refresh by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    val difficulties = listOf(&quot;Easy&quot;, &quot;Medium&quot;, &quot;Hard&quot;)&#10;&#10;    // Make best times reactive to refresh state&#10;    val bestTimes = remember(refresh) {&#10;        difficulties.associateWith { difficulty -&gt;&#10;            Pair(&#10;                BestTimeManager.getBestTimeFormatted(context, difficulty),&#10;                BestTimeManager.getBestTimeNoMistakeFormatted(context, difficulty)&#10;            )&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Best Times&quot;,&#10;            style = MaterialTheme.typography.headlineLarge,&#10;            color = MaterialTheme.colorScheme.onBackground&#10;        )&#10;        difficulties.forEach { difficulty -&gt;&#10;            val (bestTime, bestTimeNoMistakes) = bestTimes[difficulty] ?: Pair(&quot;No best time&quot;, &quot;No best time&quot;)&#10;            Text(&#10;                text = &quot;$difficulty: $bestTime&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;            )&#10;            Text(&#10;                text = &quot;$difficulty (No Mistakes): $bestTimeNoMistakes&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onBackground&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.weight(1f))&#10;        Row (&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            horizontalArrangement = Arrangement.Center,&#10;&#10;        ){&#10;            Button(&#10;                onClick = {&#10;                    BestTimeManager.clearBestTimes(context)&#10;                    refresh = !refresh // Toggle to force recomposition&#10;                          },&#10;                modifier = Modifier.padding(top = 16.dp, end = 4.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error,&#10;                    contentColor = MaterialTheme.colorScheme.onError&#10;                )&#10;            ) {&#10;                Text(text = &quot;Reset Times&quot;)&#10;            }&#10;            Button(&#10;                onClick = onNavigateBack,&#10;                modifier = Modifier.padding(start = 4.dp, top = 16.dp),&#10;            ) {&#10;                Text(text = &quot;Back to Menu&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun RecordScreenPreview() {&#10;    RecordScreen(&#10;        modifier = Modifier.fillMaxSize(),&#10;        onNavigateBack = {}&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt" />
              <option name="updatedContent" value="/**&#10; * Handles persistence of game state using SharedPreferences&#10; * Serializes game state to JSON for storage&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import com.kooshmeen.sudoku.data.*&#10;&#10;object GameStatePersistence {&#10;    private const val PREFS_NAME = &quot;SudokuGameState&quot;&#10;    private const val KEY_SAVED_GAME = &quot;saved_game&quot;&#10;    &#10;    fun saveGameState(context: Context, gameState: GameState) {&#10;        // Only save if game is active and not completed&#10;        if (!gameState.isGameActive || gameState.isGameCompleted) return&#10;        &#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = serializeGameState(gameState)&#10;        prefs.edit().putString(KEY_SAVED_GAME, json).apply()&#10;    }&#10;    &#10;    fun loadGameState(context: Context): SavedGameState? {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = prefs.getString(KEY_SAVED_GAME, null) ?: return null&#10;        return deserializeGameState(json)&#10;    }&#10;    &#10;    fun clearSavedGame(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit().remove(KEY_SAVED_GAME).apply()&#10;    }&#10;    &#10;    private fun serializeGameState(gameState: GameState): String {&#10;        val jsonObject = JSONObject().apply {&#10;            put(&quot;difficulty&quot;, gameState.difficulty)&#10;            put(&quot;elapsedTime&quot;, gameState.elapsedTimeSeconds)&#10;            put(&quot;mistakesCount&quot;, gameState.mistakesCount)&#10;            put(&quot;grid&quot;, serializeGrid(gameState.grid))&#10;            put(&quot;solutionGrid&quot;, serializeSolutionGrid(gameState.solutionGrid))&#10;        }&#10;        return jsonObject.toString()&#10;    }&#10;    &#10;    private fun serializeGrid(grid: Array&lt;Array&lt;SudokuCell&gt;&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            grid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { cell -&gt;&#10;                        val cellObj = JSONObject().apply {&#10;                            put(&quot;value&quot;, cell.value)&#10;                            put(&quot;notes&quot;, JSONArray(cell.notes.toList()))&#10;                            put(&quot;isOriginal&quot;, cell.isOriginal)&#10;                            put(&quot;hasError&quot;, cell.hasError)&#10;                        }&#10;                        put(cellObj)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun serializeSolutionGrid(solutionGrid: Array&lt;IntArray&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            solutionGrid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { value -&gt;&#10;                        put(value)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun deserializeGameState(json: String): SavedGameState? {&#10;        return try {&#10;            val jsonObject = JSONObject(json)&#10;            &#10;            val gridArray = jsonObject.getJSONArray(&quot;grid&quot;)&#10;            val grid = mutableListOf&lt;List&lt;SavedCellState&gt;&gt;()&#10;            &#10;            for (i in 0 until gridArray.length()) {&#10;                val rowArray = gridArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;SavedCellState&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    val cellObj = rowArray.getJSONObject(j)&#10;                    val notesArray = cellObj.getJSONArray(&quot;notes&quot;)&#10;                    val notes = mutableListOf&lt;Int&gt;()&#10;                    &#10;                    for (k in 0 until notesArray.length()) {&#10;                        notes.add(notesArray.getInt(k))&#10;                    }&#10;                    &#10;                    row.add(SavedCellState(&#10;                        value = cellObj.getInt(&quot;value&quot;),&#10;                        notes = notes,&#10;                        isOriginal = cellObj.getBoolean(&quot;isOriginal&quot;),&#10;                        hasError = cellObj.getBoolean(&quot;hasError&quot;)&#10;                    ))&#10;                }&#10;                grid.add(row)&#10;            }&#10;            &#10;            val solutionArray = jsonObject.getJSONArray(&quot;solutionGrid&quot;)&#10;            val solutionGrid = mutableListOf&lt;List&lt;Int&gt;&gt;()&#10;            &#10;            for (i in 0 until solutionArray.length()) {&#10;                val rowArray = solutionArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;Int&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    row.add(rowArray.getInt(j))&#10;                }&#10;                solutionGrid.add(row)&#10;            }&#10;            &#10;            SavedGameState(&#10;                grid = grid,&#10;                difficulty = jsonObject.getString(&quot;difficulty&quot;),&#10;                elapsedTimeSeconds = jsonObject.getInt(&quot;elapsedTime&quot;),&#10;                mistakesCount = jsonObject.getInt(&quot;mistakesCount&quot;),&#10;                solutionGrid = solutionGrid&#10;            )&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>