<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/MainActivity.kt" />
              <option name="originalContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.screens.AuthScreen&#10;import com.kooshmeen.sudoku.ui.screens.ChallengeResultScreen&#10;import com.kooshmeen.sudoku.ui.screens.ChallengesScreen&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.GroupMembersScreen&#10;import com.kooshmeen.sudoku.ui.screens.GroupsScreen&#10;import com.kooshmeen.sudoku.ui.screens.LeaderboardScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.screens.RecordScreen&#10;import com.kooshmeen.sudoku.ui.screens.SettingsScreen&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game/medium&quot;)&#10;                                },&#10;                                onContinueGame = {&#10;                                    NavController.navigate(&quot;game/medium&quot;)&#10;                                },&#10;                                onStartNewGame = { difficulty -&gt;&#10;                                    NavController.navigate(&quot;game/$difficulty&quot;)&#10;                                },&#10;                                onNavigateToRecords = {&#10;                                    NavController.navigate(&quot;record_screen&quot;)&#10;                                },&#10;                                onNavigateToAuth = {&#10;                                    NavController.navigate(&quot;auth_screen&quot;)&#10;                                },&#10;                                onNavigateToLeaderboard = {&#10;                                    NavController.navigate(&quot;leaderboard_screen&quot;)&#10;                                },&#10;                                onNavigateToSettings = {&#10;                                    NavController.navigate(&quot;settings_screen&quot;)&#10;                                },&#10;                                onNavigateToGroups = {&#10;                                    NavController.navigate(&quot;groups_screen&quot;)&#10;                                },&#10;                                onNavigateToChallenges = {&#10;                                    NavController.navigate(&quot;challenges_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;auth_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            AuthScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onLoginSuccess = {&#10;                                    NavController.navigate(&quot;main_menu&quot;) {&#10;                                        popUpTo(&quot;main_menu&quot;) { inclusive = true }&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&#10;                    &quot;game/{difficulty}?challengeId={challengeId}&quot;,&#10;                    arguments = listOf(&#10;                        navArgument(&quot;difficulty&quot;) { type = NavType.StringType },&#10;                        navArgument(&quot;challengeId&quot;) {&#10;                            type = NavType.StringType&#10;                            nullable = true&#10;                            defaultValue = null&#10;                        }&#10;                    )&#10;                ) { backStackEntry -&gt;&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        val difficulty = backStackEntry.arguments?.getString(&quot;difficulty&quot;) ?: &quot;medium&quot;&#10;                        val challengeIdString = backStackEntry.arguments?.getString(&quot;challengeId&quot;)&#10;                        val challengeId = challengeIdString?.takeIf { it != &quot;null&quot; }?.toIntOrNull()&#10;&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onThemeToggle = { isDarkTheme = it },&#10;                                isDarkTheme = isDarkTheme,&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;record_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            RecordScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;leaderboard_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            LeaderboardScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;settings_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            SettingsScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;groups_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GroupsScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onNavigateToGroupLeaderboard = { groupId -&gt;&#10;                                    // Navigate to group leaderboard screen when implemented&#10;                                    // NavController.navigate(&quot;group_leaderboard/$groupId&quot;)&#10;                                },&#10;                                onNavigateToGroupMembers = { group -&gt;&#10;                                    // Pass only the group ID as a navigation argument&#10;                                    group.id?.let { groupId -&gt;&#10;                                        NavController.navigate(&quot;group_members_screen/$groupId&quot;)&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;group_members_screen/{groupId}&quot;) { backStackEntry -&gt;&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        val groupId = backStackEntry.arguments?.getString(&quot;groupId&quot;)?.toIntOrNull()&#10;&#10;                        if (groupId != null) {&#10;                            Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                                GroupMembersScreen(&#10;                                    groupId = groupId,&#10;                                    onNavigateBack = {&#10;                                        NavController.navigateUp()&#10;                                    },&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .padding(innerPadding)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;challenges_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            ChallengesScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onNavigateToGame = { difficulty, challengeId -&gt;&#10;                                    // Navigate to game with challenge context&#10;                                    NavController.navigate(&quot;game/$difficulty?challengeId=$challengeId&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;challenge_result/{challengeId}/{timeSeconds}/{mistakes}&quot;) { backStackEntry -&gt;&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        val challengeId = backStackEntry.arguments?.getString(&quot;challengeId&quot;)?.toIntOrNull() ?: 0&#10;                        val timeSeconds = backStackEntry.arguments?.getString(&quot;timeSeconds&quot;)?.toIntOrNull() ?: 0&#10;                        val mistakes = backStackEntry.arguments?.getString(&quot;mistakes&quot;)?.toIntOrNull() ?: 0&#10;&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            ChallengeResultScreen(&#10;                                challengeId = challengeId,&#10;                                timeSeconds = timeSeconds,&#10;                                mistakes = mistakes,&#10;                                onNavigateBack = {&#10;                                    // Navigate back to challenges or groups&#10;                                    NavController.popBackStack(&quot;challenges_screen&quot;, false)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Save game state when app goes to background&#10;        GameStateManager.saveCurrentGame(this)&#10;    }&#10;}" />
              <option name="updatedContent" value="/**&#10; * MainActivity.kt&#10; * This file defines the main entry point for the Sudoku app.&#10; */&#10;&#10;package com.kooshmeen.sudoku&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.ui.screens.AuthScreen&#10;import com.kooshmeen.sudoku.ui.screens.ChallengeResultScreen&#10;import com.kooshmeen.sudoku.ui.screens.ChallengesScreen&#10;import com.kooshmeen.sudoku.ui.screens.GameScreen&#10;import com.kooshmeen.sudoku.ui.screens.GroupMembersScreen&#10;import com.kooshmeen.sudoku.ui.screens.GroupsScreen&#10;import com.kooshmeen.sudoku.ui.screens.LeaderboardScreen&#10;import com.kooshmeen.sudoku.ui.screens.MainMenu&#10;import com.kooshmeen.sudoku.ui.screens.RecordScreen&#10;import com.kooshmeen.sudoku.ui.screens.SettingsScreen&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val NavController = rememberNavController()&#10;            var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;            NavHost(&#10;                navController = NavController,&#10;                startDestination = &quot;main_menu&quot;,&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                composable(&quot;main_menu&quot;) {&#10;                    SudokuTheme (darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            MainMenu(&#10;                                onNavigateToGame = {&#10;                                    NavController.navigate(&quot;game/medium&quot;)&#10;                                },&#10;                                onContinueGame = {&#10;                                    NavController.navigate(&quot;game/medium&quot;)&#10;                                },&#10;                                onStartNewGame = { difficulty -&gt;&#10;                                    NavController.navigate(&quot;game/$difficulty&quot;)&#10;                                },&#10;                                onNavigateToRecords = {&#10;                                    NavController.navigate(&quot;record_screen&quot;)&#10;                                },&#10;                                onNavigateToAuth = {&#10;                                    NavController.navigate(&quot;auth_screen&quot;)&#10;                                },&#10;                                onNavigateToLeaderboard = {&#10;                                    NavController.navigate(&quot;leaderboard_screen&quot;)&#10;                                },&#10;                                onNavigateToSettings = {&#10;                                    NavController.navigate(&quot;settings_screen&quot;)&#10;                                },&#10;                                onNavigateToGroups = {&#10;                                    NavController.navigate(&quot;groups_screen&quot;)&#10;                                },&#10;                                onNavigateToChallenges = {&#10;                                    NavController.navigate(&quot;challenges_screen&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;auth_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            AuthScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onLoginSuccess = {&#10;                                    NavController.navigate(&quot;main_menu&quot;) {&#10;                                        popUpTo(&quot;main_menu&quot;) { inclusive = true }&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&#10;                    &quot;game/{difficulty}?challengeId={challengeId}&quot;,&#10;                    arguments = listOf(&#10;                        navArgument(&quot;difficulty&quot;) { type = NavType.StringType },&#10;                        navArgument(&quot;challengeId&quot;) {&#10;                            type = NavType.StringType&#10;                            nullable = true&#10;                            defaultValue = null&#10;                        }&#10;                    )&#10;                ) { backStackEntry -&gt;&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        val difficulty = backStackEntry.arguments?.getString(&quot;difficulty&quot;) ?: &quot;medium&quot;&#10;                        val challengeIdString = backStackEntry.arguments?.getString(&quot;challengeId&quot;)&#10;                        val challengeId = challengeIdString?.takeIf { it != &quot;null&quot; }?.toIntOrNull()&#10;&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GameScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onThemeToggle = { isDarkTheme = it },&#10;                                isDarkTheme = isDarkTheme,&#10;                                onNavigateToMenu = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                challengeId = challengeId,&#10;                                difficulty = difficulty&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;record_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            RecordScreen(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;leaderboard_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            LeaderboardScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;settings_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            SettingsScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding),&#10;                                isDarkTheme = isDarkTheme,&#10;                                onThemeToggle = { isDarkTheme = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;groups_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            GroupsScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onNavigateToGroupLeaderboard = { groupId -&gt;&#10;                                    // Navigate to group leaderboard screen when implemented&#10;                                    // NavController.navigate(&quot;group_leaderboard/$groupId&quot;)&#10;                                },&#10;                                onNavigateToGroupMembers = { group -&gt;&#10;                                    // Pass only the group ID as a navigation argument&#10;                                    group.id?.let { groupId -&gt;&#10;                                        NavController.navigate(&quot;group_members_screen/$groupId&quot;)&#10;                                    }&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;group_members_screen/{groupId}&quot;) { backStackEntry -&gt;&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        val groupId = backStackEntry.arguments?.getString(&quot;groupId&quot;)?.toIntOrNull()&#10;&#10;                        if (groupId != null) {&#10;                            Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                                GroupMembersScreen(&#10;                                    groupId = groupId,&#10;                                    onNavigateBack = {&#10;                                        NavController.navigateUp()&#10;                                    },&#10;                                    onNavigateToGame = { difficulty, challengeId -&gt;&#10;                                        // Navigate to game with challenge context for challenger&#10;                                        NavController.navigate(&quot;game/$difficulty?challengeId=$challengeId&quot;)&#10;                                    },&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .padding(innerPadding)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;challenges_screen&quot;) {&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            ChallengesScreen(&#10;                                onNavigateBack = {&#10;                                    NavController.navigateUp()&#10;                                },&#10;                                onNavigateToGame = { difficulty, challengeId -&gt;&#10;                                    // Navigate to game with challenge context&#10;                                    NavController.navigate(&quot;game/$difficulty?challengeId=$challengeId&quot;)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                composable(&quot;challenge_result/{challengeId}/{timeSeconds}/{mistakes}&quot;) { backStackEntry -&gt;&#10;                    SudokuTheme(darkTheme = isDarkTheme) {&#10;                        val challengeId = backStackEntry.arguments?.getString(&quot;challengeId&quot;)?.toIntOrNull() ?: 0&#10;                        val timeSeconds = backStackEntry.arguments?.getString(&quot;timeSeconds&quot;)?.toIntOrNull() ?: 0&#10;                        val mistakes = backStackEntry.arguments?.getString(&quot;mistakes&quot;)?.toIntOrNull() ?: 0&#10;&#10;                        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                            ChallengeResultScreen(&#10;                                challengeId = challengeId,&#10;                                timeSeconds = timeSeconds,&#10;                                mistakes = mistakes,&#10;                                onNavigateBack = {&#10;                                    // Navigate back to challenges or groups&#10;                                    NavController.popBackStack(&quot;challenges_screen&quot;, false)&#10;                                },&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .padding(innerPadding)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Save game state when app goes to background&#10;        GameStateManager.saveCurrentGame(this)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/api/SudokuApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/api/SudokuApiService.kt" />
              <option name="originalContent" value="package com.kooshmeen.sudoku.api&#10;&#10;import com.kooshmeen.sudoku.data.api.ApiResponse&#10;import com.kooshmeen.sudoku.data.api.ChallengeCompletionRequest&#10;import com.kooshmeen.sudoku.data.api.ChallengeCompletionResponse&#10;import com.kooshmeen.sudoku.data.api.ChallengeCreationResponse&#10;import com.kooshmeen.sudoku.data.api.ChallengesResponse&#10;import com.kooshmeen.sudoku.data.api.CreateChallengeRequest&#10;import com.kooshmeen.sudoku.data.api.GameSubmission&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.data.api.GroupMembersResponse&#10;import com.kooshmeen.sudoku.data.api.GroupsResponse&#10;import com.kooshmeen.sudoku.data.api.LeaderboardResponse&#10;import com.kooshmeen.sudoku.data.api.LiveMatch&#10;import com.kooshmeen.sudoku.data.api.LoginRequest&#10;import com.kooshmeen.sudoku.data.api.LoginResponse&#10;import com.kooshmeen.sudoku.data.api.RegisterRequest&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.DELETE&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;import retrofit2.http.POST&#10;import retrofit2.http.PUT&#10;import retrofit2.http.Path&#10;import retrofit2.http.Query&#10;&#10;interface SudokuApiService {&#10;    // Public routes (no authentication required)&#10;    @POST(&quot;register&quot;)&#10;    suspend fun register(@Body request: RegisterRequest): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;login&quot;)&#10;    suspend fun login(@Body request: LoginRequest): Response&lt;LoginResponse&gt;&#10;&#10;    @GET(&quot;groups&quot;)&#10;    suspend fun getAllGroups(): Response&lt;GroupsResponse&gt;&#10;&#10;    @GET(&quot;groups/search&quot;)&#10;    suspend fun searchGroups(@Query(&quot;q&quot;) query: String): Response&lt;GroupsResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global&quot;)&#10;    suspend fun getGlobalLeaderboard(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Specific leaderboard routes&#10;    @GET(&quot;leaderboard/global/all-time&quot;)&#10;    suspend fun getTop100GlobalAllTime(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/monthly&quot;)&#10;    suspend fun getTop100GlobalMonth(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/weekly&quot;)&#10;    suspend fun getTop100GlobalWeek(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/daily&quot;)&#10;    suspend fun getTop100GlobalDay(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Protected routes (authentication required)&#10;    @PUT(&quot;profile&quot;)&#10;    suspend fun updateProfile(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body update: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @PUT(&quot;password&quot;)&#10;    suspend fun changePassword(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body request: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Game submission&#10;    @POST(&quot;submit-game&quot;)&#10;    suspend fun submitGame(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body gameData: GameSubmission&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Player statistics and medals&#10;    @GET(&quot;stats&quot;)&#10;    suspend fun getPlayerStats(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;Map&lt;String, Any&gt;&gt;&#10;&#10;    @GET(&quot;medals&quot;)&#10;    suspend fun getPlayerMedals(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt;&#10;&#10;    // Group management routes&#10;    @POST(&quot;groups&quot;)&#10;    suspend fun createGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body groupRequest: Map&lt;String, Any?&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @GET(&quot;my-groups&quot;)&#10;    suspend fun getMyGroups(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;GroupsResponse&gt;&#10;&#10;    @GET(&quot;groups/{groupId}&quot;)&#10;    suspend fun getGroupDetails(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;GroupData&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/join&quot;)&#10;    suspend fun joinGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/join-with-password&quot;)&#10;    suspend fun joinGroupWithPassword(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Body password: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @DELETE(&quot;groups/{groupId}/leave&quot;)&#10;    suspend fun leaveGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @DELETE(&quot;groups/{groupId}&quot;)&#10;    suspend fun deleteGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Group leaderboard&#10;    @GET(&quot;groups/{groupId}/leaderboard&quot;)&#10;    suspend fun getGroupLeaderboard(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Group members&#10;    @GET(&quot;groups/{groupId}&quot;)&#10;    suspend fun getGroupMembers(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;GroupMembersResponse&gt;&#10;&#10;    // Group member management (leaders only)&#10;    @PUT(&quot;groups/{groupId}/members/{memberId}/role&quot;)&#10;    suspend fun setMemberRole(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Path(&quot;memberId&quot;) memberId: Int,&#10;        @Body roleData: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Admin routes (for awarding medals)&#10;    @POST(&quot;players/{playerId}/medals&quot;)&#10;    suspend fun awardMedal(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;playerId&quot;) playerId: Int,&#10;        @Body medalData: Map&lt;String, Any&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Challenge endpoints&#10;    @GET(&quot;challenges/pending&quot;)&#10;    suspend fun getPendingChallenges(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;ChallengesResponse&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/accept&quot;)&#10;    suspend fun acceptChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int&#10;    ): Response&lt;Map&lt;String, Any&gt;&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/complete&quot;)&#10;    suspend fun completeChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int,&#10;        @Body request: ChallengeCompletionRequest&#10;    ): Response&lt;ChallengeCompletionResponse&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/challenge&quot;)&#10;    suspend fun createChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Body request: CreateChallengeRequest&#10;    ): Response&lt;ChallengeCreationResponse&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/reject&quot;)&#10;    suspend fun rejectChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/complete-challenger&quot;)&#10;    suspend fun completeChallengerGame(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int,&#10;        @Body request: ChallengeCompletionRequest&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @GET(&quot;matches/pending&quot;)&#10;    suspend fun getPendingLiveMatches(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;Map&lt;String, List&lt;LiveMatch&gt;&gt;&gt;&#10;&#10;    @POST(&quot;matches/{matchId}/accept&quot;)&#10;    suspend fun acceptLiveMatch(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;matchId&quot;) matchId: Int&#10;    ): Response&lt;Map&lt;String, Any&gt;&gt;&#10;}" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.api&#10;&#10;import com.kooshmeen.sudoku.data.api.ApiResponse&#10;import com.kooshmeen.sudoku.data.api.ChallengeCompletionRequest&#10;import com.kooshmeen.sudoku.data.api.ChallengeCompletionResponse&#10;import com.kooshmeen.sudoku.data.api.ChallengeCreationResponse&#10;import com.kooshmeen.sudoku.data.api.ChallengesResponse&#10;import com.kooshmeen.sudoku.data.api.CreateChallengeRequest&#10;import com.kooshmeen.sudoku.data.api.GameSubmission&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.data.api.GroupMembersResponse&#10;import com.kooshmeen.sudoku.data.api.GroupsResponse&#10;import com.kooshmeen.sudoku.data.api.LeaderboardResponse&#10;import com.kooshmeen.sudoku.data.api.LiveMatch&#10;import com.kooshmeen.sudoku.data.api.LoginRequest&#10;import com.kooshmeen.sudoku.data.api.LoginResponse&#10;import com.kooshmeen.sudoku.data.api.RegisterRequest&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.DELETE&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;import retrofit2.http.POST&#10;import retrofit2.http.PUT&#10;import retrofit2.http.Path&#10;import retrofit2.http.Query&#10;&#10;interface SudokuApiService {&#10;    // Public routes (no authentication required)&#10;    @POST(&quot;register&quot;)&#10;    suspend fun register(@Body request: RegisterRequest): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;login&quot;)&#10;    suspend fun login(@Body request: LoginRequest): Response&lt;LoginResponse&gt;&#10;&#10;    @GET(&quot;groups&quot;)&#10;    suspend fun getAllGroups(): Response&lt;GroupsResponse&gt;&#10;&#10;    @GET(&quot;groups/search&quot;)&#10;    suspend fun searchGroups(@Query(&quot;q&quot;) query: String): Response&lt;GroupsResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global&quot;)&#10;    suspend fun getGlobalLeaderboard(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Specific leaderboard routes&#10;    @GET(&quot;leaderboard/global/all-time&quot;)&#10;    suspend fun getTop100GlobalAllTime(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/monthly&quot;)&#10;    suspend fun getTop100GlobalMonth(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/weekly&quot;)&#10;    suspend fun getTop100GlobalWeek(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;leaderboard/global/daily&quot;)&#10;    suspend fun getTop100GlobalDay(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Protected routes (authentication required)&#10;    @PUT(&quot;profile&quot;)&#10;    suspend fun updateProfile(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body update: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @PUT(&quot;password&quot;)&#10;    suspend fun changePassword(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body request: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Game submission&#10;    @POST(&quot;submit-game&quot;)&#10;    suspend fun submitGame(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body gameData: GameSubmission&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Player statistics and medals&#10;    @GET(&quot;stats&quot;)&#10;    suspend fun getPlayerStats(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;Map&lt;String, Any&gt;&gt;&#10;&#10;    @GET(&quot;medals&quot;)&#10;    suspend fun getPlayerMedals(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt;&#10;&#10;    // Group management routes&#10;    @POST(&quot;groups&quot;)&#10;    suspend fun createGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body groupRequest: Map&lt;String, Any?&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @GET(&quot;my-groups&quot;)&#10;    suspend fun getMyGroups(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;GroupsResponse&gt;&#10;&#10;    @GET(&quot;groups/{groupId}&quot;)&#10;    suspend fun getGroupDetails(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;GroupData&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/join&quot;)&#10;    suspend fun joinGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/join-with-password&quot;)&#10;    suspend fun joinGroupWithPassword(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Body password: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @DELETE(&quot;groups/{groupId}/leave&quot;)&#10;    suspend fun leaveGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @DELETE(&quot;groups/{groupId}&quot;)&#10;    suspend fun deleteGroup(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Group leaderboard&#10;    @GET(&quot;groups/{groupId}/leaderboard&quot;)&#10;    suspend fun getGroupLeaderboard(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Group members&#10;    @GET(&quot;groups/{groupId}&quot;)&#10;    suspend fun getGroupMembers(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int&#10;    ): Response&lt;GroupMembersResponse&gt;&#10;&#10;    // Group member management (leaders only)&#10;    @PUT(&quot;groups/{groupId}/members/{memberId}/role&quot;)&#10;    suspend fun setMemberRole(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Path(&quot;memberId&quot;) memberId: Int,&#10;        @Body roleData: Map&lt;String, String&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Admin routes (for awarding medals)&#10;    @POST(&quot;players/{playerId}/medals&quot;)&#10;    suspend fun awardMedal(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;playerId&quot;) playerId: Int,&#10;        @Body medalData: Map&lt;String, Any&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    // Challenge endpoints&#10;    @GET(&quot;challenges/pending&quot;)&#10;    suspend fun getPendingChallenges(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;ChallengesResponse&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/accept&quot;)&#10;    suspend fun acceptChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int&#10;    ): Response&lt;Map&lt;String, Any&gt;&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/complete&quot;)&#10;    suspend fun completeChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int,&#10;        @Body request: ChallengeCompletionRequest&#10;    ): Response&lt;ChallengeCompletionResponse&gt;&#10;&#10;    @POST(&quot;groups/{groupId}/challenge&quot;)&#10;    suspend fun createChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;groupId&quot;) groupId: Int,&#10;        @Body request: CreateChallengeRequest&#10;    ): Response&lt;ChallengeCreationResponse&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/reject&quot;)&#10;    suspend fun rejectChallenge(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @POST(&quot;challenges/{challengeId}/complete-challenger&quot;)&#10;    suspend fun completeChallengerGame(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;challengeId&quot;) challengeId: Int,&#10;        @Body request: Map&lt;String, Any&gt;&#10;    ): Response&lt;ApiResponse&gt;&#10;&#10;    @GET(&quot;matches/pending&quot;)&#10;    suspend fun getPendingLiveMatches(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;Map&lt;String, List&lt;LiveMatch&gt;&gt;&gt;&#10;&#10;    @POST(&quot;matches/{matchId}/accept&quot;)&#10;    suspend fun acceptLiveMatch(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;matchId&quot;) matchId: Int&#10;    ): Response&lt;Map&lt;String, Any&gt;&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameAction.kt" />
              <option name="originalContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Sealed class representing different actions that can be performed on the Sudoku grid&#10; * Used for implementing undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;sealed class GameAction {&#10;    data class SetValue(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val newValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class AddNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class RemoveNote(&#10;        val row: Int,&#10;        val col: Int,&#10;        val note: Int&#10;    ) : GameAction()&#10;&#10;    data class ClearCell(&#10;        val row: Int,&#10;        val col: Int,&#10;        val oldValue: Int,&#10;        val oldNotes: Set&lt;Int&gt;&#10;    ) : GameAction()&#10;&#10;    data class RemoveNotesBatch(&#10;        val cells: List&lt;Pair&lt;Int, Int&gt;&gt;,&#10;        val note: Int,&#10;        val oldNotes: List&lt;Set&lt;Int&gt;&gt;&#10;    ) : GameAction()&#10;&#10;    data class AutofillNotes(&#10;        val cells: List&lt;Pair&lt;Int, Int&gt;&gt;,&#10;        val oldNotes: List&lt;Set&lt;Int&gt;&gt;&#10;    ) : GameAction()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameState.kt" />
              <option name="originalContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import android.content.Context&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Current number of mistakes made by the player&#10;    var mistakesCount by mutableIntStateOf(0)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    // Store the original solution grid for error checking&#10;    internal var solutionGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;        private set&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    private lateinit var repository: SudokuRepository&#10;&#10;    fun initializeRepository(context: Context) {&#10;        repository = SudokuRepository(context)&#10;    }&#10;&#10;    suspend fun submitScoreToServer(): Boolean {&#10;        return if (isGameCompleted &amp;&amp; ::repository.isInitialized &amp;&amp; repository.isLoggedIn()) {&#10;            val result = repository.submitGame(&#10;                difficulty = difficulty,&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;            result.isSuccess&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Record game completion in local statistics&#10;     */&#10;    fun recordGameCompletion(context: Context) {&#10;        if (isGameCompleted) {&#10;            com.kooshmeen.sudoku.utils.StatisticsManager.recordCompletedGame(&#10;                context = context,&#10;                difficulty = difficulty,&#10;                score = highestPossibleScore(),&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Returns highest possible score from current game state&#10;     * Calculated as:&#10;     * const score = Math.round((difficultyMultiplier * mistakePenalty) * (Math.max(0, (timeScore - timeSeconds) * 2) + basePoints));&#10;     * With: difficultyMultiplier = 0.33 for Easy, 0.7 for Medium, 1.5 for Hard&#10;     * timeScore = 600 for Easy, 1200 for Medium, 1800 for Hard&#10;     * mistakePenalty = max(0.4, 1 - (numberOfMistakes * 0.1)&#10;     * basePoints = 1000&#10;     */&#10;    fun highestPossibleScore(): Int {&#10;        val difficultyMultiplier = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 0.33&#10;            &quot;medium&quot; -&gt; 0.7&#10;            &quot;hard&quot; -&gt; 1.5&#10;            else -&gt; 0.33 // Default to Easy if unknown&#10;        }&#10;&#10;        val timeScore = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 600&#10;            &quot;medium&quot; -&gt; 1200&#10;            &quot;hard&quot; -&gt; 1800&#10;            else -&gt; 600 // Default to Easy if unknown&#10;        }&#10;&#10;        val mistakePenalty = maxOf(0.4, 1 - (mistakesCount * 0.1))&#10;        val basePoints = 1000&#10;&#10;        return ((difficultyMultiplier * mistakePenalty) * (maxOf(0, (timeScore - elapsedTimeSeconds) * 2) + basePoints)).toInt()&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;        if (currentCell.isOriginal) return&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        // Error: compare to solutionGrid&#10;        val hasError = solutionGrid[row][col] != value&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(),&#10;            hasError = hasError&#10;        )&#10;        // Track cells and old notes for undo&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val affectedOldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;        // Remove notes of this value in row&#10;        for (c in 0..8) {&#10;            if (c != col) {&#10;                val cell = newGrid[row][c]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(row, c))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[row][c] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from column&#10;        for (r in 0..8) {&#10;            if (r != row) {&#10;                val cell = newGrid[r][col]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(r, col))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[r][col] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if ((r != row || c != col)) {&#10;                    val cell = newGrid[r][c]&#10;                    if (cell.notes.contains(value)) {&#10;                        affectedCells.add(Pair(r, c))&#10;                        affectedOldNotes.add(cell.notes)&#10;                        newGrid[r][c] = cell.copy(notes = cell.notes - value)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // Push batch note removal to action stack for undo&#10;        if (affectedCells.isNotEmpty()) {&#10;            actionHistory.push(GameAction.RemoveNotesBatch(affectedCells, value, affectedOldNotes))&#10;        }&#10;        if (hasError) {&#10;            errorCells = errorCells + Pair(row, col)&#10;            // Mark as mistake&#10;            mistakesCount++&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;        grid = newGrid&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    private fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = SudokuCell() // Create a new empty cell&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    hasError = false&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = SudokuCell(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    isOriginal = grid[action.row][action.col].isOriginal&#10;                )&#10;            }&#10;            is GameAction.RemoveNotesBatch -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;            is GameAction.AutofillNotes -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        // Generate a new puzzle and store the solution grid&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused &amp;&amp; isGameActive) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;&#10;    /**&#10;     * Load game state from saved data&#10;     */&#10;    fun loadFromSavedState(savedState: SavedGameState) {&#10;        this.difficulty = savedState.difficulty&#10;        this.elapsedTimeSeconds = savedState.elapsedTimeSeconds&#10;        this.mistakesCount = savedState.mistakesCount&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.errorCells = emptySet()&#10;&#10;        // Convert saved grid to SudokuCell array&#10;        this.grid = Array(9) { row -&gt;&#10;            Array(9) { col -&gt;&#10;                val saved = savedState.grid[row][col]&#10;                SudokuCell(&#10;                    value = saved.value,&#10;                    notes = saved.notes.toSet(),&#10;                    isOriginal = saved.isOriginal,&#10;                    hasError = saved.hasError&#10;                )&#10;            }&#10;        }&#10;&#10;        // Convert solution grid&#10;        this.solutionGrid = Array(9) { row -&gt;&#10;            IntArray(9) { col -&gt;&#10;                savedState.solutionGrid[row][col]&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Autofill all valid notes for empty cells&#10;     */&#10;    fun autofillNotes() {&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val oldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty &amp;&amp; !cell.isOriginal) {&#10;                    val validNotes = getValidNotesForCell(row, col)&#10;                    if (validNotes != cell.notes) {&#10;                        affectedCells.add(Pair(row, col))&#10;                        oldNotes.add(cell.notes)&#10;                        newGrid[row][col] = cell.copy(notes = validNotes)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Only update grid and add to history if there were changes&#10;        if (affectedCells.isNotEmpty()) {&#10;            // Create action for undo&#10;            val action = GameAction.AutofillNotes(affectedCells, oldNotes)&#10;            actionHistory.push(action)&#10;            grid = newGrid&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all valid notes for a cell based on current grid state&#10;     */&#10;    private fun getValidNotesForCell(row: Int, col: Int): Set&lt;Int&gt; {&#10;        val validNotes = mutableSetOf&lt;Int&gt;()&#10;&#10;        for (number in 1..9) {&#10;            if (isValidPlacement(row, col, number)) {&#10;                validNotes.add(number)&#10;            }&#10;        }&#10;&#10;        return validNotes&#10;    }&#10;&#10;    /**&#10;     * Check if placing a number at the given position would be valid&#10;     */&#10;    private fun isValidPlacement(row: Int, col: Int, number: Int): Boolean {&#10;        // Check row&#10;        for (c in 0..8) {&#10;            if (grid[row][c].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check column&#10;        for (r in 0..8) {&#10;            if (grid[r][col].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check 3x3 box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if (grid[r][c].value == number) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;&#10;        return true&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game state manager for Sudoku&#10; * Handles all game logic, state management, and action history for undo functionality&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import android.content.Context&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.utils.SudokuValidator&#10;import java.util.Locale&#10;import java.util.Stack&#10;&#10;class GameState {&#10;    // Game grid - 9x9 array of SudokuCell objects&#10;    var grid by mutableStateOf(Array(9) { Array(9) { SudokuCell() } })&#10;        private set&#10;&#10;    // Currently selected cell&#10;    var selectedCell by mutableStateOf&lt;Pair&lt;Int, Int&gt;?&gt;(null)&#10;        private set&#10;&#10;    // Current game mode&#10;    var gameMode by mutableStateOf(GameMode.NORMAL)&#10;        private set&#10;&#10;    // Current number of mistakes made by the player&#10;    var mistakesCount by mutableIntStateOf(0)&#10;        private set&#10;&#10;    // Selected number from input row (1-9)&#10;    var selectedNumber by mutableStateOf&lt;Int?&gt;(null)&#10;        private set&#10;&#10;    // Action history for undo functionality&#10;    private val actionHistory = Stack&lt;GameAction&gt;()&#10;&#10;    // Game timer&#10;    var elapsedTimeSeconds by mutableStateOf(0)&#10;        private set&#10;&#10;    // Game difficulty&#10;    var difficulty by mutableStateOf(&quot;Easy&quot;)&#10;        private set&#10;&#10;    // Game paused state&#10;    var isPaused by mutableStateOf(false)&#10;        private set&#10;&#10;    // Error cells&#10;    var errorCells by mutableStateOf(emptySet&lt;Pair&lt;Int, Int&gt;&gt;())&#10;        private set&#10;&#10;    // Game active state&#10;    var isGameActive by mutableStateOf(false)&#10;        private set&#10;&#10;    // Game completed state&#10;    var isGameCompleted by mutableStateOf(false)&#10;        private set&#10;&#10;    // Store the original solution grid for error checking&#10;    internal var solutionGrid: Array&lt;IntArray&gt; = Array(9) { IntArray(9) }&#10;        private set&#10;&#10;    enum class GameMode {&#10;        NORMAL,    // Place numbers&#10;        NOTES,     // Add/remove notes&#10;        ERASE      // Clear cells&#10;    }&#10;&#10;    private lateinit var repository: SudokuRepository&#10;&#10;    fun initializeRepository(context: Context) {&#10;        repository = SudokuRepository(context)&#10;    }&#10;&#10;    suspend fun submitScoreToServer(): Boolean {&#10;        return if (isGameCompleted &amp;&amp; ::repository.isInitialized &amp;&amp; repository.isLoggedIn()) {&#10;            val result = repository.submitGame(&#10;                difficulty = difficulty,&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;            result.isSuccess&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Record game completion in local statistics&#10;     */&#10;    fun recordGameCompletion(context: Context) {&#10;        if (isGameCompleted) {&#10;            com.kooshmeen.sudoku.utils.StatisticsManager.recordCompletedGame(&#10;                context = context,&#10;                difficulty = difficulty,&#10;                score = highestPossibleScore(),&#10;                timeSeconds = elapsedTimeSeconds,&#10;                mistakes = mistakesCount&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Select a number from the input row&#10;     */&#10;    fun selectNumber(number: Int) {&#10;        selectedNumber = if (selectedNumber == number) null else number&#10;    }&#10;&#10;    /**&#10;     * Toggle the game mode between NORMAL and NOTES&#10;     */&#10;    fun toggleNotesMode() {&#10;        gameMode = if (gameMode == GameMode.NOTES) GameMode.NORMAL else GameMode.NOTES&#10;    }&#10;&#10;    /**&#10;     * Toggle erase mode on/off&#10;     */&#10;    fun toggleEraseMode() {&#10;        gameMode = if (gameMode == GameMode.ERASE) GameMode.NORMAL else GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Set erase mode&#10;     */&#10;    fun setEraseMode() {&#10;        gameMode = GameMode.ERASE&#10;    }&#10;&#10;    /**&#10;     * Returns highest possible score from current game state&#10;     * Calculated as:&#10;     * const score = Math.round((difficultyMultiplier * mistakePenalty) * (Math.max(0, (timeScore - timeSeconds) * 2) + basePoints));&#10;     * With: difficultyMultiplier = 0.33 for Easy, 0.7 for Medium, 1.5 for Hard&#10;     * timeScore = 600 for Easy, 1200 for Medium, 1800 for Hard&#10;     * mistakePenalty = max(0.4, 1 - (numberOfMistakes * 0.1)&#10;     * basePoints = 1000&#10;     */&#10;    fun highestPossibleScore(): Int {&#10;        val difficultyMultiplier = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 0.33&#10;            &quot;medium&quot; -&gt; 0.7&#10;            &quot;hard&quot; -&gt; 1.5&#10;            else -&gt; 0.33 // Default to Easy if unknown&#10;        }&#10;&#10;        val timeScore = when (difficulty.lowercase(Locale.ROOT)) {&#10;            &quot;easy&quot; -&gt; 600&#10;            &quot;medium&quot; -&gt; 1200&#10;            &quot;hard&quot; -&gt; 1800&#10;            else -&gt; 600 // Default to Easy if unknown&#10;        }&#10;&#10;        val mistakePenalty = maxOf(0.4, 1 - (mistakesCount * 0.1))&#10;        val basePoints = 1000&#10;&#10;        return ((difficultyMultiplier * mistakePenalty) * (maxOf(0, (timeScore - elapsedTimeSeconds) * 2) + basePoints)).toInt()&#10;    }&#10;&#10;    /**&#10;     * Input a number directly to a cell (no selection needed)&#10;     */&#10;    fun inputToCell(row: Int, col: Int) {&#10;        val number = selectedNumber ?: return&#10;&#10;        when (gameMode) {&#10;            GameMode.NORMAL -&gt; setValue(row, col, number)&#10;            GameMode.NOTES -&gt; toggleNote(row, col, number)&#10;            GameMode.ERASE -&gt; clearCell(row, col)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a value in a cell&#10;     */&#10;    private fun setValue(row: Int, col: Int, value: Int) {&#10;        val currentCell = grid[row][col]&#10;        if (currentCell.isOriginal) return&#10;        val action = GameAction.SetValue(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            newValue = value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        // Error: compare to solutionGrid&#10;        val hasError = solutionGrid[row][col] != value&#10;        newGrid[row][col] = currentCell.copy(&#10;            value = value,&#10;            notes = emptySet(),&#10;            hasError = hasError&#10;        )&#10;        // Track cells and old notes for undo&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val affectedOldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;        // Remove notes of this value in row&#10;        for (c in 0..8) {&#10;            if (c != col) {&#10;                val cell = newGrid[row][c]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(row, c))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[row][c] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from column&#10;        for (r in 0..8) {&#10;            if (r != row) {&#10;                val cell = newGrid[r][col]&#10;                if (cell.notes.contains(value)) {&#10;                    affectedCells.add(Pair(r, col))&#10;                    affectedOldNotes.add(cell.notes)&#10;                    newGrid[r][col] = cell.copy(notes = cell.notes - value)&#10;                }&#10;            }&#10;        }&#10;        // Remove from box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if ((r != row || c != col)) {&#10;                    val cell = newGrid[r][c]&#10;                    if (cell.notes.contains(value)) {&#10;                        affectedCells.add(Pair(r, c))&#10;                        affectedOldNotes.add(cell.notes)&#10;                        newGrid[r][c] = cell.copy(notes = cell.notes - value)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // Push batch note removal to action stack for undo&#10;        if (affectedCells.isNotEmpty()) {&#10;            actionHistory.push(GameAction.RemoveNotesBatch(affectedCells, value, affectedOldNotes))&#10;        }&#10;        if (hasError) {&#10;            errorCells = errorCells + Pair(row, col)&#10;            // Mark as mistake&#10;            mistakesCount++&#10;        } else {&#10;            errorCells = errorCells - Pair(row, col)&#10;        }&#10;        grid = newGrid&#10;        if (isGameComplete()) {&#10;            isGameCompleted = true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle a note in a cell&#10;     */&#10;    private fun toggleNote(row: Int, col: Int, note: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Only allow notes in empty cells&#10;        if (currentCell.isFilled || currentCell.isOriginal) return&#10;&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        if (currentCell.notes.contains(note)) {&#10;            // Remove note&#10;            val action = GameAction.RemoveNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes - note,&#10;            )&#10;        } else {&#10;            // Add note&#10;            val action = GameAction.AddNote(row, col, note)&#10;            actionHistory.push(action)&#10;&#10;            newGrid[row][col] = currentCell.copy(&#10;                notes = currentCell.notes + note,&#10;            )&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Clear a cell (erase mode)&#10;     */&#10;    private fun clearCell(row: Int, col: Int) {&#10;        val currentCell = grid[row][col]&#10;&#10;        // Don't allow clearing original puzzle cells&#10;        if (currentCell.isOriginal) return&#10;&#10;        // Create action for undo&#10;        val action = GameAction.ClearCell(&#10;            row = row,&#10;            col = col,&#10;            oldValue = currentCell.value,&#10;            oldNotes = currentCell.notes&#10;        )&#10;        actionHistory.push(action)&#10;&#10;        // Clear the cell&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        newGrid[row][col] = SudokuCell() // Create a new empty cell&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Undo the last action&#10;     */&#10;    fun undo() {&#10;        if (actionHistory.isEmpty()) return&#10;&#10;        val action = actionHistory.pop()&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;&#10;        when (action) {&#10;            is GameAction.SetValue -&gt; {&#10;                newGrid[action.row][action.col] = grid[action.row][action.col].copy(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    hasError = false&#10;                )&#10;            }&#10;            is GameAction.AddNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes - action.note,&#10;                )&#10;            }&#10;            is GameAction.RemoveNote -&gt; {&#10;                val currentCell = grid[action.row][action.col]&#10;                newGrid[action.row][action.col] = currentCell.copy(&#10;                    notes = currentCell.notes + action.note,&#10;                )&#10;            }&#10;            is GameAction.ClearCell -&gt; {&#10;                newGrid[action.row][action.col] = SudokuCell(&#10;                    value = action.oldValue,&#10;                    notes = action.oldNotes,&#10;                    isOriginal = grid[action.row][action.col].isOriginal&#10;                )&#10;            }&#10;            is GameAction.RemoveNotesBatch -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;            is GameAction.AutofillNotes -&gt; {&#10;                action.cells.forEachIndexed { idx, (row, col) -&gt;&#10;                    val cell = grid[row][col]&#10;                    newGrid[row][col] = cell.copy(notes = action.oldNotes[idx])&#10;                }&#10;            }&#10;        }&#10;&#10;        grid = newGrid&#10;    }&#10;&#10;    /**&#10;     * Check if there's an active game in progress&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return isGameActive &amp;&amp; !isGameCompleted&#10;    }&#10;&#10;    /**&#10;     * Check if the game is completed&#10;     */&#10;    fun isGameComplete(): Boolean {&#10;        // Check if all cells are filled and there are no errors&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty || cell.hasError) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Initialize a new game with the given difficulty&#10;     */&#10;    fun startNewGame(difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        // Generate a new puzzle and store the solution grid&#10;        val generator = SudokuGenerator()&#10;        val completeGrid = generator.generateCompleteGrid()&#10;        solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;        grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Load a challenge game with specific puzzle data&#10;     */&#10;    fun loadChallengeGame(puzzleData: Map&lt;*, *&gt;, difficulty: String) {&#10;        this.difficulty = difficulty&#10;        this.elapsedTimeSeconds = 0&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.errorCells = emptySet()&#10;        this.mistakesCount = 0&#10;&#10;        // Load the specific puzzle data from the challenge&#10;        try {&#10;            val puzzleGrid = puzzleData[&quot;puzzle&quot;] as? List&lt;*&gt;&#10;            val solutionGrid = puzzleData[&quot;solution&quot;] as? List&lt;*&gt;&#10;            &#10;            if (puzzleGrid != null &amp;&amp; solutionGrid != null) {&#10;                // Load the solution grid&#10;                this.solutionGrid = Array(9) { row -&gt;&#10;                    IntArray(9) { col -&gt;&#10;                        val rowData = solutionGrid[row] as? List&lt;*&gt;&#10;                        (rowData?.get(col) as? Number)?.toInt() ?: 0&#10;                    }&#10;                }&#10;                &#10;                // Load the puzzle grid&#10;                this.grid = Array(9) { row -&gt;&#10;                    Array(9) { col -&gt;&#10;                        val rowData = puzzleGrid[row] as? List&lt;*&gt;&#10;                        val cellValue = (rowData?.get(col) as? Number)?.toInt() ?: 0&#10;                        SudokuCell(&#10;                            value = cellValue,&#10;                            isOriginal = cellValue != 0&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                // Fallback: generate a new puzzle if data is invalid&#10;                val generator = SudokuGenerator()&#10;                val completeGrid = generator.generateCompleteGrid()&#10;                this.solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;                this.grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback: generate a new puzzle if there's an error parsing the data&#10;            val generator = SudokuGenerator()&#10;            val completeGrid = generator.generateCompleteGrid()&#10;            this.solutionGrid = completeGrid.map { it.clone() }.toTypedArray()&#10;            this.grid = generator.createPuzzleWithUniquenessCheck(completeGrid, difficulty)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Continue an existing game&#10;     */&#10;    fun continueGame() {&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        this.isGameActive = false&#10;        this.isGameCompleted = isGameComplete()&#10;    }&#10;&#10;    /**&#10;     * Toggle pause state&#10;     */&#10;    fun togglePause() {&#10;        isPaused = !isPaused&#10;    }&#10;&#10;    /**&#10;     * Update timer (call this every second when game is not paused)&#10;     */&#10;    fun updateTimer() {&#10;        if (!isPaused &amp;&amp; isGameActive) {&#10;            elapsedTimeSeconds++&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format elapsed time as MM:SS&#10;     */&#10;    fun getFormattedTime(): String {&#10;        val minutes = elapsedTimeSeconds / 60&#10;        val seconds = elapsedTimeSeconds % 60&#10;        return String.format(Locale.ROOT, &quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;&#10;    /**&#10;     * Load game state from saved data&#10;     */&#10;    fun loadFromSavedState(savedState: SavedGameState) {&#10;        this.difficulty = savedState.difficulty&#10;        this.elapsedTimeSeconds = savedState.elapsedTimeSeconds&#10;        this.mistakesCount = savedState.mistakesCount&#10;        this.isGameActive = true&#10;        this.isGameCompleted = false&#10;        this.isPaused = false&#10;        this.selectedCell = null&#10;        this.selectedNumber = null&#10;        this.gameMode = GameMode.NORMAL&#10;        this.actionHistory.clear()&#10;        this.errorCells = emptySet()&#10;&#10;        // Convert saved grid to SudokuCell array&#10;        this.grid = Array(9) { row -&gt;&#10;            Array(9) { col -&gt;&#10;                val saved = savedState.grid[row][col]&#10;                SudokuCell(&#10;                    value = saved.value,&#10;                    notes = saved.notes.toSet(),&#10;                    isOriginal = saved.isOriginal,&#10;                    hasError = saved.hasError&#10;                )&#10;            }&#10;        }&#10;&#10;        // Convert solution grid&#10;        this.solutionGrid = Array(9) { row -&gt;&#10;            IntArray(9) { col -&gt;&#10;                savedState.solutionGrid[row][col]&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Autofill all valid notes for empty cells&#10;     */&#10;    fun autofillNotes() {&#10;        val newGrid = Array(9) { r -&gt; Array(9) { c -&gt; grid[r][c] } }&#10;        val affectedCells = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val oldNotes = mutableListOf&lt;Set&lt;Int&gt;&gt;()&#10;&#10;        for (row in 0..8) {&#10;            for (col in 0..8) {&#10;                val cell = grid[row][col]&#10;                if (cell.isEmpty &amp;&amp; !cell.isOriginal) {&#10;                    val validNotes = getValidNotesForCell(row, col)&#10;                    if (validNotes != cell.notes) {&#10;                        affectedCells.add(Pair(row, col))&#10;                        oldNotes.add(cell.notes)&#10;                        newGrid[row][col] = cell.copy(notes = validNotes)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Only update grid and add to history if there were changes&#10;        if (affectedCells.isNotEmpty()) {&#10;            // Create action for undo&#10;            val action = GameAction.AutofillNotes(affectedCells, oldNotes)&#10;            actionHistory.push(action)&#10;            grid = newGrid&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all valid notes for a cell based on current grid state&#10;     */&#10;    private fun getValidNotesForCell(row: Int, col: Int): Set&lt;Int&gt; {&#10;        val validNotes = mutableSetOf&lt;Int&gt;()&#10;&#10;        for (number in 1..9) {&#10;            if (isValidPlacement(row, col, number)) {&#10;                validNotes.add(number)&#10;            }&#10;        }&#10;&#10;        return validNotes&#10;    }&#10;&#10;    /**&#10;     * Check if placing a number at the given position would be valid&#10;     */&#10;    private fun isValidPlacement(row: Int, col: Int, number: Int): Boolean {&#10;        // Check row&#10;        for (c in 0..8) {&#10;            if (grid[row][c].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check column&#10;        for (r in 0..8) {&#10;            if (grid[r][col].value == number) {&#10;                return false&#10;            }&#10;        }&#10;&#10;        // Check 3x3 box&#10;        val boxRow = (row / 3) * 3&#10;        val boxCol = (col / 3) * 3&#10;        for (r in boxRow until boxRow + 3) {&#10;            for (c in boxCol until boxCol + 3) {&#10;                if (grid[r][c].value == number) {&#10;                    return false&#10;                }&#10;            }&#10;        }&#10;&#10;        return true&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameStateManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/GameStateManager.kt" />
              <option name="originalContent" value="/**&#10; * Global game state manager&#10; * Provides a singleton instance of GameState that can be shared across screens&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import android.content.Context&#10;import com.kooshmeen.sudoku.utils.GameStatePersistence&#10;&#10;object GameStateManager {&#10;    private val _gameState = GameState()&#10;&#10;    val gameState: GameState get() = _gameState&#10;&#10;    /**&#10;     * Check if there's an active game that can be continued&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return _gameState.hasActiveGame()&#10;    }&#10;&#10;    /**&#10;     * Check if there's a saved game that can be loaded&#10;     */&#10;    fun hasSavedGame(context: Context): Boolean {&#10;        return GameStatePersistence.loadGameState(context) != null&#10;    }&#10;&#10;    /**&#10;     * Load saved game&#10;     */&#10;    fun loadSavedGame(context: Context): Boolean {&#10;        val savedState = GameStatePersistence.loadGameState(context) ?: return false&#10;        _gameState.loadFromSavedState(savedState)&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Save current game&#10;     */&#10;    fun saveCurrentGame(context: Context) {&#10;        GameStatePersistence.saveGameState(context, _gameState)&#10;    }&#10;&#10;    /**&#10;     * Start a new game with the specified difficulty&#10;     */&#10;    fun startNewGame(difficulty: String, context: Context? = null) {&#10;        context?.let { GameStatePersistence.clearSavedGame(it) }&#10;        _gameState.startNewGame(difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue the current active game&#10;     */&#10;    fun continueGame() {&#10;        _gameState.continueGame()&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        _gameState.endGame()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Global game state manager&#10; * Provides a singleton instance of GameState that can be shared across screens&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;import android.content.Context&#10;import com.kooshmeen.sudoku.utils.GameStatePersistence&#10;&#10;object GameStateManager {&#10;    private val _gameState = GameState()&#10;&#10;    val gameState: GameState get() = _gameState&#10;&#10;    /**&#10;     * Check if there's an active game that can be continued&#10;     */&#10;    fun hasActiveGame(): Boolean {&#10;        return _gameState.hasActiveGame()&#10;    }&#10;&#10;    /**&#10;     * Check if there's a saved game that can be loaded&#10;     */&#10;    fun hasSavedGame(context: Context): Boolean {&#10;        return GameStatePersistence.loadGameState(context) != null&#10;    }&#10;&#10;    /**&#10;     * Load saved game&#10;     */&#10;    fun loadSavedGame(context: Context): Boolean {&#10;        val savedState = GameStatePersistence.loadGameState(context) ?: return false&#10;        _gameState.loadFromSavedState(savedState)&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Save current game&#10;     */&#10;    fun saveCurrentGame(context: Context) {&#10;        GameStatePersistence.saveGameState(context, _gameState)&#10;    }&#10;&#10;    /**&#10;     * Start a new game with the specified difficulty&#10;     */&#10;    fun startNewGame(difficulty: String, context: Context? = null) {&#10;        context?.let { GameStatePersistence.clearSavedGame(it) }&#10;        _gameState.startNewGame(difficulty)&#10;    }&#10;&#10;    /**&#10;     * Load a challenge game with specific puzzle data&#10;     */&#10;    fun loadChallengeGame(puzzleData: Map&lt;*, *&gt;, difficulty: String, context: Context? = null) {&#10;        context?.let { GameStatePersistence.clearSavedGame(it) }&#10;        _gameState.loadChallengeGame(puzzleData, difficulty)&#10;    }&#10;&#10;    /**&#10;     * Continue the current active game&#10;     */&#10;    fun continueGame() {&#10;        _gameState.continueGame()&#10;    }&#10;&#10;    /**&#10;     * End the current game&#10;     */&#10;    fun endGame() {&#10;        _gameState.endGame()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/data/SavedGameState.kt" />
              <option name="updatedContent" value="/**&#10; * Data class representing the serializable game state&#10; * Used for saving/loading games from SharedPreferences&#10; */&#10;&#10;package com.kooshmeen.sudoku.data&#10;&#10;data class SavedGameState(&#10;    val grid: List&lt;List&lt;SavedCellState&gt;&gt;,&#10;    val difficulty: String,&#10;    val elapsedTimeSeconds: Int,&#10;    val mistakesCount: Int,&#10;    val solutionGrid: List&lt;List&lt;Int&gt;&gt;&#10;)&#10;&#10;data class SavedCellState(&#10;    val value: Int,&#10;    val notes: List&lt;Int&gt;,&#10;    val isOriginal: Boolean,&#10;    val hasError: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/repository/SudokuRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/repository/SudokuRepository.kt" />
              <option name="originalContent" value="package com.kooshmeen.sudoku.repository&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.kooshmeen.sudoku.api.ApiClient&#10;import com.kooshmeen.sudoku.data.api.*&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;&#10;class SudokuRepository(private val context: Context) {&#10;    private val apiService = ApiClient.apiService&#10;    private val prefs = context.getSharedPreferences(&quot;sudoku_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    private var authToken: String?&#10;        get() = prefs.getString(&quot;auth_token&quot;, null)&#10;        set(value) = prefs.edit().putString(&quot;auth_token&quot;, value).apply()&#10;&#10;    private var currentUser: User?&#10;        get() {&#10;            val id = prefs.getInt(&quot;user_id&quot;, -1)&#10;            val username = prefs.getString(&quot;user_username&quot;, null)&#10;            val email = prefs.getString(&quot;user_email&quot;, null)&#10;            return if (id != -1 &amp;&amp; username != null &amp;&amp; email != null) {&#10;                User(id, username, email)&#10;            } else null&#10;        }&#10;        set(value) {&#10;            if (value != null) {&#10;                prefs.edit().apply {&#10;                    putInt(&quot;user_id&quot;, value.id)&#10;                    putString(&quot;user_username&quot;, value.username)&#10;                    putString(&quot;user_email&quot;, value.email)&#10;                    apply()&#10;                }&#10;            } else {&#10;                prefs.edit().apply {&#10;                    remove(&quot;user_id&quot;)&#10;                    remove(&quot;user_username&quot;)&#10;                    remove(&quot;user_email&quot;)&#10;                    apply()&#10;                }&#10;            }&#10;        }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;LoginResponse&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val loginResponse = response.body()!!&#10;                authToken = loginResponse.token&#10;                currentUser = loginResponse.user&#10;                Result.success(loginResponse)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registration failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun submitGame(difficulty: String, timeSeconds: Int, mistakes: Int): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.submitGame(&#10;                &quot;Bearer $token&quot;,&#10;                GameSubmission(timeSeconds, difficulty.lowercase(), mistakes)&#10;            )&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to submit game&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Leaderboard methods&#10;    suspend fun getLeaderboardTotal(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalAllTime()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardMonth(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalMonth()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load monthly leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardWeek(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalWeek()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load weekly leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardDay(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalDay()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load daily leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun isLoggedIn(): Boolean = authToken != null&#10;&#10;    fun fetchCurrentUser(): User? = currentUser&#10;&#10;    fun logout() {&#10;        authToken = null&#10;        currentUser = null&#10;    }&#10;&#10;    // Group Management Methods&#10;    suspend fun getAllGroups(): Result&lt;List&lt;GroupData&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getAllGroups()&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupsResponse -&gt;&#10;                        Result.success(groupsResponse.groups)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load groups: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun searchGroups(query: String): Result&lt;List&lt;GroupData&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.searchGroups(query)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupsResponse -&gt;&#10;                        Result.success(groupsResponse.groups)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to search groups: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getMyGroups(): Result&lt;List&lt;GroupData&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getMyGroups(&quot;Bearer $token&quot;)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupsResponse -&gt;&#10;                        Result.success(groupsResponse.groups)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load my groups: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun createGroup(groupName: String, description: String?, password: String?): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                // Create a map to send only the necessary data to the server&#10;                val groupRequest = mutableMapOf&lt;String, Any?&gt;(&#10;                    &quot;group_name&quot; to groupName,&#10;                    &quot;group_description&quot; to description&#10;                )&#10;                if (password != null) {&#10;                    groupRequest[&quot;group_password&quot;] = password&#10;                }&#10;&#10;                val response = apiService.createGroup(&quot;Bearer $token&quot;, groupRequest)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to create group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun joinGroup(groupId: Int, password: String?): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = if (password != null) {&#10;                    apiService.joinGroupWithPassword(&quot;Bearer $token&quot;, groupId, mapOf(&quot;password&quot; to password))&#10;                } else {&#10;                    apiService.joinGroup(&quot;Bearer $token&quot;, groupId)&#10;                }&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to join group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun leaveGroup(groupId: Int): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.leaveGroup(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to leave group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun deleteGroup(groupId: Int): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.deleteGroup(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to delete group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getGroupDetails(groupId: Int): Result&lt;GroupData&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getGroupDetails(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load group details: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getGroupLeaderboard(groupId: Int): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getGroupLeaderboard(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load group leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getGroupMembers(groupId: Int): Result&lt;List&lt;GroupMember&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getGroupMembers(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupMembersResponse -&gt;&#10;                        Result.success(groupMembersResponse.members)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load group members: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a challenge invitation with type&#10;     */&#10;    suspend fun createChallenge(&#10;        groupId: Int,&#10;        challengedId: Int,&#10;        difficulty: String,&#10;        challengeType: String&#10;    ): Result&lt;ChallengeCreationResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val request = CreateChallengeRequest(challengedId, difficulty, challengeType)&#10;            val response = apiService.createChallenge(&quot;Bearer $token&quot;, groupId, request)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to create challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reject a challenge invitation&#10;     */&#10;    suspend fun rejectChallenge(challengeId: Int): Result&lt;String&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.rejectChallenge(&quot;Bearer $token&quot;, challengeId)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()?.message ?: &quot;Challenge rejected&quot;)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to reject challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Complete challenger's game for offline challenges&#10;     */&#10;    suspend fun completeChallengerGame(&#10;        challengeId: Int,&#10;        timeSeconds: Int,&#10;        numberOfMistakes: Int&#10;    ): Result&lt;String&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val request = ChallengeCompletionRequest(timeSeconds, numberOfMistakes)&#10;            val response = apiService.completeChallengerGame(&quot;Bearer $token&quot;, challengeId, request)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()?.message ?: &quot;Game completed&quot;)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to complete game: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get pending challenges for current user&#10;     */&#10;    suspend fun getPendingChallenges(): Result&lt;List&lt;ChallengeInvitation&gt;&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.getPendingChallenges(&quot;Bearer $token&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val challenges = response.body()?.challenges ?: emptyList()&#10;                Result.success(challenges)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to get challenges: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Accept a challenge invitation&#10;     */&#10;    suspend fun acceptChallenge(challengeId: Int): Result&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.acceptChallenge(&quot;Bearer $token&quot;, challengeId)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body() ?: emptyMap())&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to accept challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Complete a challenge&#10;     */&#10;    suspend fun completeChallenge(&#10;        challengeId: Int,&#10;        timeSeconds: Int,&#10;        numberOfMistakes: Int&#10;    ): Result&lt;ChallengeCompletionResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val request = ChallengeCompletionRequest(timeSeconds, numberOfMistakes)&#10;            val response = apiService.completeChallenge(&quot;Bearer $token&quot;, challengeId, request)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to complete challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.repository&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.kooshmeen.sudoku.api.ApiClient&#10;import com.kooshmeen.sudoku.data.api.*&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;&#10;class SudokuRepository(private val context: Context) {&#10;    private val apiService = ApiClient.apiService&#10;    private val prefs = context.getSharedPreferences(&quot;sudoku_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    private var authToken: String?&#10;        get() = prefs.getString(&quot;auth_token&quot;, null)&#10;        set(value) = prefs.edit().putString(&quot;auth_token&quot;, value).apply()&#10;&#10;    private var currentUser: User?&#10;        get() {&#10;            val id = prefs.getInt(&quot;user_id&quot;, -1)&#10;            val username = prefs.getString(&quot;user_username&quot;, null)&#10;            val email = prefs.getString(&quot;user_email&quot;, null)&#10;            return if (id != -1 &amp;&amp; username != null &amp;&amp; email != null) {&#10;                User(id, username, email)&#10;            } else null&#10;        }&#10;        set(value) {&#10;            if (value != null) {&#10;                prefs.edit().apply {&#10;                    putInt(&quot;user_id&quot;, value.id)&#10;                    putString(&quot;user_username&quot;, value.username)&#10;                    putString(&quot;user_email&quot;, value.email)&#10;                    apply()&#10;                }&#10;            } else {&#10;                prefs.edit().apply {&#10;                    remove(&quot;user_id&quot;)&#10;                    remove(&quot;user_username&quot;)&#10;                    remove(&quot;user_email&quot;)&#10;                    apply()&#10;                }&#10;            }&#10;        }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;LoginResponse&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val loginResponse = response.body()!!&#10;                authToken = loginResponse.token&#10;                currentUser = loginResponse.user&#10;                Result.success(loginResponse)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registration failed&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun submitGame(difficulty: String, timeSeconds: Int, mistakes: Int): Result&lt;ApiResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.submitGame(&#10;                &quot;Bearer $token&quot;,&#10;                GameSubmission(timeSeconds, difficulty.lowercase(), mistakes)&#10;            )&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to submit game&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Leaderboard methods&#10;    suspend fun getLeaderboardTotal(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalAllTime()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardMonth(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalMonth()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load monthly leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardWeek(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalWeek()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load weekly leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboardDay(): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getTop100GlobalDay()&#10;&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load daily leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun isLoggedIn(): Boolean = authToken != null&#10;&#10;    fun fetchCurrentUser(): User? = currentUser&#10;&#10;    fun logout() {&#10;        authToken = null&#10;        currentUser = null&#10;    }&#10;&#10;    // Group Management Methods&#10;    suspend fun getAllGroups(): Result&lt;List&lt;GroupData&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.getAllGroups()&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupsResponse -&gt;&#10;                        Result.success(groupsResponse.groups)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load groups: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun searchGroups(query: String): Result&lt;List&lt;GroupData&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = apiService.searchGroups(query)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupsResponse -&gt;&#10;                        Result.success(groupsResponse.groups)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to search groups: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getMyGroups(): Result&lt;List&lt;GroupData&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getMyGroups(&quot;Bearer $token&quot;)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupsResponse -&gt;&#10;                        Result.success(groupsResponse.groups)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load my groups: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun createGroup(groupName: String, description: String?, password: String?): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                // Create a map to send only the necessary data to the server&#10;                val groupRequest = mutableMapOf&lt;String, Any?&gt;(&#10;                    &quot;group_name&quot; to groupName,&#10;                    &quot;group_description&quot; to description&#10;                )&#10;                if (password != null) {&#10;                    groupRequest[&quot;group_password&quot;] = password&#10;                }&#10;&#10;                val response = apiService.createGroup(&quot;Bearer $token&quot;, groupRequest)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to create group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun joinGroup(groupId: Int, password: String?): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = if (password != null) {&#10;                    apiService.joinGroupWithPassword(&quot;Bearer $token&quot;, groupId, mapOf(&quot;password&quot; to password))&#10;                } else {&#10;                    apiService.joinGroup(&quot;Bearer $token&quot;, groupId)&#10;                }&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to join group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun leaveGroup(groupId: Int): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.leaveGroup(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to leave group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun deleteGroup(groupId: Int): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.deleteGroup(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to delete group: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getGroupDetails(groupId: Int): Result&lt;GroupData&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getGroupDetails(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load group details: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getGroupLeaderboard(groupId: Int): Result&lt;LeaderboardResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getGroupLeaderboard(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { Result.success(it) }&#10;                        ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load group leaderboard: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getGroupMembers(groupId: Int): Result&lt;List&lt;GroupMember&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val token = authToken ?: return@withContext Result.failure(Exception(&quot;Not logged in&quot;))&#10;                val response = apiService.getGroupMembers(&quot;Bearer $token&quot;, groupId)&#10;                if (response.isSuccessful) {&#10;                    response.body()?.let { groupMembersResponse -&gt;&#10;                        Result.success(groupMembersResponse.members)&#10;                    } ?: Result.failure(Exception(&quot;Empty response&quot;))&#10;                } else {&#10;                    Result.failure(Exception(&quot;Failed to load group members: ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create a challenge invitation with type&#10;     */&#10;    suspend fun createChallenge(&#10;        groupId: Int,&#10;        challengedId: Int,&#10;        difficulty: String,&#10;        challengeType: String&#10;    ): Result&lt;ChallengeCreationResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val request = CreateChallengeRequest(challengedId, difficulty, challengeType)&#10;            val response = apiService.createChallenge(&quot;Bearer $token&quot;, groupId, request)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to create challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reject a challenge invitation&#10;     */&#10;    suspend fun rejectChallenge(challengeId: Int): Result&lt;String&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.rejectChallenge(&quot;Bearer $token&quot;, challengeId)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()?.message ?: &quot;Challenge rejected&quot;)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to reject challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Complete challenger's game for offline challenges&#10;     */&#10;    suspend fun completeChallengerGame(&#10;        challengeId: Int,&#10;        timeSeconds: Int,&#10;        numberOfMistakes: Int,&#10;        puzzleData: Map&lt;String, Any&gt;? = null&#10;    ): Result&lt;String&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val requestBody = mutableMapOf&lt;String, Any&gt;(&#10;                &quot;timeSeconds&quot; to timeSeconds,&#10;                &quot;numberOfMistakes&quot; to numberOfMistakes&#10;            )&#10;&#10;            // Add puzzle data if provided (for offline challenges)&#10;            puzzleData?.let { data -&gt;&#10;                requestBody[&quot;puzzleData&quot;] = data&#10;            }&#10;&#10;            val response = apiService.completeChallengerGame(&quot;Bearer $token&quot;, challengeId, requestBody)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()?.message ?: &quot;Game completed&quot;)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to complete game: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get pending challenges for current user&#10;     */&#10;    suspend fun getPendingChallenges(): Result&lt;List&lt;ChallengeInvitation&gt;&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.getPendingChallenges(&quot;Bearer $token&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val challenges = response.body()?.challenges ?: emptyList()&#10;                Result.success(challenges)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to get challenges: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Accept a challenge invitation&#10;     */&#10;    suspend fun acceptChallenge(challengeId: Int): Result&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.acceptChallenge(&quot;Bearer $token&quot;, challengeId)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body() ?: emptyMap())&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to accept challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Complete a challenge&#10;     */&#10;    suspend fun completeChallenge(&#10;        challengeId: Int,&#10;        timeSeconds: Int,&#10;        numberOfMistakes: Int&#10;    ): Result&lt;ChallengeCompletionResponse&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val request = ChallengeCompletionRequest(timeSeconds, numberOfMistakes)&#10;            val response = apiService.completeChallenge(&quot;Bearer $token&quot;, challengeId, request)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to complete challenge: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get challenge data including puzzle information&#10;     */&#10;    suspend fun getChallengeData(challengeId: Int): Result&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            val token = authToken ?: return Result.failure(Exception(&quot;Not authenticated&quot;))&#10;            val response = apiService.acceptChallenge(&quot;Bearer $token&quot;, challengeId)&#10;&#10;            if (response.isSuccessful) {&#10;                Result.success(response.body() ?: emptyMap())&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to get challenge data: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/UtilityRow.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/components/UtilityRow.kt" />
              <option name="originalContent" value="/**&#10; * UtilityRow.kt&#10; * This file defines a composable function for displaying a row of utility buttons in the Sudoku app.&#10; * These buttons are, from left to right:&#10; * Erase: selecting it will enable erasing mode, clearing non-starting cells when clicked.&#10; * Notes: selecting it will toggle notes mode, allowing users to add notes to cells.&#10; * Undo: selecting it will undo the last action.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.kooshmeen.sudoku.R&#10;&#10;@Composable&#10;fun UtilityRow(&#10;    modifier: Modifier = Modifier,&#10;    selectedButton: String? = null,&#10;    onEraseClick: () -&gt; Unit = {},&#10;    onNotesClick: () -&gt; Unit = {},&#10;    onUndoClick: () -&gt; Unit = {}&#10;        horizontalArrangement = androidx.compose.foundation.layout.Arrangement.SpaceEvenly,&#10;        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically&#10;    ) {&#10;        // Erase Button&#10;        }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview (showBackground = true)&#10;@Composable&#10;fun UtilityRowPreview() {&#10;    UtilityRow(&#10;        selectedButton = null,&#10;        modifier = Modifier.fillMaxSize()&#10;    )&#10;}" />
              <option name="updatedContent" value="/**&#10; * UtilityRow.kt&#10; * This file defines a composable function for displaying a row of utility buttons in the Sudoku app.&#10; * These buttons are, from left to right:&#10; * Erase: selecting it will enable erasing mode, clearing non-starting cells when clicked.&#10; * Notes: selecting it will toggle notes mode, allowing users to add notes to cells.&#10; * Undo: selecting it will undo the last action.&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.components&#10;&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconToggleButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.kooshmeen.sudoku.R&#10;&#10;@Composable&#10;fun UtilityRow(&#10;    modifier: Modifier = Modifier,&#10;    selectedButton: String? = null,&#10;    onEraseClick: () -&gt; Unit = {},&#10;    onNotesClick: () -&gt; Unit = {},&#10;    onUndoClick: () -&gt; Unit = {},&#10;    onAutofillNotesClick: () -&gt; Unit = {}&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        horizontalArrangement = androidx.compose.foundation.layout.Arrangement.SpaceEvenly,&#10;        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically&#10;    ) {&#10;        // Autofill Notes Button&#10;        IconButton(&#10;            onClick = onAutofillNotesClick,&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.add_notes_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Autofill Notes&quot;,&#10;                tint = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        // Erase Button&#10;        IconToggleButton(&#10;            checked = selectedButton == &quot;erase&quot;,&#10;            onCheckedChange = { onEraseClick() }, // Always call onEraseClick, let GameState handle toggle&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.ink_eraser_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Erase&quot;,&#10;                tint = if (selectedButton == &quot;erase&quot;) MaterialTheme.colorScheme.primary&#10;                else MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        // Notes Button&#10;        IconToggleButton(&#10;            checked = selectedButton == &quot;notes&quot;,&#10;            onCheckedChange = { onNotesClick() }, // Always call onNotesClick, let GameState handle toggle&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.add_notes_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Notes&quot;,&#10;                tint = if (selectedButton == &quot;notes&quot;) MaterialTheme.colorScheme.primary&#10;                else MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        // Undo Button&#10;        IconButton(&#10;            onClick = onUndoClick,&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Icon (&#10;                painter = painterResource(id = R.drawable.undo_24dp_e3e3e3_fill0_wght400_grad0_opsz24),&#10;                contentDescription = &quot;Undo&quot;,&#10;                tint = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview (showBackground = true)&#10;@Composable&#10;fun UtilityRowPreview() {&#10;    UtilityRow(&#10;        selectedButton = null,&#10;        modifier = Modifier.fillMaxSize()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/AuthScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/AuthScreen.kt" />
              <option name="updatedContent" value="/**&#10; * Authentication screen for login and registration&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun AuthScreen(&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    onLoginSuccess: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var isLoginMode by remember { mutableStateOf(true) }&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var username by remember { mutableStateOf(&quot;&quot;) }&#10;    var confirmPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;    var confirmPasswordVisible by remember { mutableStateOf(false) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var successMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header with back button&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = onNavigateBack) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        // Title&#10;        Text(&#10;            text = if (isLoginMode) &quot;Login&quot; else &quot;Register&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onBackground,&#10;            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        // Username field (only for registration)&#10;        if (!isLoginMode) {&#10;            OutlinedTextField(&#10;                value = username,&#10;                onValueChange = { username = it },&#10;                label = { Text(&quot;Username&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;&#10;        // Email field&#10;        OutlinedTextField(&#10;            value = email,&#10;            onValueChange = { email = it },&#10;            label = { Text(&quot;Email&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true,&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),&#10;            enabled = !isLoading&#10;        )&#10;&#10;        // Password field&#10;        OutlinedTextField(&#10;            value = password,&#10;            onValueChange = { password = it },&#10;            label = { Text(&quot;Password&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true,&#10;            visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;            trailingIcon = {&#10;                IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                    Icon(&#10;                        imageVector = if (passwordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                        contentDescription = if (passwordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                    )&#10;                }&#10;            },&#10;            enabled = !isLoading&#10;        )&#10;&#10;        // Confirm password field (only for registration)&#10;        if (!isLoginMode) {&#10;            OutlinedTextField(&#10;                value = confirmPassword,&#10;                onValueChange = { confirmPassword = it },&#10;                label = { Text(&quot;Confirm Password&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                visualTransformation = if (confirmPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;                trailingIcon = {&#10;                    IconButton(onClick = { confirmPasswordVisible = !confirmPasswordVisible }) {&#10;                        Icon(&#10;                            imageVector = if (confirmPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                            contentDescription = if (confirmPasswordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                        )&#10;                    }&#10;                },&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;&#10;        // Error message&#10;        errorMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = message,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Success message&#10;        successMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = message,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Submit button&#10;        Button(&#10;            onClick = {&#10;                errorMessage = null&#10;                successMessage = null&#10;&#10;                // Validation&#10;                if (email.isBlank() || password.isBlank()) {&#10;                    errorMessage = &quot;Please fill in all fields&quot;&#10;                    return@Button&#10;                }&#10;&#10;                if (!isLoginMode) {&#10;                    if (username.isBlank()) {&#10;                        errorMessage = &quot;Please enter a username&quot;&#10;                        return@Button&#10;                    }&#10;                    if (password != confirmPassword) {&#10;                        errorMessage = &quot;Passwords do not match&quot;&#10;                        return@Button&#10;                    }&#10;                    if (password.length &lt; 6) {&#10;                        errorMessage = &quot;Password must be at least 6 characters&quot;&#10;                        return@Button&#10;                    }&#10;                }&#10;&#10;                isLoading = true&#10;                scope.launch {&#10;                    try {&#10;                        if (isLoginMode) {&#10;                            val result = repository.login(email, password)&#10;                            if (result.isSuccess) {&#10;                                onLoginSuccess()&#10;                            } else {&#10;                                errorMessage = result.exceptionOrNull()?.message ?: &quot;Login failed&quot;&#10;                            }&#10;                        } else {&#10;                            val result = repository.register(username, email, password)&#10;                            if (result.isSuccess) {&#10;                                successMessage = &quot;Registration successful! Please login.&quot;&#10;                                isLoginMode = true&#10;                                // Clear fields&#10;                                username = &quot;&quot;&#10;                                password = &quot;&quot;&#10;                                confirmPassword = &quot;&quot;&#10;                            } else {&#10;                                errorMessage = result.exceptionOrNull()?.message ?: &quot;Registration failed&quot;&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        errorMessage = e.message ?: &quot;An error occurred&quot;&#10;                    } finally {&#10;                        isLoading = false&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            enabled = !isLoading&#10;        ) {&#10;            if (isLoading) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(20.dp),&#10;                    color = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            } else {&#10;                Text(if (isLoginMode) &quot;Login&quot; else &quot;Register&quot;)&#10;            }&#10;        }&#10;&#10;        // Toggle mode button&#10;        TextButton(&#10;            onClick = {&#10;                isLoginMode = !isLoginMode&#10;                errorMessage = null&#10;                successMessage = null&#10;            },&#10;            modifier = Modifier.align(Alignment.CenterHorizontally),&#10;            enabled = !isLoading&#10;        ) {&#10;            Text(&#10;                if (isLoginMode) &quot;Don't have an account? Register&quot; else &quot;Already have an account? Login&quot;&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AuthScreenPreview() {&#10;    SudokuTheme {&#10;        AuthScreen()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GameScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GameScreen.kt" />
              <option name="originalContent" value="/**&#10; * Game Screen for the Sudoku Game&#10; * This screen displays the Sudoku grid and allows users to play the game.&#10; * Includes a timer from the start of the game, a difficulty indicator,&#10; * a back button to return to the main menu, and a pause button - which pauses the timer&#10; * and covers the grid.&#10; *&#10; * The grid is displayed using a SudokuGrid composable, and the input numbers are handled by an InputRow composable.&#10; * Below is a UtilityRow composable.&#10;*/&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Accessibility&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.GameState&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.components.InputRow&#10;import com.kooshmeen.sudoku.ui.components.SudokuGrid&#10;import com.kooshmeen.sudoku.ui.components.UtilityRow&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun GameScreen(&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToMenu: () -&gt; Unit = { /* Default no-op */ },&#10;    challengeId: Int? = null, // Optional challenge ID for challenges mode&#10;    difficulty: String? = null // Optional difficulty override for challenges&#10;) {&#10;    val gameState = GameStateManager.gameState&#10;    var showCompletionDialog by remember { mutableStateOf(false) }&#10;&#10;    var opponentTime by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;    var isChallenge by remember { mutableStateOf(challengeId != null) }&#10;    var challengeData by remember { mutableStateOf&lt;Map&lt;String, Any&gt;?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load challenge data if this is a challenge game&#10;    LaunchedEffect(challengeId, difficulty) {&#10;        challengeId?.let { id -&gt;&#10;            isChallenge = true&#10;            // For offline challenges, the challenger starts immediately with a new puzzle&#10;            // No need to &quot;accept&quot; the challenge as they created it&#10;            difficulty?.let { diff -&gt;&#10;                // Start a new game with the specified difficulty for the challenge&#10;                GameStateManager.startNewGame(diff, context)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timer effect - only run when game is active and not paused&#10;    LaunchedEffect(gameState.isGameActive, gameState.isPaused) {&#10;        while (gameState.isGameActive &amp;&amp; !gameState.isPaused) {&#10;            delay(1000)&#10;            gameState.updateTimer()&#10;        }&#10;    }&#10;&#10;    // Check for game completion&#10;    LaunchedEffect(gameState.isGameCompleted) {&#10;        if (gameState.isGameCompleted) {&#10;            showCompletionDialog = true&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(12.dp)&#10;            .background(MaterialTheme.colorScheme.background) // Use MaterialTheme for background color&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // Timer&#10;            Text(&#10;                text = &quot;Elapsed: ${gameState.getFormattedTime()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;&#10;            // If in challenge mode, show opponent's time&#10;&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the difficulty indicator to the end&#10;            // Difficulty indicator&#10;            Text(&#10;                text = gameState.difficulty,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 32.dp)&#10;            )&#10;        }&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // back to menu button&#10;            IconButton(&#10;                onClick = onNavigateToMenu,&#10;                modifier = Modifier.padding(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back to Main Menu&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground // Use MaterialTheme for icon color&#10;                )&#10;            }&#10;&#10;            if (isChallenge &amp;&amp; opponentTime != null) {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Accessibility,&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = formatTime(opponentTime!!),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = &quot;Opponent&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the pause button to the end&#10;            // Pause button - will pause timer, but cover the grid&#10;            IconButton(&#10;                onClick = { gameState.togglePause() },&#10;                modifier = Modifier.padding(8.dp),&#10;                // align the icon to the end of the row&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Lock,&#10;                    contentDescription = &quot;Pause Game&quot;,&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        // Display number of mistakes and highest possible score&#10;        Row (&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Mistakes: ${gameState.mistakesCount}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;            Spacer(Modifier.weight(1f)) // Push the highest possible score to the end&#10;            Text(&#10;                text = &quot;Max Score: ${gameState.highestPossibleScore()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(end = 8.dp)&#10;            )&#10;        }&#10;&#10;        Spacer(Modifier.height(14.dp))&#10;        // Grid - show overlay when paused&#10;        Box(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            SudokuGrid(&#10;                grid = gameState.grid,&#10;                selectedCell = null,&#10;                selectedNumber = gameState.selectedNumber, // Pass selectedNumber&#10;                onCellClick = { row, col -&gt;&#10;                    gameState.inputToCell(row, col)&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Pause overlay&#10;            if (gameState.isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 1f)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Paused&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Compute which numbers are disabled (already filled in all spots)&#10;        val numberCounts = IntArray(9) { 0 }&#10;        for (row in gameState.grid) {&#10;            for (cell in row) {&#10;                if (cell.value in 1..9) {&#10;                    numberCounts[cell.value - 1]++&#10;                }&#10;            }&#10;        }&#10;        val disabledNumbers = numberCounts.mapIndexed { idx, count -&gt; if (count &gt;= 9) idx + 1 else null }.filterNotNull()&#10;&#10;        // Input numbers row&#10;        InputRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            input = List(9) { it + 1 },&#10;            onInputChange = { index, value -&gt;&#10;                val number = value.toInt()&#10;                if (!disabledNumbers.contains(number)) {&#10;                    gameState.selectNumber(number)&#10;                }&#10;            },&#10;            selectedNumber = gameState.selectedNumber,&#10;            disabledNumbers = disabledNumbers // Pass disabled numbers&#10;        )&#10;        Spacer(Modifier.height(24.dp))&#10;        // Utility Row&#10;        UtilityRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            selectedButton = when (gameState.gameMode) {&#10;                GameState.GameMode.NOTES -&gt; &quot;notes&quot;&#10;                GameState.GameMode.ERASE -&gt; &quot;erase&quot;&#10;                else -&gt; null&#10;            },&#10;            onEraseClick = { gameState.toggleEraseMode() },&#10;            onNotesClick = { gameState.toggleNotesMode() },&#10;            onUndoClick = { gameState.undo() },&#10;            onAutofillNotesClick = { gameState.autofillNotes() }&#10;        )&#10;&#10;        // Completion Dialog&#10;        if (showCompletionDialog) {&#10;            // Check for new best time&#10;            val (isNewBest, isNewBestNoMistakes) = BestTimeManager.setBestTime(&#10;                context = LocalContext.current,&#10;                difficulty = gameState.difficulty,&#10;                time = gameState.getFormattedTime(),&#10;                numMistakes = gameState.mistakesCount,&#10;            )&#10;&#10;            val context = LocalContext.current&#10;&#10;            LaunchedEffect(Unit) {&#10;                // Initialize repository if not done&#10;                gameState.initializeRepository(context)&#10;&#10;                // Record game completion in local statistics&#10;                gameState.recordGameCompletion(context)&#10;&#10;                // Try to submit score&#10;                val submitted = gameState.submitScoreToServer()&#10;                if (!submitted) { // off line mode or not connected to server&#10;                    // Show a toast or some indication that score submission failed&#10;                    // Toast.makeText(context, &quot;Score submission failed. Please try again later.&quot;, Toast.LENGTH_SHORT).show()&#10;                    // For now, we will just log it&#10;                    println(&quot;Score submission failed. Please try again later.&quot;)&#10;                }&#10;&#10;                // challenge - handle offline challenges differently&#10;                if (isChallenge &amp;&amp; challengeId != null) {&#10;                    // For offline challenges, the challenger uses a different endpoint&#10;                    val challengeResult = repository.completeChallengerGame(&#10;                        challengeId = challengeId,&#10;                        timeSeconds = gameState.elapsedTimeSeconds,&#10;                        numberOfMistakes = gameState.mistakesCount&#10;                    )&#10;                    challengeResult.fold(&#10;                        onSuccess = {&#10;                            // Successfully submitted challenger's game completion&#10;                            println(&quot;Challenger game completed successfully.&quot;)&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            // Handle error submitting challenger's game&#10;                            println(&quot;Error submitting challenger game: ${exception.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            GameStateManager.endGame()&#10;            AlertDialog(&#10;                onDismissRequest = {&#10;                    showCompletionDialog = false&#10;                    GameStateManager.endGame()&#10;                },&#10;                title = { Text(&quot;Congratulations! Final score: ${gameState.highestPossibleScore()}&quot;) },&#10;                text = {&#10;                    if (isNewBest) {&#10;                        Text(&quot;You completed the game in a new best time for ${gameState.difficulty}: ${gameState.getFormattedTime()}!&quot;)&#10;                    } else {&#10;                        Text(&quot;You completed the game in ${gameState.getFormattedTime()}! Your best time for ${gameState.difficulty} is ${BestTimeManager.getBestTimeFormatted(LocalContext.current, gameState.difficulty)}.&quot;)&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    Button(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                            onNavigateToMenu()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Back to Menu&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Stay Here&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(&quot;%02d:%02d&quot;, minutes, remainingSeconds)&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GameScreenPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        GameScreen(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it },&#10;&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game Screen for the Sudoku Game&#10; * This screen displays the Sudoku grid and allows users to play the game.&#10; * Includes a timer from the start of the game, a difficulty indicator,&#10; * a back button to return to the main menu, and a pause button - which pauses the timer&#10; * and covers the grid.&#10; *&#10; * The grid is displayed using a SudokuGrid composable, and the input numbers are handled by an InputRow composable.&#10; * Below is a UtilityRow composable.&#10;*/&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Accessibility&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.kooshmeen.sudoku.data.GameState&#10;import com.kooshmeen.sudoku.data.GameStateManager&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.components.InputRow&#10;import com.kooshmeen.sudoku.ui.components.SudokuGrid&#10;import com.kooshmeen.sudoku.ui.components.UtilityRow&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import com.kooshmeen.sudoku.utils.BestTimeManager&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun GameScreen(&#10;    modifier: Modifier = Modifier,&#10;    onThemeToggle: (Boolean) -&gt; Unit = { /* Default no-op */ },&#10;    isDarkTheme: Boolean = true, // Default value for dark theme&#10;    onNavigateToMenu: () -&gt; Unit = { /* Default no-op */ },&#10;    challengeId: Int? = null, // Optional challenge ID for challenges mode&#10;    difficulty: String? = null // Optional difficulty override for challenges&#10;) {&#10;    val gameState = GameStateManager.gameState&#10;    var showCompletionDialog by remember { mutableStateOf(false) }&#10;&#10;    var opponentTime by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;    var isChallenge by remember { mutableStateOf(challengeId != null) }&#10;    var challengeData by remember { mutableStateOf&lt;Map&lt;String, Any&gt;?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load challenge data if this is a challenge game&#10;    LaunchedEffect(challengeId, difficulty) {&#10;        challengeId?.let { id -&gt;&#10;            isChallenge = true&#10;            &#10;            // Check if this is accepting an existing challenge (challenged player)&#10;            // or creating a new puzzle for offline challenge (challenger)&#10;            scope.launch {&#10;                val result = repository.getChallengeData(id)&#10;                result.fold(&#10;                    onSuccess = { data -&gt;&#10;                        challengeData = data&#10;                        opponentTime = (data[&quot;challengerTime&quot;] as? Number)?.toInt()&#10;                        &#10;                        // If puzzle data exists, load that specific puzzle&#10;                        val puzzleData = data[&quot;puzzleData&quot;] as? Map&lt;*, *&gt;&#10;                        if (puzzleData != null) {&#10;                            // Load the exact same puzzle the challenger played&#10;                            GameStateManager.loadChallengeGame(puzzleData, difficulty ?: &quot;medium&quot;, context)&#10;                        } else {&#10;                            // This is the challenger creating a new puzzle&#10;                            difficulty?.let { diff -&gt;&#10;                                GameStateManager.startNewGame(diff, context)&#10;                            }&#10;                        }&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        // If no challenge data exists, this is a new challenge being created&#10;                        difficulty?.let { diff -&gt;&#10;                            GameStateManager.startNewGame(diff, context)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timer effect - only run when game is active and not paused&#10;    LaunchedEffect(gameState.isGameActive, gameState.isPaused) {&#10;        while (gameState.isGameActive &amp;&amp; !gameState.isPaused) {&#10;            delay(1000)&#10;            gameState.updateTimer()&#10;        }&#10;    }&#10;&#10;    // Check for game completion&#10;    LaunchedEffect(gameState.isGameCompleted) {&#10;        if (gameState.isGameCompleted) {&#10;            showCompletionDialog = true&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(12.dp)&#10;            .background(MaterialTheme.colorScheme.background) // Use MaterialTheme for background color&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // Timer&#10;            Text(&#10;                text = &quot;Elapsed: ${gameState.getFormattedTime()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;&#10;            // If in challenge mode, show opponent's time&#10;&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the difficulty indicator to the end&#10;            // Difficulty indicator&#10;            Text(&#10;                text = gameState.difficulty,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 32.dp)&#10;            )&#10;        }&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // back to menu button&#10;            IconButton(&#10;                onClick = onNavigateToMenu,&#10;                modifier = Modifier.padding(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Back to Main Menu&quot;,&#10;                    tint = MaterialTheme.colorScheme.onBackground // Use MaterialTheme for icon color&#10;                )&#10;            }&#10;&#10;            if (isChallenge &amp;&amp; opponentTime != null) {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Accessibility,&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = formatTime(opponentTime!!),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.secondary&#10;                    )&#10;                    Text(&#10;                        text = &quot;Opponent&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f)) // Push the pause button to the end&#10;            // Pause button - will pause timer, but cover the grid&#10;            IconButton(&#10;                onClick = { gameState.togglePause() },&#10;                modifier = Modifier.padding(8.dp),&#10;                // align the icon to the end of the row&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Lock,&#10;                    contentDescription = &quot;Pause Game&quot;,&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        // Display number of mistakes and highest possible score&#10;        Row (&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Mistakes: ${gameState.mistakesCount}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(start = 8.dp)&#10;            )&#10;            Spacer(Modifier.weight(1f)) // Push the highest possible score to the end&#10;            Text(&#10;                text = &quot;Max Score: ${gameState.highestPossibleScore()}&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.padding(end = 8.dp)&#10;            )&#10;        }&#10;&#10;        Spacer(Modifier.height(14.dp))&#10;        // Grid - show overlay when paused&#10;        Box(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            SudokuGrid(&#10;                grid = gameState.grid,&#10;                selectedCell = null,&#10;                selectedNumber = gameState.selectedNumber, // Pass selectedNumber&#10;                onCellClick = { row, col -&gt;&#10;                    gameState.inputToCell(row, col)&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Pause overlay&#10;            if (gameState.isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 1f)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Paused&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(96.dp))&#10;&#10;        // Compute which numbers are disabled (already filled in all spots)&#10;        val numberCounts = IntArray(9) { 0 }&#10;        for (row in gameState.grid) {&#10;            for (cell in row) {&#10;                if (cell.value in 1..9) {&#10;                    numberCounts[cell.value - 1]++&#10;                }&#10;            }&#10;        }&#10;        val disabledNumbers = numberCounts.mapIndexed { idx, count -&gt; if (count &gt;= 9) idx + 1 else null }.filterNotNull()&#10;&#10;        // Input numbers row&#10;        InputRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            input = List(9) { it + 1 },&#10;            onInputChange = { index, value -&gt;&#10;                val number = value.toInt()&#10;                if (!disabledNumbers.contains(number)) {&#10;                    gameState.selectNumber(number)&#10;                }&#10;            },&#10;            selectedNumber = gameState.selectedNumber,&#10;            disabledNumbers = disabledNumbers // Pass disabled numbers&#10;        )&#10;        Spacer(Modifier.height(24.dp))&#10;        // Utility Row&#10;        UtilityRow(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            selectedButton = when (gameState.gameMode) {&#10;                GameState.GameMode.NOTES -&gt; &quot;notes&quot;&#10;                GameState.GameMode.ERASE -&gt; &quot;erase&quot;&#10;                else -&gt; null&#10;            },&#10;            onEraseClick = { gameState.toggleEraseMode() },&#10;            onNotesClick = { gameState.toggleNotesMode() },&#10;            onUndoClick = { gameState.undo() },&#10;            onAutofillNotesClick = { gameState.autofillNotes() }&#10;        )&#10;&#10;        // Completion Dialog&#10;        if (showCompletionDialog) {&#10;            // Check for new best time&#10;            val (isNewBest, isNewBestNoMistakes) = BestTimeManager.setBestTime(&#10;                context = LocalContext.current,&#10;                difficulty = gameState.difficulty,&#10;                time = gameState.getFormattedTime(),&#10;                numMistakes = gameState.mistakesCount,&#10;            )&#10;&#10;            val context = LocalContext.current&#10;&#10;            LaunchedEffect(Unit) {&#10;                // Initialize repository if not done&#10;                gameState.initializeRepository(context)&#10;&#10;                // Record game completion in local statistics&#10;                gameState.recordGameCompletion(context)&#10;&#10;                // Try to submit score&#10;                val submitted = gameState.submitScoreToServer()&#10;                if (!submitted) { // off line mode or not connected to server&#10;                    // Show a toast or some indication that score submission failed&#10;                    // Toast.makeText(context, &quot;Score submission failed. Please try again later.&quot;, Toast.LENGTH_SHORT).show()&#10;                    // For now, we will just log it&#10;                    println(&quot;Score submission failed. Please try again later.&quot;)&#10;                }&#10;&#10;                // challenge - handle offline challenges differently&#10;                if (isChallenge &amp;&amp; challengeId != null) {&#10;                    // For offline challenges, the challenger needs to send puzzle data along with completion&#10;                    val challengeResult = repository.completeChallengerGame(&#10;                        challengeId = challengeId,&#10;                        timeSeconds = gameState.elapsedTimeSeconds,&#10;                        numberOfMistakes = gameState.mistakesCount,&#10;                        puzzleData = mapOf(&#10;                            &quot;puzzle&quot; to gameState.grid.map { row -&gt; &#10;                                row.map { cell -&gt; if (cell.isOriginal) cell.value else 0 } &#10;                            },&#10;                            &quot;solution&quot; to gameState.solutionGrid.map { it.toList() }&#10;                        )&#10;                    )&#10;                    challengeResult.fold(&#10;                        onSuccess = {&#10;                            // Successfully submitted challenger's game completion&#10;                            println(&quot;Challenger game completed successfully. Invitation sent to challenged player.&quot;)&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            // Handle error submitting challenger's game&#10;                            println(&quot;Error submitting challenger game: ${exception.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            GameStateManager.endGame()&#10;            AlertDialog(&#10;                onDismissRequest = {&#10;                    showCompletionDialog = false&#10;                    GameStateManager.endGame()&#10;                },&#10;                title = { Text(&quot;Congratulations! Final score: ${gameState.highestPossibleScore()}&quot;) },&#10;                text = {&#10;                    if (isNewBest) {&#10;                        Text(&quot;You completed the game in a new best time for ${gameState.difficulty}: ${gameState.getFormattedTime()}!&quot;)&#10;                    } else {&#10;                        Text(&quot;You completed the game in ${gameState.getFormattedTime()}! Your best time for ${gameState.difficulty} is ${BestTimeManager.getBestTimeFormatted(LocalContext.current, gameState.difficulty)}.&quot;)&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    Button(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                            onNavigateToMenu()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Back to Menu&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            showCompletionDialog = false&#10;                            GameStateManager.endGame()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Stay Here&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(&quot;%02d:%02d&quot;, minutes, remainingSeconds)&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GameScreenPreview() {&#10;    var isDarkTheme by remember { mutableStateOf(false) }&#10;&#10;    SudokuTheme(darkTheme = isDarkTheme) {&#10;        GameScreen(&#10;            isDarkTheme = isDarkTheme,&#10;            onThemeToggle = { isDarkTheme = it },&#10;&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GroupMembersScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GroupMembersScreen.kt" />
              <option name="originalContent" value="/**&#10; * Group Members screen for viewing members of a specific group&#10; * Shows all group members with their roles and join dates&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.data.api.GroupMember&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GroupMembersScreen(&#10;    groupId: Int,&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    onNavigateToGame: (difficulty: String, challengeId: Int) -&gt; Unit = { _, _ -&gt; }&#10;) {&#10;    var groupData by remember { mutableStateOf&lt;GroupData?&gt;(null) }&#10;    var members by remember { mutableStateOf&lt;List&lt;GroupMember&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    var showChallengeDialog by remember { mutableStateOf(false) }&#10;    var selectedMemberId by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load group data and members&#10;    LaunchedEffect(groupId) {&#10;        isLoading = true&#10;        errorMessage = null&#10;&#10;        scope.launch {&#10;            // First get group details&#10;            val groupResult = repository.getGroupDetails(groupId)&#10;            groupResult.fold(&#10;                onSuccess = { group -&gt;&#10;                    groupData = group&#10;                    // Then get group members&#10;                    val membersResult = repository.getGroupMembers(groupId)&#10;                    membersResult.fold(&#10;                        onSuccess = { membersList -&gt;&#10;                            members = membersList.sortedWith(&#10;                                compareBy&lt;GroupMember&gt; { member -&gt;&#10;                                    when ((member.role ?: &quot;member&quot;).lowercase()) {&#10;                                        &quot;leader&quot; -&gt; 0&#10;                                        else -&gt; 1&#10;                                    }&#10;                                }.thenBy { it.username ?: &quot;Unknown User&quot; }&#10;                            )&#10;                            isLoading = false&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            errorMessage = exception.message ?: &quot;Failed to load group members&quot;&#10;                            isLoading = false&#10;                        }&#10;                    )&#10;                },&#10;                onFailure = { exception -&gt;&#10;                    errorMessage = exception.message ?: &quot;Failed to load group details&quot;&#10;                    isLoading = false&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    groupData?.let { group -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Header with back button and title&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = group.group_name ?: &quot;Unknown Group&quot;, // Add null safety&#10;                            style = MaterialTheme.typography.titleLarge,&#10;                            fontWeight = FontWeight.Bold,&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                        Text(&#10;                            text = &quot;Members&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                )&#10;            )&#10;&#10;            // Group info card&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                shape = RoundedCornerShape(12.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.People,&#10;                        contentDescription = &quot;Members&quot;,&#10;                        modifier = Modifier.size(32.dp),&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Spacer(modifier = Modifier.width(12.dp))&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;${members.size} members&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                        group.group_description?.let { description -&gt;&#10;                            Text(&#10;                                text = description,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Error Message&#10;            errorMessage?.let { message -&gt;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Error,&#10;                            contentDescription = &quot;Error&quot;,&#10;                            tint = MaterialTheme.colorScheme.onErrorContainer&#10;                        )&#10;                        Spacer(modifier = Modifier.width(12.dp))&#10;                        Text(&#10;                            text = message,&#10;                            color = MaterialTheme.colorScheme.onErrorContainer,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Content&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp)&#10;            ) {&#10;                when {&#10;                    isLoading -&gt; {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;&#10;                    members.isEmpty() &amp;&amp; errorMessage == null -&gt; {&#10;                        EmptyMembersMessage(&#10;                            modifier = Modifier.align(Alignment.Center)&#10;                        )&#10;                    }&#10;&#10;                    else -&gt; {&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                            contentPadding = PaddingValues(vertical = 8.dp)&#10;                        ) {&#10;                            items(members) { member -&gt;&#10;                                MemberCard(&#10;                                    member = member,&#10;                                    isCurrentUser = repository.fetchCurrentUser()?.id == member.id&#10;                                )&#10;                                // Dont show challenge button for self&#10;                                if (member.player_id != repository.fetchCurrentUser()?.id) {&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            // Show challenge dialog&#10;                                            showChallengeDialog = true&#10;                                            selectedMemberId = member.player_id&#10;                                            Log.d(&quot;GroupMembersScreen&quot;, &quot;Selected member for challenge: ${member.username} with ID ${member.player_id}&quot;)&#10;                                        }&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.SportsEsports,&#10;                                            contentDescription = &quot;Challenge Player&quot;,&#10;                                            tint = MaterialTheme.colorScheme.primary&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    } ?: run {&#10;        // Show loading or error state when group data is not loaded&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .background(MaterialTheme.colorScheme.background),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            if (isLoading) {&#10;                CircularProgressIndicator(color = MaterialTheme.colorScheme.primary)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&quot;Loading group details...&quot;)&#10;            } else {&#10;                errorMessage?.let { message -&gt;&#10;                    Icon(&#10;                        imageVector = Icons.Default.Error,&#10;                        contentDescription = &quot;Error&quot;,&#10;                        modifier = Modifier.size(64.dp),&#10;                        tint = MaterialTheme.colorScheme.error&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = message,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Button(onClick = onNavigateBack) {&#10;                        Text(&quot;Go Back&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    if (showChallengeDialog &amp;&amp; selectedMemberId != null) {&#10;        ChallengeDialog(&#10;            onDismiss = { showChallengeDialog = false },&#10;            onChallengeCreated = { difficulty, type -&gt;&#10;                // Handle challenge creation&#10;                scope.launch {&#10;                    val result = repository.createChallenge(&#10;                        challengedId = selectedMemberId!!,&#10;                        groupId = groupId,&#10;                        difficulty = difficulty,&#10;                        challengeType = type&#10;                    )&#10;                    result.fold(&#10;                        onSuccess = { response -&gt;&#10;                            showChallengeDialog = false&#10;&#10;                            // For offline challenges, challenger should start the game immediately&#10;                            if (type == &quot;offline&quot; &amp;&amp; response.requiresChallengerCompletion == true) {&#10;                                response.challengeId?.let { challengeId -&gt;&#10;                                    // Navigate to game with challenge context for challenger&#10;                                    // This will be handled by the parent navigation&#10;                                    Log.d(&quot;GroupMembersScreen&quot;, &quot;Starting offline challenge game for challenger with ID: $challengeId&quot;)&#10;                                    onNavigateToGame(type, challengeId)&#10;                                }&#10;                            }&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            Log.e(&quot;GroupMembersScreen&quot;, &quot;Failed to create challenge: ${exception.message}&quot;)&#10;                            // Optionally show error message&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun MemberCard(&#10;    member: GroupMember,&#10;    isCurrentUser: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (isCurrentUser) {&#10;                MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.5f)&#10;            } else {&#10;                MaterialTheme.colorScheme.surface&#10;            }&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Avatar placeholder&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                            &quot;leader&quot; -&gt; Color(0xFFFFD700) // Gold for leader&#10;                            else -&gt; MaterialTheme.colorScheme.primary // Default for member&#10;                        }&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                        &quot;leader&quot; -&gt; Icons.Default.Star&#10;                        else -&gt; Icons.Default.Person&#10;                    },&#10;                    contentDescription = member.role ?: &quot;Member&quot;,&#10;                    tint = when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                        &quot;leader&quot; -&gt; Color.Black&#10;                        else -&gt; MaterialTheme.colorScheme.onPrimary&#10;                    },&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Member info&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = member.username ?: &quot;Unknown User&quot;, // Add null safety&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Medium,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (isCurrentUser) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .clip(RoundedCornerShape(4.dp))&#10;                                .background(MaterialTheme.colorScheme.primary)&#10;                                .padding(horizontal = 6.dp, vertical = 2.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;YOU&quot;,&#10;                                style = MaterialTheme.typography.labelSmall,&#10;                                color = MaterialTheme.colorScheme.onPrimary,&#10;                                fontSize = 10.sp&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Role badge&#10;                Box(&#10;                    modifier = Modifier&#10;                        .clip(RoundedCornerShape(6.dp))&#10;                        .background(&#10;                            when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                                &quot;leader&quot; -&gt; Color(0xFFFFD700).copy(alpha = 0.2f)&#10;                                else -&gt; MaterialTheme.colorScheme.surfaceVariant&#10;                            }&#10;                        )&#10;                        .padding(horizontal = 8.dp, vertical = 4.dp)&#10;                ) {&#10;                    Text(&#10;                        text = (member.role ?: &quot;Member&quot;).replaceFirstChar { // Add null safety&#10;                            if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString()&#10;                        },&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        color = when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                            &quot;leader&quot; -&gt; Color(0xFFB8860B)&#10;                            else -&gt; MaterialTheme.colorScheme.onSurfaceVariant&#10;                        },&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                }&#10;&#10;                // Join date&#10;                member.joined_at?.let { joinDate -&gt;&#10;                    if (joinDate.isNotBlank()) { // Add additional check for empty strings&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Text(&#10;                            text = &quot;Joined ${formatJoinDate(joinDate)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptyMembersMessage(&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.GroupOff,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(64.dp),&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Text(&#10;            text = &quot;No Members Found&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;        Text(&#10;            text = &quot;This group doesn't have any members yet&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(top = 8.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ChallengeDialog(&#10;    onDismiss: () -&gt; Unit,&#10;    onChallengeCreated: (String, String) -&gt; Unit // Add challengeType parameter&#10;) {&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;medium&quot;) }&#10;    var selectedType by remember { mutableStateOf(&quot;offline&quot;) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Create Challenge&quot;) },&#10;        text = {&#10;            Column {&#10;                Text(&quot;Select challenge type:&quot;)&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Challenge type selection&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    listOf(&quot;offline&quot;, &quot;online&quot;).forEach { type -&gt;&#10;                        FilterChip(&#10;                            onClick = { selectedType = type },&#10;                            label = {&#10;                                Text(&#10;                                    when(type) {&#10;                                        &quot;offline&quot; -&gt; &quot;Offline&quot;&#10;                                        &quot;online&quot; -&gt; &quot;Live&quot;&#10;                                        else -&gt; type&#10;                                    }&#10;                                )&#10;                            },&#10;                            selected = selectedType == type&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&quot;Select difficulty:&quot;)&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Difficulty selection&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    listOf(&quot;easy&quot;, &quot;medium&quot;, &quot;hard&quot;).forEach { difficulty -&gt;&#10;                        FilterChip(&#10;                            onClick = { selectedDifficulty = difficulty },&#10;                            label = { Text(difficulty.uppercase()) },&#10;                            selected = selectedDifficulty == difficulty&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Explanation text&#10;                Text(&#10;                    text = when(selectedType) {&#10;                        &quot;offline&quot; -&gt; &quot;Offline: You play first, then your opponent gets the same puzzle with your time to beat.&quot;&#10;                        &quot;online&quot; -&gt; &quot;Live: Both players start the same puzzle simultaneously when accepted.&quot;&#10;                        else -&gt; &quot;&quot;&#10;                    },&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = { onChallengeCreated(selectedDifficulty, selectedType) }&#10;            ) {&#10;                Text(&quot;Create Challenge&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;private fun formatJoinDate(dateString: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;MMM d, yyyy&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(dateString)&#10;        outputFormat.format(date ?: Date())&#10;    } catch (e: Exception) {&#10;        try {&#10;            val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;            val outputFormat = SimpleDateFormat(&quot;MMM d, yyyy&quot;, Locale.getDefault())&#10;            val date = inputFormat.parse(dateString)&#10;            outputFormat.format(date ?: Date())&#10;        } catch (e2: Exception) {&#10;            &quot;Recently&quot;&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GroupMembersScreenPreview() {&#10;    SudokuTheme {&#10;        GroupMembersScreen(&#10;            groupId = 1&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Group Members screen for viewing members of a specific group&#10; * Shows all group members with their roles and join dates&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.data.api.GroupMember&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GroupMembersScreen(&#10;    groupId: Int,&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    onNavigateToGame: (difficulty: String, challengeId: Int) -&gt; Unit = { _, _ -&gt; }&#10;) {&#10;    var groupData by remember { mutableStateOf&lt;GroupData?&gt;(null) }&#10;    var members by remember { mutableStateOf&lt;List&lt;GroupMember&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    var showChallengeDialog by remember { mutableStateOf(false) }&#10;    var selectedMemberId by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load group data and members&#10;    LaunchedEffect(groupId) {&#10;        isLoading = true&#10;        errorMessage = null&#10;&#10;        scope.launch {&#10;            // First get group details&#10;            val groupResult = repository.getGroupDetails(groupId)&#10;            groupResult.fold(&#10;                onSuccess = { group -&gt;&#10;                    groupData = group&#10;                    // Then get group members&#10;                    val membersResult = repository.getGroupMembers(groupId)&#10;                    membersResult.fold(&#10;                        onSuccess = { membersList -&gt;&#10;                            members = membersList.sortedWith(&#10;                                compareBy&lt;GroupMember&gt; { member -&gt;&#10;                                    when ((member.role ?: &quot;member&quot;).lowercase()) {&#10;                                        &quot;leader&quot; -&gt; 0&#10;                                        else -&gt; 1&#10;                                    }&#10;                                }.thenBy { it.username ?: &quot;Unknown User&quot; }&#10;                            )&#10;                            isLoading = false&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            errorMessage = exception.message ?: &quot;Failed to load group members&quot;&#10;                            isLoading = false&#10;                        }&#10;                    )&#10;                },&#10;                onFailure = { exception -&gt;&#10;                    errorMessage = exception.message ?: &quot;Failed to load group details&quot;&#10;                    isLoading = false&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    groupData?.let { group -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Header with back button and title&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = group.group_name ?: &quot;Unknown Group&quot;, // Add null safety&#10;                            style = MaterialTheme.typography.titleLarge,&#10;                            fontWeight = FontWeight.Bold,&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                        Text(&#10;                            text = &quot;Members&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                )&#10;            )&#10;&#10;            // Group info card&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                shape = RoundedCornerShape(12.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.People,&#10;                        contentDescription = &quot;Members&quot;,&#10;                        modifier = Modifier.size(32.dp),&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Spacer(modifier = Modifier.width(12.dp))&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;${members.size} members&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                        group.group_description?.let { description -&gt;&#10;                            Text(&#10;                                text = description,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Error Message&#10;            errorMessage?.let { message -&gt;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Error,&#10;                            contentDescription = &quot;Error&quot;,&#10;                            tint = MaterialTheme.colorScheme.onErrorContainer&#10;                        )&#10;                        Spacer(modifier = Modifier.width(12.dp))&#10;                        Text(&#10;                            text = message,&#10;                            color = MaterialTheme.colorScheme.onErrorContainer,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Content&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp)&#10;            ) {&#10;                when {&#10;                    isLoading -&gt; {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;&#10;                    members.isEmpty() &amp;&amp; errorMessage == null -&gt; {&#10;                        EmptyMembersMessage(&#10;                            modifier = Modifier.align(Alignment.Center)&#10;                        )&#10;                    }&#10;&#10;                    else -&gt; {&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                            contentPadding = PaddingValues(vertical = 8.dp)&#10;                        ) {&#10;                            items(members) { member -&gt;&#10;                                MemberCard(&#10;                                    member = member,&#10;                                    isCurrentUser = repository.fetchCurrentUser()?.id == member.id&#10;                                )&#10;                                // Dont show challenge button for self&#10;                                if (member.player_id != repository.fetchCurrentUser()?.id) {&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            // Show challenge dialog&#10;                                            showChallengeDialog = true&#10;                                            selectedMemberId = member.player_id&#10;                                            Log.d(&quot;GroupMembersScreen&quot;, &quot;Selected member for challenge: ${member.username} with ID ${member.player_id}&quot;)&#10;                                        }&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.SportsEsports,&#10;                                            contentDescription = &quot;Challenge Player&quot;,&#10;                                            tint = MaterialTheme.colorScheme.primary&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    } ?: run {&#10;        // Show loading or error state when group data is not loaded&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .background(MaterialTheme.colorScheme.background),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            if (isLoading) {&#10;                CircularProgressIndicator(color = MaterialTheme.colorScheme.primary)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&quot;Loading group details...&quot;)&#10;            } else {&#10;                errorMessage?.let { message -&gt;&#10;                    Icon(&#10;                        imageVector = Icons.Default.Error,&#10;                        contentDescription = &quot;Error&quot;,&#10;                        modifier = Modifier.size(64.dp),&#10;                        tint = MaterialTheme.colorScheme.error&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = message,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Button(onClick = onNavigateBack) {&#10;                        Text(&quot;Go Back&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    if (showChallengeDialog &amp;&amp; selectedMemberId != null) {&#10;        ChallengeDialog(&#10;            onDismiss = { showChallengeDialog = false },&#10;            onChallengeCreated = { difficulty, type -&gt;&#10;                // Handle challenge creation&#10;                scope.launch {&#10;                    val result = repository.createChallenge(&#10;                        challengedId = selectedMemberId!!,&#10;                        groupId = groupId,&#10;                        difficulty = difficulty,&#10;                        challengeType = type&#10;                    )&#10;                    result.fold(&#10;                        onSuccess = { response -&gt;&#10;                            showChallengeDialog = false&#10;&#10;                            // For offline challenges, challenger should start the game immediately&#10;                            if (type == &quot;offline&quot; &amp;&amp; response.requiresChallengerCompletion == true) {&#10;                                response.challengeId?.let { challengeId -&gt;&#10;                                    // Navigate to game with challenge context for challenger&#10;                                    // This will be handled by the parent navigation&#10;                                    Log.d(&quot;GroupMembersScreen&quot;, &quot;Starting offline challenge game for challenger with ID: $challengeId&quot;)&#10;                                    onNavigateToGame(difficulty, challengeId)&#10;                                }&#10;                            }&#10;                        },&#10;                        onFailure = { exception -&gt;&#10;                            Log.e(&quot;GroupMembersScreen&quot;, &quot;Failed to create challenge: ${exception.message}&quot;)&#10;                            // Optionally show error message&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun MemberCard(&#10;    member: GroupMember,&#10;    isCurrentUser: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (isCurrentUser) {&#10;                MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.5f)&#10;            } else {&#10;                MaterialTheme.colorScheme.surface&#10;            }&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Avatar placeholder&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                            &quot;leader&quot; -&gt; Color(0xFFFFD700) // Gold for leader&#10;                            else -&gt; MaterialTheme.colorScheme.primary // Default for member&#10;                        }&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                        &quot;leader&quot; -&gt; Icons.Default.Star&#10;                        else -&gt; Icons.Default.Person&#10;                    },&#10;                    contentDescription = member.role ?: &quot;Member&quot;,&#10;                    tint = when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                        &quot;leader&quot; -&gt; Color.Black&#10;                        else -&gt; MaterialTheme.colorScheme.onPrimary&#10;                    },&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Member info&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = member.username ?: &quot;Unknown User&quot;, // Add null safety&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Medium,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (isCurrentUser) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .clip(RoundedCornerShape(4.dp))&#10;                                .background(MaterialTheme.colorScheme.primary)&#10;                                .padding(horizontal = 6.dp, vertical = 2.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;YOU&quot;,&#10;                                style = MaterialTheme.typography.labelSmall,&#10;                                color = MaterialTheme.colorScheme.onPrimary,&#10;                                fontSize = 10.sp&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Role badge&#10;                Box(&#10;                    modifier = Modifier&#10;                        .clip(RoundedCornerShape(6.dp))&#10;                        .background(&#10;                            when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                                &quot;leader&quot; -&gt; Color(0xFFFFD700).copy(alpha = 0.2f)&#10;                                else -&gt; MaterialTheme.colorScheme.surfaceVariant&#10;                            }&#10;                        )&#10;                        .padding(horizontal = 8.dp, vertical = 4.dp)&#10;                ) {&#10;                    Text(&#10;                        text = (member.role ?: &quot;Member&quot;).replaceFirstChar { // Add null safety&#10;                            if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString()&#10;                        },&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        color = when ((member.role ?: &quot;member&quot;).lowercase()) { // Add null safety&#10;                            &quot;leader&quot; -&gt; Color(0xFFB8860B)&#10;                            else -&gt; MaterialTheme.colorScheme.onSurfaceVariant&#10;                        },&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                }&#10;&#10;                // Join date&#10;                member.joined_at?.let { joinDate -&gt;&#10;                    if (joinDate.isNotBlank()) { // Add additional check for empty strings&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Text(&#10;                            text = &quot;Joined ${formatJoinDate(joinDate)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptyMembersMessage(&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.GroupOff,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(64.dp),&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Text(&#10;            text = &quot;No Members Found&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;        Text(&#10;            text = &quot;This group doesn't have any members yet&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(top = 8.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ChallengeDialog(&#10;    onDismiss: () -&gt; Unit,&#10;    onChallengeCreated: (String, String) -&gt; Unit // Add challengeType parameter&#10;) {&#10;    var selectedDifficulty by remember { mutableStateOf(&quot;medium&quot;) }&#10;    var selectedType by remember { mutableStateOf(&quot;offline&quot;) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Create Challenge&quot;) },&#10;        text = {&#10;            Column {&#10;                Text(&quot;Select challenge type:&quot;)&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Challenge type selection&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    listOf(&quot;offline&quot;, &quot;online&quot;).forEach { type -&gt;&#10;                        FilterChip(&#10;                            onClick = { selectedType = type },&#10;                            label = {&#10;                                Text(&#10;                                    when(type) {&#10;                                        &quot;offline&quot; -&gt; &quot;Offline&quot;&#10;                                        &quot;online&quot; -&gt; &quot;Live&quot;&#10;                                        else -&gt; type&#10;                                    }&#10;                                )&#10;                            },&#10;                            selected = selectedType == type&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&quot;Select difficulty:&quot;)&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Difficulty selection&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    listOf(&quot;easy&quot;, &quot;medium&quot;, &quot;hard&quot;).forEach { difficulty -&gt;&#10;                        FilterChip(&#10;                            onClick = { selectedDifficulty = difficulty },&#10;                            label = { Text(difficulty.uppercase()) },&#10;                            selected = selectedDifficulty == difficulty&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Explanation text&#10;                Text(&#10;                    text = when(selectedType) {&#10;                        &quot;offline&quot; -&gt; &quot;Offline: You play first, then your opponent gets the same puzzle with your time to beat.&quot;&#10;                        &quot;online&quot; -&gt; &quot;Live: Both players start the same puzzle simultaneously when accepted.&quot;&#10;                        else -&gt; &quot;&quot;&#10;                    },&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = { onChallengeCreated(selectedDifficulty, selectedType) }&#10;            ) {&#10;                Text(&quot;Create Challenge&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;private fun formatJoinDate(dateString: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;MMM d, yyyy&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(dateString)&#10;        outputFormat.format(date ?: Date())&#10;    } catch (e: Exception) {&#10;        try {&#10;            val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;            val outputFormat = SimpleDateFormat(&quot;MMM d, yyyy&quot;, Locale.getDefault())&#10;            val date = inputFormat.parse(dateString)&#10;            outputFormat.format(date ?: Date())&#10;        } catch (e2: Exception) {&#10;            &quot;Recently&quot;&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GroupMembersScreenPreview() {&#10;    SudokuTheme {&#10;        GroupMembersScreen(&#10;            groupId = 1&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GroupsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/GroupsScreen.kt" />
              <option name="originalContent" value="/**&#10; * Groups screen for managing Sudoku groups&#10; * Includes functionality to view, join, create, and manage groups&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ExitToApp&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GroupsScreen(&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    onNavigateToGroupLeaderboard: (Int) -&gt; Unit = {}&#10;) {&#10;    var selectedTabIndex by remember { mutableIntStateOf(0) }&#10;    var allGroups by remember { mutableStateOf&lt;List&lt;GroupData&gt;&gt;(emptyList()) }&#10;    var myGroups by remember { mutableStateOf&lt;List&lt;GroupData&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var successMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var showCreateGroupDialog by remember { mutableStateOf(false) }&#10;    var showJoinGroupDialog by remember { mutableStateOf(false) }&#10;    var selectedGroup by remember { mutableStateOf&lt;GroupData?&gt;(null) }&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var isSearching by remember { mutableStateOf(false) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;    val isLoggedIn = repository.isLoggedIn()&#10;&#10;    val tabTitles = if (isLoggedIn) listOf(&quot;All Groups&quot;, &quot;My Groups&quot;) else listOf(&quot;All Groups&quot;)&#10;&#10;    // Load data based on selected tab&#10;    LaunchedEffect(selectedTabIndex, isLoggedIn) {&#10;        isLoading = true&#10;        errorMessage = null&#10;&#10;        scope.launch {&#10;            try {&#10;                when (selectedTabIndex) {&#10;                    0 -&gt; { // All Groups&#10;                        val result = if (searchQuery.isBlank()) {&#10;                            repository.getAllGroups()&#10;                        } else {&#10;                            repository.searchGroups(searchQuery)&#10;                        }&#10;                        result.fold(&#10;                            onSuccess = { groups -&gt;&#10;                                allGroups = groups&#10;                                isLoading = false&#10;                            },&#10;                            onFailure = { exception -&gt;&#10;                                errorMessage = exception.message ?: &quot;Failed to load groups&quot;&#10;                                isLoading = false&#10;                            }&#10;                        )&#10;                    }&#10;                    1 -&gt; { // My Groups (only if logged in)&#10;                        if (isLoggedIn) {&#10;                            val result = repository.getMyGroups()&#10;                            result.fold(&#10;                                onSuccess = { groups -&gt;&#10;                                    myGroups = groups&#10;                                    isLoading = false&#10;                                },&#10;                                onFailure = { exception -&gt;&#10;                                    errorMessage = exception.message ?: &quot;Failed to load my groups&quot;&#10;                                    isLoading = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                errorMessage = e.message ?: &quot;An error occurred&quot;&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        // Header with back button and title&#10;        TopAppBar(&#10;            title = {&#10;                Text(&#10;                    text = &quot;Groups&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            },&#10;            navigationIcon = {&#10;                IconButton(onClick = onNavigateBack) {&#10;                    Icon(&#10;                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                        contentDescription = &quot;Back&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            },&#10;            actions = {&#10;                if (isLoggedIn) {&#10;                    IconButton(onClick = { showCreateGroupDialog = true }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Add,&#10;                            contentDescription = &quot;Create Group&quot;,&#10;                            tint = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            colors = TopAppBarDefaults.topAppBarColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            )&#10;        )&#10;&#10;        // Search bar for All Groups tab&#10;        if (selectedTabIndex == 0) {&#10;            OutlinedTextField(&#10;                value = searchQuery,&#10;                onValueChange = {&#10;                    searchQuery = it&#10;                    if (it.isNotBlank()) {&#10;                        isSearching = true&#10;                        scope.launch {&#10;                            val result = repository.searchGroups(it)&#10;                            result.fold(&#10;                                onSuccess = { groups -&gt;&#10;                                    allGroups = groups&#10;                                    isSearching = false&#10;                                },&#10;                                onFailure = {&#10;                                    isSearching = false&#10;                                }&#10;                            )&#10;                        }&#10;                    } else {&#10;                        // Reload all groups when search is cleared&#10;                        scope.launch {&#10;                            val result = repository.getAllGroups()&#10;                            result.fold(&#10;                                onSuccess = { groups -&gt; allGroups = groups },&#10;                                onFailure = { /* Handle error */ }&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Search Groups&quot;) },&#10;                leadingIcon = {&#10;                    Icon(Icons.Default.Search, contentDescription = &quot;Search&quot;)&#10;                },&#10;                trailingIcon = {&#10;                    if (searchQuery.isNotEmpty()) {&#10;                        IconButton(onClick = { searchQuery = &quot;&quot; }) {&#10;                            Icon(Icons.Default.Clear, contentDescription = &quot;Clear&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                singleLine = true&#10;            )&#10;        }&#10;&#10;        // Tab Row&#10;        if (isLoggedIn) {&#10;            TabRow(&#10;                selectedTabIndex = selectedTabIndex,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                containerColor = MaterialTheme.colorScheme.surface,&#10;                contentColor = MaterialTheme.colorScheme.onSurface&#10;            ) {&#10;                tabTitles.forEachIndexed { index, title -&gt;&#10;                    Tab(&#10;                        selected = selectedTabIndex == index,&#10;                        onClick = { selectedTabIndex = index },&#10;                        text = {&#10;                            Text(&#10;                                text = title,&#10;                                fontSize = 14.sp,&#10;                                fontWeight = if (selectedTabIndex == index) FontWeight.Bold else FontWeight.Normal&#10;                            )&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Error/Success Messages&#10;        errorMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Error,&#10;                        contentDescription = &quot;Error&quot;,&#10;                        tint = MaterialTheme.colorScheme.onErrorContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.width(12.dp))&#10;                    Text(&#10;                        text = message,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                    IconButton(onClick = { errorMessage = null }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Close,&#10;                            contentDescription = &quot;Dismiss&quot;,&#10;                            tint = MaterialTheme.colorScheme.onErrorContainer&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        successMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.CheckCircle,&#10;                        contentDescription = &quot;Success&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.width(12.dp))&#10;                    Text(&#10;                        text = message,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                    IconButton(onClick = { successMessage = null }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Close,&#10;                            contentDescription = &quot;Dismiss&quot;,&#10;                            tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Content&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            when {&#10;                isLoading || isSearching -&gt; {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.align(Alignment.Center),&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;&#10;                selectedTabIndex == 0 &amp;&amp; allGroups.isEmpty() -&gt; {&#10;                    EmptyStateMessage(&#10;                        title = if (searchQuery.isBlank()) &quot;No Groups Available&quot; else &quot;No Groups Found&quot;,&#10;                        subtitle = if (searchQuery.isBlank()) &quot;There are no public groups to display&quot;&#10;                                  else &quot;Try adjusting your search terms&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                selectedTabIndex == 1 &amp;&amp; myGroups.isEmpty() -&gt; {&#10;                    EmptyStateMessage(&#10;                        title = &quot;No Groups Joined&quot;,&#10;                        subtitle = &quot;Join or create a group to get started&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                else -&gt; {&#10;                    val groupsToShow = if (selectedTabIndex == 0) allGroups else myGroups&#10;&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                        contentPadding = PaddingValues(vertical = 8.dp)&#10;                    ) {&#10;                        items(groupsToShow) { group -&gt;&#10;                            GroupCard(&#10;                                group = group,&#10;                                isLoggedIn = isLoggedIn,&#10;                                isMyGroup = selectedTabIndex == 1,&#10;                                onJoinClick = {&#10;                                    selectedGroup = group&#10;                                    showJoinGroupDialog = true&#10;                                },&#10;                                onLeaveClick = { groupId -&gt;&#10;                                    scope.launch {&#10;                                        val result = repository.leaveGroup(groupId)&#10;                                        result.fold(&#10;                                            onSuccess = {&#10;                                                successMessage = &quot;Left group successfully&quot;&#10;                                                // Refresh my groups&#10;                                                repository.getMyGroups().fold(&#10;                                                    onSuccess = { myGroups = it },&#10;                                                    onFailure = { }&#10;                                                )&#10;                                            },&#10;                                            onFailure = {&#10;                                                errorMessage = it.message ?: &quot;Failed to leave group&quot;&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onDeleteClick = { groupId -&gt;&#10;                                    scope.launch {&#10;                                        val result = repository.deleteGroup(groupId)&#10;                                        result.fold(&#10;                                            onSuccess = {&#10;                                                successMessage = &quot;Group deleted successfully&quot;&#10;                                                // Refresh my groups&#10;                                                repository.getMyGroups().fold(&#10;                                                    onSuccess = { myGroups = it },&#10;                                                    onFailure = { }&#10;                                                )&#10;                                            },&#10;                                            onFailure = {&#10;                                                errorMessage = it.message ?: &quot;Failed to delete group&quot;&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onLeaderboardClick = { groupId -&gt;&#10;                                    onNavigateToGroupLeaderboard(groupId)&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dialogs&#10;        if (showCreateGroupDialog) {&#10;            CreateGroupDialog(&#10;                onDismiss = { showCreateGroupDialog = false },&#10;                onCreateGroup = { name, description, password -&gt;&#10;                    scope.launch {&#10;                        val result = repository.createGroup(name, description, password)&#10;                        result.fold(&#10;                            onSuccess = {&#10;                                successMessage = &quot;Group created successfully&quot;&#10;                                showCreateGroupDialog = false&#10;                                // Refresh groups&#10;                                if (selectedTabIndex == 1) {&#10;                                    repository.getMyGroups().fold(&#10;                                        onSuccess = { myGroups = it },&#10;                                        onFailure = { }&#10;                                    )&#10;                                } else {&#10;                                    repository.getAllGroups().fold(&#10;                                        onSuccess = { allGroups = it },&#10;                                        onFailure = { }&#10;                                    )&#10;                                }&#10;                            },&#10;                            onFailure = {&#10;                                errorMessage = it.message ?: &quot;Failed to create group&quot;&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showJoinGroupDialog &amp;&amp; selectedGroup != null) {&#10;            JoinGroupDialog(&#10;                group = selectedGroup!!,&#10;                onDismiss = {&#10;                    showJoinGroupDialog = false&#10;                    selectedGroup = null&#10;                },&#10;                onJoinGroup = { groupId, password -&gt;&#10;                    scope.launch {&#10;                        val result = repository.joinGroup(groupId, password)&#10;                        result.fold(&#10;                            onSuccess = {&#10;                                successMessage = &quot;Joined group successfully&quot;&#10;                                showJoinGroupDialog = false&#10;                                selectedGroup = null&#10;                                // Refresh my groups if on that tab&#10;                                if (selectedTabIndex == 1) {&#10;                                    repository.getMyGroups().fold(&#10;                                        onSuccess = { myGroups = it },&#10;                                        onFailure = { }&#10;                                    )&#10;                                }&#10;                            },&#10;                            onFailure = {&#10;                                errorMessage = it.message ?: &quot;Failed to join group&quot;&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun GroupCard(&#10;    group: GroupData,&#10;    isLoggedIn: Boolean,&#10;    isMyGroup: Boolean,&#10;    onJoinClick: () -&gt; Unit,&#10;    onLeaveClick: (Int) -&gt; Unit,&#10;    onDeleteClick: (Int) -&gt; Unit,&#10;    onLeaderboardClick: (Int) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = group.group_name,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                        if (group.is_private == true) {&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Private Group&quot;,&#10;                                modifier = Modifier.size(16.dp),&#10;                                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    group.group_description?.let { description -&gt;&#10;                        Text(&#10;                            text = description,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis,&#10;                            modifier = Modifier.padding(top = 4.dp)&#10;                        )&#10;                    }&#10;&#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.People,&#10;                            contentDescription = &quot;Members&quot;,&#10;                            modifier = Modifier.size(16.dp),&#10;                            tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                        Text(&#10;                            text = &quot;${group.member_count ?: 0} members&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            modifier = Modifier.padding(start = 4.dp)&#10;                        )&#10;&#10;                        if (isMyGroup &amp;&amp; group.user_role != null) {&#10;                            Spacer(modifier = Modifier.width(16.dp))&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .clip(RoundedCornerShape(4.dp))&#10;                                    .background(MaterialTheme.colorScheme.primaryContainer)&#10;                                    .padding(horizontal = 6.dp, vertical = 2.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = group.user_role!!.uppercase(),&#10;                                    style = MaterialTheme.typography.labelSmall,&#10;                                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Action buttons&#10;                Column {&#10;                    if (isMyGroup) {&#10;                        // Actions for groups the user is in&#10;                        IconButton(onClick = { group.id?.let { onLeaderboardClick(it) } }) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Leaderboard,&#10;                                contentDescription = &quot;View Leaderboard&quot;,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;                        if (group.user_role == &quot;owner&quot;) {&#10;                            IconButton(onClick = { group.id?.let { onDeleteClick(it) } }) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Delete,&#10;                                    contentDescription = &quot;Delete Group&quot;,&#10;                                    tint = MaterialTheme.colorScheme.error&#10;                                )&#10;                            }&#10;                        } else {&#10;                            IconButton(onClick = { group.id?.let { onLeaveClick(it) } }) {&#10;                                Icon(&#10;                                    imageVector = Icons.AutoMirrored.Filled.ExitToApp,&#10;                                    contentDescription = &quot;Leave Group&quot;,&#10;                                    tint = MaterialTheme.colorScheme.error&#10;                                )&#10;                            }&#10;                        }&#10;                    } else {&#10;                        // Actions for groups the user can join&#10;                        if (isLoggedIn) {&#10;                            Button(&#10;                                onClick = onJoinClick,&#10;                                modifier = Modifier.size(width = 80.dp, height = 36.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Join&quot;,&#10;                                    fontSize = 12.sp&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CreateGroupDialog(&#10;    onDismiss: () -&gt; Unit,&#10;    onCreateGroup: (String, String?, String?) -&gt; Unit&#10;) {&#10;    var groupName by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var isPrivate by remember { mutableStateOf(false) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Create New Group&quot;) },&#10;        text = {&#10;            Column(&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = groupName,&#10;                    onValueChange = { groupName = it },&#10;                    label = { Text(&quot;Group Name&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    singleLine = true&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = description,&#10;                    onValueChange = { description = it },&#10;                    label = { Text(&quot;Description (Optional)&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    maxLines = 3&#10;                )&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Checkbox(&#10;                        checked = isPrivate,&#10;                        onCheckedChange = { isPrivate = it }&#10;                    )&#10;                    Text(&quot;Private Group&quot;, modifier = Modifier.padding(start = 8.dp))&#10;                }&#10;&#10;                if (isPrivate) {&#10;                    OutlinedTextField(&#10;                        value = password,&#10;                        onValueChange = { password = it },&#10;                        label = { Text(&quot;Password&quot;) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                                Icon(&#10;                                    imageVector = if (passwordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                                    contentDescription = if (passwordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                                )&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    onCreateGroup(&#10;                        groupName.trim(),&#10;                        description.trim().ifBlank { null },&#10;                        if (isPrivate &amp;&amp; password.isNotBlank()) password else null&#10;                    )&#10;                },&#10;                enabled = groupName.trim().isNotEmpty()&#10;            ) {&#10;                Text(&quot;Create&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun JoinGroupDialog(&#10;    group: GroupData,&#10;    onDismiss: () -&gt; Unit,&#10;    onJoinGroup: (Int, String?) -&gt; Unit&#10;) {&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Join Group&quot;) },&#10;        text = {&#10;            Column(&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Join \&quot;${group.group_name}\&quot;?&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;&#10;                group.group_description?.let { description -&gt;&#10;                    Text(&#10;                        text = description,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;&#10;                if (group.is_private == true) {&#10;                    OutlinedTextField(&#10;                        value = password,&#10;                        onValueChange = { password = it },&#10;                        label = { Text(&quot;Group Password&quot;) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                                Icon(&#10;                                    imageVector = if (passwordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                                    contentDescription = if (passwordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                                )&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    group.id?.let { groupId -&gt;&#10;                        onJoinGroup(&#10;                            groupId,&#10;                            if (group.is_private == true &amp;&amp; password.isNotBlank()) password else null&#10;                        )&#10;                    }&#10;                },&#10;                enabled = group.is_private != true || password.isNotBlank()&#10;            ) {&#10;                Text(&quot;Join&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EmptyStateMessage(&#10;    title: String,&#10;    subtitle: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Groups,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(64.dp),&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Text(&#10;            text = title,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;        Text(&#10;            text = subtitle,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(top = 8.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GroupsScreenPreview() {&#10;    SudokuTheme {&#10;        GroupsScreen()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Groups screen for managing Sudoku groups&#10; * Includes functionality to view, join, create, and manage groups&#10; */&#10;&#10;package com.kooshmeen.sudoku.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ExitToApp&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.kooshmeen.sudoku.data.api.GroupData&#10;import com.kooshmeen.sudoku.repository.SudokuRepository&#10;import com.kooshmeen.sudoku.ui.theme.SudokuTheme&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GroupsScreen(&#10;    modifier: Modifier = Modifier,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    onNavigateToGroupLeaderboard: (Int) -&gt; Unit = {},&#10;    onNavigateToGroupMembers: (GroupData) -&gt; Unit = {}&#10;) {&#10;    var selectedTabIndex by remember { mutableIntStateOf(0) }&#10;    var allGroups by remember { mutableStateOf&lt;List&lt;GroupData&gt;&gt;(emptyList()) }&#10;    var myGroups by remember { mutableStateOf&lt;List&lt;GroupData&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var successMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var showCreateGroupDialog by remember { mutableStateOf(false) }&#10;    var showJoinGroupDialog by remember { mutableStateOf(false) }&#10;    var selectedGroup by remember { mutableStateOf&lt;GroupData?&gt;(null) }&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var isSearching by remember { mutableStateOf(false) }&#10;&#10;    val context = LocalContext.current&#10;    val repository = remember { SudokuRepository(context) }&#10;    val scope = rememberCoroutineScope()&#10;    val isLoggedIn = repository.isLoggedIn()&#10;&#10;    val tabTitles = if (isLoggedIn) listOf(&quot;All Groups&quot;, &quot;My Groups&quot;) else listOf(&quot;All Groups&quot;)&#10;&#10;    // Load data based on selected tab&#10;    LaunchedEffect(selectedTabIndex, isLoggedIn) {&#10;        isLoading = true&#10;        errorMessage = null&#10;&#10;        scope.launch {&#10;            try {&#10;                when (selectedTabIndex) {&#10;                    0 -&gt; { // All Groups&#10;                        val result = if (searchQuery.isBlank()) {&#10;                            repository.getAllGroups()&#10;                        } else {&#10;                            repository.searchGroups(searchQuery)&#10;                        }&#10;                        result.fold(&#10;                            onSuccess = { groups -&gt;&#10;                                allGroups = groups&#10;                                isLoading = false&#10;                            },&#10;                            onFailure = { exception -&gt;&#10;                                errorMessage = exception.message ?: &quot;Failed to load groups&quot;&#10;                                isLoading = false&#10;                            }&#10;                        )&#10;                    }&#10;                    1 -&gt; { // My Groups (only if logged in)&#10;                        if (isLoggedIn) {&#10;                            val result = repository.getMyGroups()&#10;                            result.fold(&#10;                                onSuccess = { groups -&gt;&#10;                                    myGroups = groups&#10;                                    isLoading = false&#10;                                },&#10;                                onFailure = { exception -&gt;&#10;                                    errorMessage = exception.message ?: &quot;Failed to load my groups&quot;&#10;                                    isLoading = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                errorMessage = e.message ?: &quot;An error occurred&quot;&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        // Header with back button and title&#10;        TopAppBar(&#10;            title = {&#10;                Text(&#10;                    text = &quot;Groups&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            },&#10;            navigationIcon = {&#10;                IconButton(onClick = onNavigateBack) {&#10;                    Icon(&#10;                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                        contentDescription = &quot;Back&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            },&#10;            actions = {&#10;                if (isLoggedIn) {&#10;                    IconButton(onClick = { showCreateGroupDialog = true }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Add,&#10;                            contentDescription = &quot;Create Group&quot;,&#10;                            tint = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            colors = TopAppBarDefaults.topAppBarColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            )&#10;        )&#10;&#10;        // Search bar for All Groups tab&#10;        if (selectedTabIndex == 0) {&#10;            OutlinedTextField(&#10;                value = searchQuery,&#10;                onValueChange = {&#10;                    searchQuery = it&#10;                    if (it.isNotBlank()) {&#10;                        isSearching = true&#10;                        scope.launch {&#10;                            val result = repository.searchGroups(it)&#10;                            result.fold(&#10;                                onSuccess = { groups -&gt;&#10;                                    allGroups = groups&#10;                                    isSearching = false&#10;                                },&#10;                                onFailure = {&#10;                                    isSearching = false&#10;                                }&#10;                            )&#10;                        }&#10;                    } else {&#10;                        // Reload all groups when search is cleared&#10;                        scope.launch {&#10;                            val result = repository.getAllGroups()&#10;                            result.fold(&#10;                                onSuccess = { groups -&gt; allGroups = groups },&#10;                                onFailure = { /* Handle error */ }&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Search Groups&quot;) },&#10;                leadingIcon = {&#10;                    Icon(Icons.Default.Search, contentDescription = &quot;Search&quot;)&#10;                },&#10;                trailingIcon = {&#10;                    if (searchQuery.isNotEmpty()) {&#10;                        IconButton(onClick = { searchQuery = &quot;&quot; }) {&#10;                            Icon(Icons.Default.Clear, contentDescription = &quot;Clear&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                singleLine = true&#10;            )&#10;        }&#10;&#10;        // Tab Row&#10;        if (isLoggedIn) {&#10;            TabRow(&#10;                selectedTabIndex = selectedTabIndex,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                containerColor = MaterialTheme.colorScheme.surface,&#10;                contentColor = MaterialTheme.colorScheme.onSurface&#10;            ) {&#10;                tabTitles.forEachIndexed { index, title -&gt;&#10;                    Tab(&#10;                        selected = selectedTabIndex == index,&#10;                        onClick = { selectedTabIndex = index },&#10;                        text = {&#10;                            Text(&#10;                                text = title,&#10;                                fontSize = 14.sp,&#10;                                fontWeight = if (selectedTabIndex == index) FontWeight.Bold else FontWeight.Normal&#10;                            )&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Error/Success Messages&#10;        errorMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Error,&#10;                        contentDescription = &quot;Error&quot;,&#10;                        tint = MaterialTheme.colorScheme.onErrorContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.width(12.dp))&#10;                    Text(&#10;                        text = message,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                    IconButton(onClick = { errorMessage = null }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Close,&#10;                            contentDescription = &quot;Dismiss&quot;,&#10;                            tint = MaterialTheme.colorScheme.onErrorContainer&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        successMessage?.let { message -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.CheckCircle,&#10;                        contentDescription = &quot;Success&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.width(12.dp))&#10;                    Text(&#10;                        text = message,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                    IconButton(onClick = { successMessage = null }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Close,&#10;                            contentDescription = &quot;Dismiss&quot;,&#10;                            tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Content&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            when {&#10;                isLoading || isSearching -&gt; {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.align(Alignment.Center),&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;&#10;                selectedTabIndex == 0 &amp;&amp; allGroups.isEmpty() -&gt; {&#10;                    EmptyStateMessage(&#10;                        title = if (searchQuery.isBlank()) &quot;No Groups Available&quot; else &quot;No Groups Found&quot;,&#10;                        subtitle = if (searchQuery.isBlank()) &quot;There are no public groups to display&quot;&#10;                                  else &quot;Try adjusting your search terms&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                selectedTabIndex == 1 &amp;&amp; myGroups.isEmpty() -&gt; {&#10;                    EmptyStateMessage(&#10;                        title = &quot;No Groups Joined&quot;,&#10;                        subtitle = &quot;Join or create a group to get started&quot;,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                else -&gt; {&#10;                    val groupsToShow = if (selectedTabIndex == 0) allGroups else myGroups&#10;&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                        contentPadding = PaddingValues(vertical = 8.dp)&#10;                    ) {&#10;                        items(groupsToShow) { group -&gt;&#10;                            GroupCard(&#10;                                group = group,&#10;                                isLoggedIn = isLoggedIn,&#10;                                isMyGroup = selectedTabIndex == 1,&#10;                                onJoinClick = {&#10;                                    selectedGroup = group&#10;                                    showJoinGroupDialog = true&#10;                                },&#10;                                onLeaveClick = { groupId -&gt;&#10;                                    scope.launch {&#10;                                        val result = repository.leaveGroup(groupId)&#10;                                        result.fold(&#10;                                            onSuccess = {&#10;                                                successMessage = &quot;Left group successfully&quot;&#10;                                                // Refresh my groups&#10;                                                repository.getMyGroups().fold(&#10;                                                    onSuccess = { myGroups = it },&#10;                                                    onFailure = { }&#10;                                                )&#10;                                            },&#10;                                            onFailure = {&#10;                                                errorMessage = it.message ?: &quot;Failed to leave group&quot;&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onDeleteClick = { groupId -&gt;&#10;                                    scope.launch {&#10;                                        val result = repository.deleteGroup(groupId)&#10;                                        result.fold(&#10;                                            onSuccess = {&#10;                                                successMessage = &quot;Group deleted successfully&quot;&#10;                                                // Refresh my groups&#10;                                                repository.getMyGroups().fold(&#10;                                                    onSuccess = { myGroups = it },&#10;                                                    onFailure = { }&#10;                                                )&#10;                                            },&#10;                                            onFailure = {&#10;                                                errorMessage = it.message ?: &quot;Failed to delete group&quot;&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onLeaderboardClick = { groupId -&gt;&#10;                                    onNavigateToGroupLeaderboard(groupId)&#10;                                },&#10;                                onViewMembersClick = { group -&gt;&#10;                                    onNavigateToGroupMembers(group)&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dialogs&#10;        if (showCreateGroupDialog) {&#10;            CreateGroupDialog(&#10;                onDismiss = { showCreateGroupDialog = false },&#10;                onCreateGroup = { name, description, password -&gt;&#10;                    scope.launch {&#10;                        val result = repository.createGroup(name, description, password)&#10;                        result.fold(&#10;                            onSuccess = {&#10;                                successMessage = &quot;Group created successfully&quot;&#10;                                showCreateGroupDialog = false&#10;                                // Refresh groups&#10;                                if (selectedTabIndex == 1) {&#10;                                    repository.getMyGroups().fold(&#10;                                        onSuccess = { myGroups = it },&#10;                                        onFailure = { }&#10;                                    )&#10;                                } else {&#10;                                    repository.getAllGroups().fold(&#10;                                        onSuccess = { allGroups = it },&#10;                                        onFailure = { }&#10;                                    )&#10;                                }&#10;                            },&#10;                            onFailure = {&#10;                                errorMessage = it.message ?: &quot;Failed to create group&quot;&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showJoinGroupDialog &amp;&amp; selectedGroup != null) {&#10;            JoinGroupDialog(&#10;                group = selectedGroup!!,&#10;                onDismiss = {&#10;                    showJoinGroupDialog = false&#10;                    selectedGroup = null&#10;                },&#10;                onJoinGroup = { groupId, password -&gt;&#10;                    scope.launch {&#10;                        val result = repository.joinGroup(groupId, password)&#10;                        result.fold(&#10;                            onSuccess = {&#10;                                successMessage = &quot;Joined group successfully&quot;&#10;                                showJoinGroupDialog = false&#10;                                selectedGroup = null&#10;                                // Refresh my groups if on that tab&#10;                                if (selectedTabIndex == 1) {&#10;                                    repository.getMyGroups().fold(&#10;                                        onSuccess = { myGroups = it },&#10;                                        onFailure = { }&#10;                                    )&#10;                                }&#10;                            },&#10;                            onFailure = {&#10;                                errorMessage = it.message ?: &quot;Failed to join group&quot;&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun GroupCard(&#10;    group: GroupData,&#10;    isLoggedIn: Boolean,&#10;    isMyGroup: Boolean,&#10;    onJoinClick: () -&gt; Unit,&#10;    onLeaveClick: (Int) -&gt; Unit,&#10;    onDeleteClick: (Int) -&gt; Unit,&#10;    onLeaderboardClick: (Int) -&gt; Unit,&#10;    onViewMembersClick: (GroupData) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = group.group_name,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                        if (group.is_private == true) {&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Private Group&quot;,&#10;                                modifier = Modifier.size(16.dp),&#10;                                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    group.group_description?.let { description -&gt;&#10;                        Text(&#10;                            text = description,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis,&#10;                            modifier = Modifier.padding(top = 4.dp)&#10;                        )&#10;                    }&#10;&#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.People,&#10;                            contentDescription = &quot;Members&quot;,&#10;                            modifier = Modifier.size(16.dp),&#10;                            tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                        Text(&#10;                            text = &quot;${group.member_count ?: 0} members&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            modifier = Modifier.padding(start = 4.dp)&#10;                        )&#10;&#10;                        if (isMyGroup &amp;&amp; group.user_role != null) {&#10;                            Spacer(modifier = Modifier.width(16.dp))&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .clip(RoundedCornerShape(4.dp))&#10;                                    .background(MaterialTheme.colorScheme.primaryContainer)&#10;                                    .padding(horizontal = 6.dp, vertical = 2.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = group.user_role!!.uppercase(),&#10;                                    style = MaterialTheme.typography.labelSmall,&#10;                                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Action buttons&#10;                Column {&#10;                    if (isMyGroup) {&#10;                        // Actions for groups the user is in&#10;                        Row {&#10;                            IconButton(onClick = { onViewMembersClick(group) }) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.People,&#10;                                    contentDescription = &quot;View Members&quot;,&#10;                                    tint = MaterialTheme.colorScheme.primary&#10;                                )&#10;                            }&#10;                            IconButton(onClick = { group.id?.let { onLeaderboardClick(it) } }) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Leaderboard,&#10;                                    contentDescription = &quot;View Leaderboard&quot;,&#10;                                    tint = MaterialTheme.colorScheme.primary&#10;                                )&#10;                            }&#10;                        }&#10;                        if (group.user_role == &quot;owner&quot;) {&#10;                            IconButton(onClick = { group.id?.let { onDeleteClick(it) } }) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Delete,&#10;                                    contentDescription = &quot;Delete Group&quot;,&#10;                                    tint = MaterialTheme.colorScheme.error&#10;                                )&#10;                            }&#10;                        } else {&#10;                            IconButton(onClick = { group.id?.let { onLeaveClick(it) } }) {&#10;                                Icon(&#10;                                    imageVector = Icons.AutoMirrored.Filled.ExitToApp,&#10;                                    contentDescription = &quot;Leave Group&quot;,&#10;                                    tint = MaterialTheme.colorScheme.error&#10;                                )&#10;                            }&#10;                        }&#10;                    } else {&#10;                        // Actions for groups the user can join&#10;                        if (isLoggedIn) {&#10;                            Button(&#10;                                onClick = onJoinClick,&#10;                                modifier = Modifier.size(width = 80.dp, height = 36.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Join&quot;,&#10;                                    fontSize = 12.sp&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CreateGroupDialog(&#10;    onDismiss: () -&gt; Unit,&#10;    onCreateGroup: (String, String?, String?) -&gt; Unit&#10;) {&#10;    var groupName by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var isPrivate by remember { mutableStateOf(false) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Create New Group&quot;) },&#10;        text = {&#10;            Column(&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = groupName,&#10;                    onValueChange = { groupName = it },&#10;                    label = { Text(&quot;Group Name&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    singleLine = true&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = description,&#10;                    onValueChange = { description = it },&#10;                    label = { Text(&quot;Description (Optional)&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    maxLines = 3&#10;                )&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Checkbox(&#10;                        checked = isPrivate,&#10;                        onCheckedChange = { isPrivate = it }&#10;                    )&#10;                    Text(&quot;Private Group&quot;, modifier = Modifier.padding(start = 8.dp))&#10;                }&#10;&#10;                if (isPrivate) {&#10;                    OutlinedTextField(&#10;                        value = password,&#10;                        onValueChange = { password = it },&#10;                        label = { Text(&quot;Password&quot;) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                                Icon(&#10;                                    imageVector = if (passwordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                                    contentDescription = if (passwordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                                )&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    onCreateGroup(&#10;                        groupName.trim(),&#10;                        description.trim().ifBlank { null },&#10;                        if (isPrivate &amp;&amp; password.isNotBlank()) password else null&#10;                    )&#10;                },&#10;                enabled = groupName.trim().isNotEmpty()&#10;            ) {&#10;                Text(&quot;Create&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun JoinGroupDialog(&#10;    group: GroupData,&#10;    onDismiss: () -&gt; Unit,&#10;    onJoinGroup: (Int, String?) -&gt; Unit&#10;) {&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Join Group&quot;) },&#10;        text = {&#10;            Column(&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Join \&quot;${group.group_name}\&quot;?&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;&#10;                group.group_description?.let { description -&gt;&#10;                    Text(&#10;                        text = description,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;&#10;                if (group.is_private == true) {&#10;                    OutlinedTextField(&#10;                        value = password,&#10;                        onValueChange = { password = it },&#10;                        label = { Text(&quot;Group Password&quot;) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),&#10;                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),&#10;                        trailingIcon = {&#10;                            IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                                Icon(&#10;                                    imageVector = if (passwordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,&#10;                                    contentDescription = if (passwordVisible) &quot;Hide password&quot; else &quot;Show password&quot;&#10;                                )&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    group.id?.let { groupId -&gt;&#10;                        onJoinGroup(&#10;                            groupId,&#10;                            if (group.is_private == true &amp;&amp; password.isNotBlank()) password else null&#10;                        )&#10;                    }&#10;                },&#10;                enabled = group.is_private != true || password.isNotBlank()&#10;            ) {&#10;                Text(&quot;Join&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EmptyStateMessage(&#10;    title: String,&#10;    subtitle: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Groups,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(64.dp),&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Text(&#10;            text = title,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;        Text(&#10;            text = subtitle,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(top = 8.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GroupsScreenPreview() {&#10;    SudokuTheme {&#10;        GroupsScreen()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/screens/RecordScreen.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/ui/theme/Theme.kt" />
              <option name="originalContent" value="package com.kooshmeen.sudoku.ui.theme&#10;&#10;import android.os.Build&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.ColorScheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;private val DarkColorScheme = darkColorScheme(&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80,&#10;    background = Color(0xFF121212),&#10;    surface = Color(0xFF1E1E1E),&#10;    onPrimary = Color.DarkGray,&#10;    onSecondary = Color.LightGray,&#10;    onTertiary = Color.LightGray,&#10;    onBackground = Color.LightGray,&#10;    onSurface = Color.LightGray,&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Purple40,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40,&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;)&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80,&#10;    background = Color(0xFF121212),&#10;    surface = Color(0xFF1E1E1E),&#10;    onPrimary = Color.DarkGray,&#10;    onSurface = Color.LightGray,&#10;)&#10;            val context = LocalContext.current&#10;    onBackground = Color.LightGray,&#10;private val LightColorScheme = lightColorScheme(&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;&#10;    // Animate the color scheme&#10;    val animatedColorScheme = animateColorScheme(targetColorScheme)&#10;&#10;    MaterialTheme(&#10;        colorScheme = animatedColorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}&#10;&#10;@Composable&#10;fun animateColorScheme(targetScheme: ColorScheme): ColorScheme {&#10;    val primary by animateColorAsState(&#10;        targetValue = targetScheme.primary,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val background by animateColorAsState(&#10;        targetValue = targetScheme.background,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val surface by animateColorAsState(&#10;        targetValue = targetScheme.surface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onBackground by animateColorAsState(&#10;        targetValue = targetScheme.onBackground,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onSurface by animateColorAsState(&#10;        targetValue = targetScheme.onSurface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;    return targetScheme.copy(&#10;        primary = primary,&#10;        background = background,&#10;        surface = surface,&#10;        onBackground = onBackground,&#10;        onSurface = onSurface&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.kooshmeen.sudoku.ui.theme&#10;&#10;import android.os.Build&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.ColorScheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.kooshmeen.sudoku.utils.ThemeManager&#10;&#10;@Composable&#10;fun SudokuTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    dynamicColor: Boolean = false,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val customTheme = ThemeManager.loadCustomTheme(context)&#10;&#10;    val targetColorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;        darkTheme -&gt; darkColorScheme(&#10;            primary = customTheme.darkPrimary,&#10;            secondary = customTheme.darkSecondary,&#10;            tertiary = customTheme.darkTertiary,&#10;            background = customTheme.darkBackground,&#10;            surface = customTheme.darkSurface,&#10;            onPrimary = customTheme.darkOnPrimary,&#10;            onSecondary = customTheme.darkOnSecondary,&#10;            onTertiary = customTheme.darkOnTertiary,&#10;            onBackground = customTheme.darkOnBackground,&#10;            onSurface = customTheme.darkOnSurface&#10;        )&#10;        else -&gt; lightColorScheme(&#10;            primary = customTheme.lightPrimary,&#10;            secondary = customTheme.lightSecondary,&#10;            tertiary = customTheme.lightTertiary,&#10;            background = customTheme.lightBackground,&#10;            surface = customTheme.lightSurface,&#10;            onPrimary = customTheme.lightOnPrimary,&#10;            onSecondary = customTheme.lightOnSecondary,&#10;            onTertiary = customTheme.lightOnTertiary,&#10;            onBackground = customTheme.lightOnBackground,&#10;            onSurface = customTheme.lightOnSurface&#10;        )&#10;    }&#10;&#10;    // Animate the color scheme&#10;    val animatedColorScheme = animateColorScheme(targetColorScheme)&#10;&#10;    MaterialTheme(&#10;        colorScheme = animatedColorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}&#10;&#10;@Composable&#10;fun animateColorScheme(targetScheme: ColorScheme): ColorScheme {&#10;    val primary by animateColorAsState(&#10;        targetValue = targetScheme.primary,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val background by animateColorAsState(&#10;        targetValue = targetScheme.background,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val surface by animateColorAsState(&#10;        targetValue = targetScheme.surface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onBackground by animateColorAsState(&#10;        targetValue = targetScheme.onBackground,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;    val onSurface by animateColorAsState(&#10;        targetValue = targetScheme.onSurface,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;    return targetScheme.copy(&#10;        primary = primary,&#10;        background = background,&#10;        surface = surface,&#10;        onBackground = onBackground,&#10;        onSurface = onSurface&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/GameStatePersistence.kt" />
              <option name="updatedContent" value="/**&#10; * Handles persistence of game state using SharedPreferences&#10; * Serializes game state to JSON for storage&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import com.kooshmeen.sudoku.data.*&#10;&#10;object GameStatePersistence {&#10;    private const val PREFS_NAME = &quot;SudokuGameState&quot;&#10;    private const val KEY_SAVED_GAME = &quot;saved_game&quot;&#10;    &#10;    fun saveGameState(context: Context, gameState: GameState) {&#10;        // Only save if game is active and not completed&#10;        if (!gameState.isGameActive || gameState.isGameCompleted) return&#10;        &#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = serializeGameState(gameState)&#10;        prefs.edit().putString(KEY_SAVED_GAME, json).apply()&#10;    }&#10;    &#10;    fun loadGameState(context: Context): SavedGameState? {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val json = prefs.getString(KEY_SAVED_GAME, null) ?: return null&#10;        return deserializeGameState(json)&#10;    }&#10;    &#10;    fun clearSavedGame(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit().remove(KEY_SAVED_GAME).apply()&#10;    }&#10;    &#10;    private fun serializeGameState(gameState: GameState): String {&#10;        val jsonObject = JSONObject().apply {&#10;            put(&quot;difficulty&quot;, gameState.difficulty)&#10;            put(&quot;elapsedTime&quot;, gameState.elapsedTimeSeconds)&#10;            put(&quot;mistakesCount&quot;, gameState.mistakesCount)&#10;            put(&quot;grid&quot;, serializeGrid(gameState.grid))&#10;            put(&quot;solutionGrid&quot;, serializeSolutionGrid(gameState.solutionGrid))&#10;        }&#10;        return jsonObject.toString()&#10;    }&#10;    &#10;    private fun serializeGrid(grid: Array&lt;Array&lt;SudokuCell&gt;&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            grid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { cell -&gt;&#10;                        val cellObj = JSONObject().apply {&#10;                            put(&quot;value&quot;, cell.value)&#10;                            put(&quot;notes&quot;, JSONArray(cell.notes.toList()))&#10;                            put(&quot;isOriginal&quot;, cell.isOriginal)&#10;                            put(&quot;hasError&quot;, cell.hasError)&#10;                        }&#10;                        put(cellObj)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun serializeSolutionGrid(solutionGrid: Array&lt;IntArray&gt;): JSONArray {&#10;        return JSONArray().apply {&#10;            solutionGrid.forEach { row -&gt;&#10;                val rowArray = JSONArray().apply {&#10;                    row.forEach { value -&gt;&#10;                        put(value)&#10;                    }&#10;                }&#10;                put(rowArray)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun deserializeGameState(json: String): SavedGameState? {&#10;        return try {&#10;            val jsonObject = JSONObject(json)&#10;            &#10;            val gridArray = jsonObject.getJSONArray(&quot;grid&quot;)&#10;            val grid = mutableListOf&lt;List&lt;SavedCellState&gt;&gt;()&#10;            &#10;            for (i in 0 until gridArray.length()) {&#10;                val rowArray = gridArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;SavedCellState&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    val cellObj = rowArray.getJSONObject(j)&#10;                    val notesArray = cellObj.getJSONArray(&quot;notes&quot;)&#10;                    val notes = mutableListOf&lt;Int&gt;()&#10;                    &#10;                    for (k in 0 until notesArray.length()) {&#10;                        notes.add(notesArray.getInt(k))&#10;                    }&#10;                    &#10;                    row.add(SavedCellState(&#10;                        value = cellObj.getInt(&quot;value&quot;),&#10;                        notes = notes,&#10;                        isOriginal = cellObj.getBoolean(&quot;isOriginal&quot;),&#10;                        hasError = cellObj.getBoolean(&quot;hasError&quot;)&#10;                    ))&#10;                }&#10;                grid.add(row)&#10;            }&#10;            &#10;            val solutionArray = jsonObject.getJSONArray(&quot;solutionGrid&quot;)&#10;            val solutionGrid = mutableListOf&lt;List&lt;Int&gt;&gt;()&#10;            &#10;            for (i in 0 until solutionArray.length()) {&#10;                val rowArray = solutionArray.getJSONArray(i)&#10;                val row = mutableListOf&lt;Int&gt;()&#10;                &#10;                for (j in 0 until rowArray.length()) {&#10;                    row.add(rowArray.getInt(j))&#10;                }&#10;                solutionGrid.add(row)&#10;            }&#10;            &#10;            SavedGameState(&#10;                grid = grid,&#10;                difficulty = jsonObject.getString(&quot;difficulty&quot;),&#10;                elapsedTimeSeconds = jsonObject.getInt(&quot;elapsedTime&quot;),&#10;                mistakesCount = jsonObject.getInt(&quot;mistakesCount&quot;),&#10;                solutionGrid = solutionGrid&#10;            )&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/StatisticsManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/StatisticsManager.kt" />
              <option name="originalContent" value="/**&#10; * Comprehensive statistics manager for tracking player performance&#10; * Handles local storage of game statistics including completion counts, scores, and time-based tracking&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.lang.reflect.Array.getInt&#10;import java.lang.reflect.Array.getLong&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;object StatisticsManager {&#10;    private const val PREFS_NAME = &quot;SudokuStatistics&quot;&#10;&#10;    // Keys for different statistics&#10;    private const val KEY_GAMES_COMPLETED = &quot;games_completed_&quot;&#10;    private const val KEY_GAMES_PERFECT = &quot;games_perfect_&quot; // without mistakes&#10;    private const val KEY_TOTAL_SCORE = &quot;total_score_&quot;&#10;    private const val KEY_DAILY_SCORE = &quot;daily_score_&quot;&#10;    private const val KEY_WEEKLY_SCORE = &quot;weekly_score_&quot;&#10;    private const val KEY_MONTHLY_SCORE = &quot;monthly_score_&quot;&#10;    private const val KEY_LAST_PLAY_DATE = &quot;last_play_date&quot;&#10;    private const val KEY_CURRENT_STREAK = &quot;current_streak&quot;&#10;    private const val KEY_LONGEST_STREAK = &quot;longest_streak&quot;&#10;    private const val KEY_TOTAL_TIME_PLAYED = &quot;total_time_played&quot;&#10;    private const val KEY_AVERAGE_SCORE = &quot;average_score_&quot;&#10;&#10;    data class PlayerStats(&#10;        val easyGamesCompleted: Int = 0,&#10;        val mediumGamesCompleted: Int = 0,&#10;        val hardGamesCompleted: Int = 0,&#10;        val easyGamesPerfect: Int = 0,&#10;        val mediumGamesPerfect: Int = 0,&#10;        val hardGamesPerfect: Int = 0,&#10;        val easyTotalScore: Int = 0,&#10;        val mediumTotalScore: Int = 0,&#10;        val hardTotalScore: Int = 0,&#10;        val dailyScore: Int = 0,&#10;        val weeklyScore: Int = 0,&#10;        val monthlyScore: Int = 0,&#10;        val currentStreak: Int = 0,&#10;        val longestStreak: Int = 0,&#10;        val totalTimePlayed: Long = 0, // in seconds&#10;        val easyAverageScore: Float = 0f,&#10;        val mediumAverageScore: Float = 0f,&#10;        val hardAverageScore: Float = 0f&#10;    )&#10;&#10;    /**&#10;     * Record a completed game and update all relevant statistics&#10;     */&#10;    fun recordCompletedGame(&#10;        context: Context,&#10;        difficulty: String,&#10;        score: Int,&#10;        timeSeconds: Int,&#10;        mistakes: Int&#10;    ) {&#10;            val currentCompleted = getInt(completedKey, 0)&#10;        val difficultyKey = difficulty.lowercase()&#10;            val currentCompleted = getInt(completedKey, 0)&#10;        prefs.edit {&#10;            val currentCompleted = getInt(completedKey, 0)&#10;            val completedKey = KEY_GAMES_COMPLETED + difficultyKey&#10;                val currentPerfect = getInt(perfectKey, 0)&#10;            putInt(completedKey, currentCompleted + 1)&#10;                val currentPerfect = getInt(perfectKey, 0)&#10;            // Update perfect games count (no mistakes)&#10;                val currentPerfect = getInt(perfectKey, 0)&#10;                val perfectKey = KEY_GAMES_PERFECT + difficultyKey&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;                putInt(perfectKey, currentPerfect + 1)&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;            val totalScoreKey = KEY_TOTAL_SCORE + difficultyKey&#10;            val currentTotalScore = getInt(totalScoreKey, 0)&#10;            putInt(totalScoreKey, currentTotalScore + score)&#10;&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val averageKey = KEY_AVERAGE_SCORE + difficultyKey&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            updateTimeBasedScores(&#10;                this, score,&#10;                context = context&#10;            )&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            // Update playing streak&#10;            updatePlayingStreak(this, context)&#10;&#10;            // Update total time played&#10;            val currentTotalTime = getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            putLong(KEY_TOTAL_TIME_PLAYED, currentTotalTime + timeSeconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update daily, weekly, and monthly scores&#10;     */&#10;    private fun updateTimeBasedScores(editor: SharedPreferences.Editor, score: Int, context: Context) {&#10;        val currentDate = Calendar.getInstance()&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        // Get current date strings&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(currentDate.time)&#10;        val thisWeek = &quot;${currentDate.get(Calendar.YEAR)}-W${currentDate.get(Calendar.WEEK_OF_YEAR)}&quot;&#10;        val thisMonth = SimpleDateFormat(&quot;yyyy-MM&quot;, Locale.getDefault()).format(currentDate.time)&#10;&#10;        // Check if we need to reset daily score&#10;        val lastDailyUpdate = prefs.getString(&quot;last_daily_update&quot;, &quot;&quot;)&#10;        if (lastDailyUpdate != today) {&#10;            editor.putInt(KEY_DAILY_SCORE, score)&#10;            editor.putString(&quot;last_daily_update&quot;, today)&#10;        } else {&#10;            val currentDaily = prefs.getInt(KEY_DAILY_SCORE, 0)&#10;            editor.putInt(KEY_DAILY_SCORE, currentDaily + score)&#10;        }&#10;&#10;        // Check if we need to reset weekly score&#10;        val lastWeeklyUpdate = prefs.getString(&quot;last_weekly_update&quot;, &quot;&quot;)&#10;        if (lastWeeklyUpdate != thisWeek) {&#10;            editor.putInt(KEY_WEEKLY_SCORE, score)&#10;            editor.putString(&quot;last_weekly_update&quot;, thisWeek)&#10;        } else {&#10;            val currentWeekly = prefs.getInt(KEY_WEEKLY_SCORE, 0)&#10;            editor.putInt(KEY_WEEKLY_SCORE, currentWeekly + score)&#10;        }&#10;&#10;        // Check if we need to reset monthly score&#10;        val lastMonthlyUpdate = prefs.getString(&quot;last_monthly_update&quot;, &quot;&quot;)&#10;        if (lastMonthlyUpdate != thisMonth) {&#10;            editor.putInt(KEY_MONTHLY_SCORE, score)&#10;            editor.putString(&quot;last_monthly_update&quot;, thisMonth)&#10;        } else {&#10;            val currentMonthly = prefs.getInt(KEY_MONTHLY_SCORE, 0)&#10;            editor.putInt(KEY_MONTHLY_SCORE, currentMonthly + score)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update playing streak (consecutive days played)&#10;     */&#10;    private fun updatePlayingStreak(editor: SharedPreferences.Editor, context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;        val lastPlayDate = prefs.getString(KEY_LAST_PLAY_DATE, &quot;&quot;)&#10;&#10;        val currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0)&#10;        val longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0)&#10;&#10;        if (lastPlayDate == today) {&#10;            // Already played today, don't update streak&#10;            return&#10;        }&#10;&#10;        val yesterday = Calendar.getInstance().apply {&#10;            add(Calendar.DAY_OF_YEAR, -1)&#10;        }&#10;        val yesterdayStr = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(yesterday.time)&#10;&#10;        val newStreak = if (lastPlayDate == yesterdayStr) {&#10;            // Consecutive day&#10;            currentStreak + 1&#10;        } else {&#10;            // Streak broken or first time playing&#10;            1&#10;        }&#10;&#10;        editor.putString(KEY_LAST_PLAY_DATE, today)&#10;        editor.putInt(KEY_CURRENT_STREAK, newStreak)&#10;&#10;        if (newStreak &gt; longestStreak) {&#10;            editor.putInt(KEY_LONGEST_STREAK, newStreak)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all player statistics&#10;     */&#10;    fun getPlayerStats(context: Context): PlayerStats {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        return PlayerStats(&#10;            easyGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;easy&quot;, 0),&#10;            mediumGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;medium&quot;, 0),&#10;            hardGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;hard&quot;, 0),&#10;            easyGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;easy&quot;, 0),&#10;            mediumGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;medium&quot;, 0),&#10;            hardGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;hard&quot;, 0),&#10;            easyTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;easy&quot;, 0),&#10;            mediumTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;medium&quot;, 0),&#10;            hardTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;hard&quot;, 0),&#10;            dailyScore = prefs.getInt(KEY_DAILY_SCORE, 0),&#10;            weeklyScore = prefs.getInt(KEY_WEEKLY_SCORE, 0),&#10;            monthlyScore = prefs.getInt(KEY_MONTHLY_SCORE, 0),&#10;            currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0),&#10;            longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0),&#10;            totalTimePlayed = prefs.getLong(KEY_TOTAL_TIME_PLAYED, 0),&#10;            easyAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;easy&quot;, 0f),&#10;            mediumAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;medium&quot;, 0f),&#10;            hardAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;hard&quot;, 0f)&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Clear all statistics&#10;     */&#10;    fun clearAllStats(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { clear() }&#10;    }&#10;&#10;    /**&#10;     * Format time in a human-readable way&#10;     */&#10;    fun formatPlayTime(totalSeconds: Long): String {&#10;        val hours = totalSeconds / 3600&#10;        val minutes = (totalSeconds % 3600) / 60&#10;        val seconds = totalSeconds % 60&#10;&#10;        return when {&#10;            hours &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dh %dm %ds&quot;, hours, minutes, seconds)&#10;            minutes &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dm %ds&quot;, minutes, seconds)&#10;            else -&gt; String.format(Locale.getDefault(), &quot;%ds&quot;, seconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate completion rate for a difficulty&#10;     */&#10;    fun getCompletionRate(completed: Int, perfect: Int): Float {&#10;        return if (completed &gt; 0) (perfect.toFloat() / completed.toFloat()) * 100 else 0f&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Comprehensive statistics manager for tracking player performance&#10; * Handles local storage of game statistics including completion counts, scores, and time-based tracking&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;object StatisticsManager {&#10;    private const val PREFS_NAME = &quot;SudokuStatistics&quot;&#10;&#10;    // Keys for different statistics&#10;    private const val KEY_GAMES_COMPLETED = &quot;games_completed_&quot;&#10;    private const val KEY_GAMES_PERFECT = &quot;games_perfect_&quot; // without mistakes&#10;    private const val KEY_TOTAL_SCORE = &quot;total_score_&quot;&#10;    private const val KEY_DAILY_SCORE = &quot;daily_score_&quot;&#10;    private const val KEY_WEEKLY_SCORE = &quot;weekly_score_&quot;&#10;    private const val KEY_MONTHLY_SCORE = &quot;monthly_score_&quot;&#10;    private const val KEY_LAST_PLAY_DATE = &quot;last_play_date&quot;&#10;    private const val KEY_CURRENT_STREAK = &quot;current_streak&quot;&#10;    private const val KEY_LONGEST_STREAK = &quot;longest_streak&quot;&#10;    private const val KEY_TOTAL_TIME_PLAYED = &quot;total_time_played&quot;&#10;    private const val KEY_AVERAGE_SCORE = &quot;average_score_&quot;&#10;&#10;    data class PlayerStats(&#10;        val easyGamesCompleted: Int = 0,&#10;        val mediumGamesCompleted: Int = 0,&#10;        val hardGamesCompleted: Int = 0,&#10;        val easyGamesPerfect: Int = 0,&#10;        val mediumGamesPerfect: Int = 0,&#10;        val hardGamesPerfect: Int = 0,&#10;        val easyTotalScore: Int = 0,&#10;        val mediumTotalScore: Int = 0,&#10;        val hardTotalScore: Int = 0,&#10;        val dailyScore: Int = 0,&#10;        val weeklyScore: Int = 0,&#10;        val monthlyScore: Int = 0,&#10;        val currentStreak: Int = 0,&#10;        val longestStreak: Int = 0,&#10;        val totalTimePlayed: Long = 0, // in seconds&#10;        val easyAverageScore: Float = 0f,&#10;        val mediumAverageScore: Float = 0f,&#10;        val hardAverageScore: Float = 0f&#10;    )&#10;&#10;    /**&#10;     * Record a completed game and update all relevant statistics&#10;     */&#10;    fun recordCompletedGame(&#10;        context: Context,&#10;        difficulty: String,&#10;        score: Int,&#10;        timeSeconds: Int,&#10;        mistakes: Int&#10;    ) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val difficultyKey = difficulty.lowercase()&#10;&#10;        prefs.edit {&#10;            // Update game completion counts&#10;            val completedKey = KEY_GAMES_COMPLETED + difficultyKey&#10;            val currentCompleted = prefs.getInt(completedKey, 0)&#10;            putInt(completedKey, currentCompleted + 1)&#10;&#10;            // Update perfect games count (no mistakes)&#10;            if (mistakes == 0) {&#10;                val perfectKey = KEY_GAMES_PERFECT + difficultyKey&#10;                val currentPerfect = prefs.getInt(perfectKey, 0)&#10;                putInt(perfectKey, currentPerfect + 1)&#10;            }&#10;&#10;            // Update total scores&#10;            val totalScoreKey = KEY_TOTAL_SCORE + difficultyKey&#10;            val currentTotalScore = prefs.getInt(totalScoreKey, 0)&#10;            putInt(totalScoreKey, currentTotalScore + score)&#10;&#10;            // Update average score&#10;            val averageKey = KEY_AVERAGE_SCORE + difficultyKey&#10;            val newAverage = (currentTotalScore + score).toFloat() / (currentCompleted + 1)&#10;            putFloat(averageKey, newAverage)&#10;&#10;            // Update time-based scores&#10;            updateTimeBasedScores(this, score, context)&#10;&#10;            // Update playing streak&#10;            updatePlayingStreak(this, context)&#10;&#10;            // Update total time played&#10;            val currentTotalTime = prefs.getLong(KEY_TOTAL_TIME_PLAYED, 0)&#10;            putLong(KEY_TOTAL_TIME_PLAYED, currentTotalTime + timeSeconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update daily, weekly, and monthly scores&#10;     */&#10;    private fun updateTimeBasedScores(editor: SharedPreferences.Editor, score: Int, context: Context) {&#10;        val currentDate = Calendar.getInstance()&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        // Get current date strings&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(currentDate.time)&#10;        val thisWeek = &quot;${currentDate.get(Calendar.YEAR)}-W${currentDate.get(Calendar.WEEK_OF_YEAR)}&quot;&#10;        val thisMonth = SimpleDateFormat(&quot;yyyy-MM&quot;, Locale.getDefault()).format(currentDate.time)&#10;&#10;        // Check if we need to reset daily score&#10;        val lastDailyUpdate = prefs.getString(&quot;last_daily_update&quot;, &quot;&quot;)&#10;        if (lastDailyUpdate != today) {&#10;            editor.putInt(KEY_DAILY_SCORE, score)&#10;            editor.putString(&quot;last_daily_update&quot;, today)&#10;        } else {&#10;            val currentDaily = prefs.getInt(KEY_DAILY_SCORE, 0)&#10;            editor.putInt(KEY_DAILY_SCORE, currentDaily + score)&#10;        }&#10;&#10;        // Check if we need to reset weekly score&#10;        val lastWeeklyUpdate = prefs.getString(&quot;last_weekly_update&quot;, &quot;&quot;)&#10;        if (lastWeeklyUpdate != thisWeek) {&#10;            editor.putInt(KEY_WEEKLY_SCORE, score)&#10;            editor.putString(&quot;last_weekly_update&quot;, thisWeek)&#10;        } else {&#10;            val currentWeekly = prefs.getInt(KEY_WEEKLY_SCORE, 0)&#10;            editor.putInt(KEY_WEEKLY_SCORE, currentWeekly + score)&#10;        }&#10;&#10;        // Check if we need to reset monthly score&#10;        val lastMonthlyUpdate = prefs.getString(&quot;last_monthly_update&quot;, &quot;&quot;)&#10;        if (lastMonthlyUpdate != thisMonth) {&#10;            editor.putInt(KEY_MONTHLY_SCORE, score)&#10;            editor.putString(&quot;last_monthly_update&quot;, thisMonth)&#10;        } else {&#10;            val currentMonthly = prefs.getInt(KEY_MONTHLY_SCORE, 0)&#10;            editor.putInt(KEY_MONTHLY_SCORE, currentMonthly + score)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update playing streak (consecutive days played)&#10;     */&#10;    private fun updatePlayingStreak(editor: SharedPreferences.Editor, context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val today = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;        val lastPlayDate = prefs.getString(KEY_LAST_PLAY_DATE, &quot;&quot;)&#10;&#10;        val currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0)&#10;        val longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0)&#10;&#10;        if (lastPlayDate == today) {&#10;            // Already played today, don't update streak&#10;            return&#10;        }&#10;&#10;        val yesterday = Calendar.getInstance().apply {&#10;            add(Calendar.DAY_OF_YEAR, -1)&#10;        }&#10;        val yesterdayStr = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(yesterday.time)&#10;&#10;        val newStreak = if (lastPlayDate == yesterdayStr) {&#10;            // Consecutive day&#10;            currentStreak + 1&#10;        } else {&#10;            // Streak broken or first time playing&#10;            1&#10;        }&#10;&#10;        editor.putString(KEY_LAST_PLAY_DATE, today)&#10;        editor.putInt(KEY_CURRENT_STREAK, newStreak)&#10;&#10;        if (newStreak &gt; longestStreak) {&#10;            editor.putInt(KEY_LONGEST_STREAK, newStreak)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all player statistics&#10;     */&#10;    fun getPlayerStats(context: Context): PlayerStats {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        return PlayerStats(&#10;            easyGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;easy&quot;, 0),&#10;            mediumGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;medium&quot;, 0),&#10;            hardGamesCompleted = prefs.getInt(KEY_GAMES_COMPLETED + &quot;hard&quot;, 0),&#10;            easyGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;easy&quot;, 0),&#10;            mediumGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;medium&quot;, 0),&#10;            hardGamesPerfect = prefs.getInt(KEY_GAMES_PERFECT + &quot;hard&quot;, 0),&#10;            easyTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;easy&quot;, 0),&#10;            mediumTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;medium&quot;, 0),&#10;            hardTotalScore = prefs.getInt(KEY_TOTAL_SCORE + &quot;hard&quot;, 0),&#10;            dailyScore = prefs.getInt(KEY_DAILY_SCORE, 0),&#10;            weeklyScore = prefs.getInt(KEY_WEEKLY_SCORE, 0),&#10;            monthlyScore = prefs.getInt(KEY_MONTHLY_SCORE, 0),&#10;            currentStreak = prefs.getInt(KEY_CURRENT_STREAK, 0),&#10;            longestStreak = prefs.getInt(KEY_LONGEST_STREAK, 0),&#10;            totalTimePlayed = prefs.getLong(KEY_TOTAL_TIME_PLAYED, 0),&#10;            easyAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;easy&quot;, 0f),&#10;            mediumAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;medium&quot;, 0f),&#10;            hardAverageScore = prefs.getFloat(KEY_AVERAGE_SCORE + &quot;hard&quot;, 0f)&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Clear all statistics&#10;     */&#10;    fun clearAllStats(context: Context) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { clear() }&#10;    }&#10;&#10;    /**&#10;     * Format time in a human-readable way&#10;     */&#10;    fun formatPlayTime(totalSeconds: Long): String {&#10;        val hours = totalSeconds / 3600&#10;        val minutes = (totalSeconds % 3600) / 60&#10;        val seconds = totalSeconds % 60&#10;&#10;        return when {&#10;            hours &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dh %dm %ds&quot;, hours, minutes, seconds)&#10;            minutes &gt; 0 -&gt; String.format(Locale.getDefault(), &quot;%dm %ds&quot;, minutes, seconds)&#10;            else -&gt; String.format(Locale.getDefault(), &quot;%ds&quot;, seconds)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate completion rate for a difficulty&#10;     */&#10;    fun getCompletionRate(completed: Int, perfect: Int): Float {&#10;        return if (completed &gt; 0) (perfect.toFloat() / completed.toFloat()) * 100 else 0f&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/ThemeManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/kooshmeen/sudoku/utils/ThemeManager.kt" />
              <option name="updatedContent" value="/**&#10; * Theme manager for handling custom color schemes and theme persistence&#10; * Includes color contrast validation to prevent UI lockout scenarios&#10; */&#10;&#10;package com.kooshmeen.sudoku.utils&#10;&#10;import android.content.Context&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.luminance&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.core.content.edit&#10;import com.kooshmeen.sudoku.ui.theme.DefaultColors&#10;import kotlin.math.abs&#10;import kotlin.math.max&#10;import kotlin.math.min&#10;&#10;object ThemeManager {&#10;    private const val PREFS_NAME = &quot;SudokuTheme&quot;&#10;    private const val MIN_CONTRAST_RATIO = 3.0f // Minimum contrast ratio for accessibility&#10;    &#10;    // Keys for storing theme colors&#10;    private const val KEY_LIGHT_PRIMARY = &quot;light_primary&quot;&#10;    private const val KEY_LIGHT_SECONDARY = &quot;light_secondary&quot;&#10;    private const val KEY_LIGHT_TERTIARY = &quot;light_tertiary&quot;&#10;    private const val KEY_LIGHT_BACKGROUND = &quot;light_background&quot;&#10;    private const val KEY_LIGHT_SURFACE = &quot;light_surface&quot;&#10;    private const val KEY_LIGHT_ON_PRIMARY = &quot;light_on_primary&quot;&#10;    private const val KEY_LIGHT_ON_SECONDARY = &quot;light_on_secondary&quot;&#10;    private const val KEY_LIGHT_ON_TERTIARY = &quot;light_on_tertiary&quot;&#10;    private const val KEY_LIGHT_ON_BACKGROUND = &quot;light_on_background&quot;&#10;    private const val KEY_LIGHT_ON_SURFACE = &quot;light_on_surface&quot;&#10;    &#10;    private const val KEY_DARK_PRIMARY = &quot;dark_primary&quot;&#10;    private const val KEY_DARK_SECONDARY = &quot;dark_secondary&quot;&#10;    private const val KEY_DARK_TERTIARY = &quot;dark_tertiary&quot;&#10;    private const val KEY_DARK_BACKGROUND = &quot;dark_background&quot;&#10;    private const val KEY_DARK_SURFACE = &quot;dark_surface&quot;&#10;    private const val KEY_DARK_ON_PRIMARY = &quot;dark_on_primary&quot;&#10;    private const val KEY_DARK_ON_SECONDARY = &quot;dark_on_secondary&quot;&#10;    private const val KEY_DARK_ON_TERTIARY = &quot;dark_on_tertiary&quot;&#10;    private const val KEY_DARK_ON_BACKGROUND = &quot;dark_on_background&quot;&#10;    private const val KEY_DARK_ON_SURFACE = &quot;dark_on_surface&quot;&#10;&#10;    data class CustomTheme(&#10;        // Light theme colors&#10;        val lightPrimary: Color,&#10;        val lightSecondary: Color,&#10;        val lightTertiary: Color,&#10;        val lightBackground: Color,&#10;        val lightSurface: Color,&#10;        val lightOnPrimary: Color,&#10;        val lightOnSecondary: Color,&#10;        val lightOnTertiary: Color,&#10;        val lightOnBackground: Color,&#10;        val lightOnSurface: Color,&#10;        &#10;        // Dark theme colors&#10;        val darkPrimary: Color,&#10;        val darkSecondary: Color,&#10;        val darkTertiary: Color,&#10;        val darkBackground: Color,&#10;        val darkSurface: Color,&#10;        val darkOnPrimary: Color,&#10;        val darkOnSecondary: Color,&#10;        val darkOnTertiary: Color,&#10;        val darkOnBackground: Color,&#10;        val darkOnSurface: Color&#10;    )&#10;&#10;    /**&#10;     * Calculate contrast ratio between two colors&#10;     */&#10;    private fun calculateContrastRatio(color1: Color, color2: Color): Float {&#10;        val luminance1 = color1.luminance()&#10;        val luminance2 = color2.luminance()&#10;        val lighter = max(luminance1, luminance2)&#10;        val darker = min(luminance1, luminance2)&#10;        return (lighter + 0.05f) / (darker + 0.05f)&#10;    }&#10;&#10;    /**&#10;     * Validate color combination to prevent UI lockout&#10;     */&#10;    fun validateColorCombination(backgroundColor: Color, onBackgroundColor: Color, surfaceColor: Color, onSurfaceColor: Color): ValidationResult {&#10;        val backgroundContrast = calculateContrastRatio(backgroundColor, onBackgroundColor)&#10;        val surfaceContrast = calculateContrastRatio(surfaceColor, onSurfaceColor)&#10;        &#10;        val issues = mutableListOf&lt;String&gt;()&#10;        &#10;        if (backgroundContrast &lt; MIN_CONTRAST_RATIO) {&#10;            issues.add(&quot;Background and text colors have insufficient contrast (${String.format(&quot;%.1f&quot;, backgroundContrast)}:1, minimum: ${MIN_CONTRAST_RATIO}:1)&quot;)&#10;        }&#10;        &#10;        if (surfaceContrast &lt; MIN_CONTRAST_RATIO) {&#10;            issues.add(&quot;Surface and text colors have insufficient contrast (${String.format(&quot;%.1f&quot;, surfaceContrast)}:1, minimum: ${MIN_CONTRAST_RATIO}:1)&quot;)&#10;        }&#10;        &#10;        // Additional check for very similar colors&#10;        val backgroundSimilarity = abs(backgroundColor.luminance() - onBackgroundColor.luminance())&#10;        if (backgroundSimilarity &lt; 0.1f) {&#10;            issues.add(&quot;Background and text colors are too similar&quot;)&#10;        }&#10;&#10;        return ValidationResult(&#10;            isValid = issues.isEmpty(),&#10;            issues = issues&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Auto-adjust colors to ensure accessibility&#10;     */&#10;    fun ensureAccessibleColors(backgroundColor: Color, textColor: Color): Pair&lt;Color, Color&gt; {&#10;        val contrast = calculateContrastRatio(backgroundColor, textColor)&#10;        &#10;        if (contrast &gt;= MIN_CONTRAST_RATIO) {&#10;            return Pair(backgroundColor, textColor)&#10;        }&#10;        &#10;        // Adjust text color to ensure sufficient contrast&#10;        val backgroundLuminance = backgroundColor.luminance()&#10;        val adjustedTextColor = if (backgroundLuminance &gt; 0.5f) {&#10;            Color.Black // Use black text on light backgrounds&#10;        } else {&#10;            Color.White // Use white text on dark backgrounds&#10;        }&#10;        &#10;        return Pair(backgroundColor, adjustedTextColor)&#10;    }&#10;&#10;    /**&#10;     * Save custom theme to SharedPreferences&#10;     */&#10;    fun saveCustomTheme(context: Context, theme: CustomTheme) {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit {&#10;            // Light theme colors&#10;            putInt(KEY_LIGHT_PRIMARY, theme.lightPrimary.toArgb())&#10;            putInt(KEY_LIGHT_SECONDARY, theme.lightSecondary.toArgb())&#10;            putInt(KEY_LIGHT_TERTIARY, theme.lightTertiary.toArgb())&#10;            putInt(KEY_LIGHT_BACKGROUND, theme.lightBackground.toArgb())&#10;            putInt(KEY_LIGHT_SURFACE, theme.lightSurface.toArgb())&#10;            putInt(KEY_LIGHT_ON_PRIMARY, theme.lightOnPrimary.toArgb())&#10;            putInt(KEY_LIGHT_ON_SECONDARY, theme.lightOnSecondary.toArgb())&#10;            putInt(KEY_LIGHT_ON_TERTIARY, theme.lightOnTertiary.toArgb())&#10;            putInt(KEY_LIGHT_ON_BACKGROUND, theme.lightOnBackground.toArgb())&#10;            putInt(KEY_LIGHT_ON_SURFACE, theme.lightOnSurface.toArgb())&#10;            &#10;            // Dark theme colors&#10;            putInt(KEY_DARK_PRIMARY, theme.darkPrimary.toArgb())&#10;            putInt(KEY_DARK_SECONDARY, theme.darkSecondary.toArgb())&#10;            putInt(KEY_DARK_TERTIARY, theme.darkTertiary.toArgb())&#10;            putInt(KEY_DARK_BACKGROUND, theme.darkBackground.toArgb())&#10;            putInt(KEY_DARK_SURFACE, theme.darkSurface.toArgb())&#10;            putInt(KEY_DARK_ON_PRIMARY, theme.darkOnPrimary.toArgb())&#10;            putInt(KEY_DARK_ON_SECONDARY, theme.darkOnSecondary.toArgb())&#10;            putInt(KEY_DARK_ON_TERTIARY, theme.darkOnTertiary.toArgb())&#10;            putInt(KEY_DARK_ON_BACKGROUND, theme.darkOnBackground.toArgb())&#10;            putInt(KEY_DARK_ON_SURFACE, theme.darkOnSurface.toArgb())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load custom theme from SharedPreferences&#10;     */&#10;    fun loadCustomTheme(context: Context): CustomTheme {&#10;        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        &#10;        return CustomTheme(&#10;            // Light theme colors&#10;            lightPrimary = Color(prefs.getInt(KEY_LIGHT_PRIMARY, DefaultColors.LightPrimary.toArgb())),&#10;            lightSecondary = Color(prefs.getInt(KEY_LIGHT_SECONDARY, DefaultColors.LightSecondary.toArgb())),&#10;            lightTertiary = Color(prefs.getInt(KEY_LIGHT_TERTIARY, DefaultColors.LightTertiary.toArgb())),&#10;            lightBackground = Color(prefs.getInt(KEY_LIGHT_BACKGROUND, DefaultColors.LightBackground.toArgb())),&#10;            lightSurface = Color(prefs.getInt(KEY_LIGHT_SURFACE, DefaultColors.LightSurface.toArgb())),&#10;            lightOnPrimary = Color(prefs.getInt(KEY_LIGHT_ON_PRIMARY, DefaultColors.LightOnPrimary.toArgb())),&#10;            lightOnSecondary = Color(prefs.getInt(KEY_LIGHT_ON_SECONDARY, DefaultColors.LightOnSecondary.toArgb())),&#10;            lightOnTertiary = Color(prefs.getInt(KEY_LIGHT_ON_TERTIARY, DefaultColors.LightOnTertiary.toArgb())),&#10;            lightOnBackground = Color(prefs.getInt(KEY_LIGHT_ON_BACKGROUND, DefaultColors.LightOnBackground.toArgb())),&#10;            lightOnSurface = Color(prefs.getInt(KEY_LIGHT_ON_SURFACE, DefaultColors.LightOnSurface.toArgb())),&#10;            &#10;            // Dark theme colors&#10;            darkPrimary = Color(prefs.getInt(KEY_DARK_PRIMARY, DefaultColors.DarkPrimary.toArgb())),&#10;            darkSecondary = Color(prefs.getInt(KEY_DARK_SECONDARY, DefaultColors.DarkSecondary.toArgb())),&#10;            darkTertiary = Color(prefs.getInt(KEY_DARK_TERTIARY, DefaultColors.DarkTertiary.toArgb())),&#10;            darkBackground = Color(prefs.getInt(KEY_DARK_BACKGROUND, DefaultColors.DarkBackground.toArgb())),&#10;            darkSurface = Color(prefs.getInt(KEY_DARK_SURFACE, DefaultColors.DarkSurface.toArgb())),&#10;            darkOnPrimary = Color(prefs.getInt(KEY_DARK_ON_PRIMARY, DefaultColors.DarkOnPrimary.toArgb())),&#10;            darkOnSecondary = Color(prefs.getInt(KEY_DARK_ON_SECONDARY, DefaultColors.DarkOnSecondary.toArgb())),&#10;            darkOnTertiary = Color(prefs.getInt(KEY_DARK_ON_TERTIARY, DefaultColors.DarkOnTertiary.toArgb())),&#10;            darkOnBackground = Color(prefs.getInt(KEY_DARK_ON_BACKGROUND, DefaultColors.DarkOnBackground.toArgb())),&#10;            darkOnSurface = Color(prefs.getInt(KEY_DARK_ON_SURFACE, DefaultColors.DarkOnSurface.toArgb()))&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Reset theme to defaults&#10;     */&#10;    fun resetToDefaults(context: Context) {&#10;        val defaultTheme = CustomTheme(&#10;            lightPrimary = DefaultColors.LightPrimary,&#10;            lightSecondary = DefaultColors.LightSecondary,&#10;            lightTertiary = DefaultColors.LightTertiary,&#10;            lightBackground = DefaultColors.LightBackground,&#10;            lightSurface = DefaultColors.LightSurface,&#10;            lightOnPrimary = DefaultColors.LightOnPrimary,&#10;            lightOnSecondary = DefaultColors.LightOnSecondary,&#10;            lightOnTertiary = DefaultColors.LightOnTertiary,&#10;            lightOnBackground = DefaultColors.LightOnBackground,&#10;            lightOnSurface = DefaultColors.LightOnSurface,&#10;            &#10;            darkPrimary = DefaultColors.DarkPrimary,&#10;            darkSecondary = DefaultColors.DarkSecondary,&#10;            darkTertiary = DefaultColors.DarkTertiary,&#10;            darkBackground = DefaultColors.DarkBackground,&#10;            darkSurface = DefaultColors.DarkSurface,&#10;            darkOnPrimary = DefaultColors.DarkOnPrimary,&#10;            darkOnSecondary = DefaultColors.DarkOnSecondary,&#10;            darkOnTertiary = DefaultColors.DarkOnTertiary,&#10;            darkOnBackground = DefaultColors.DarkOnBackground,&#10;            darkOnSurface = DefaultColors.DarkOnSurface&#10;        )&#10;        saveCustomTheme(context, defaultTheme)&#10;    }&#10;&#10;    data class ValidationResult(&#10;        val isValid: Boolean,&#10;        val issues: List&lt;String&gt;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>